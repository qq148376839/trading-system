# 量化交易系统技术文档

**创建日期**: 2025-12-02  
**最后更新**: 2025-12-16  
**状态**: ✅ 已完成

---

## 📚 文档索引

### 文档结构

本文档整合了量化交易系统的所有技术内容，包括：
- 项目概述和技术栈
- 核心功能和系统架构
- 策略逻辑和流程详解
- 关键优化和实现细节
- 验证方法和诊断工具

### 快速导航

**想了解项目概况？** → 查看「1. 项目概述」

**想了解系统架构？** → 查看「2. 系统架构」

**想了解策略流程？** → 查看「3. 策略逻辑和流程」

**想了解优化内容？** → 查看「4. 关键优化」

**想了解技术实现？** → 查看「5. 技术实现」

---

# 1. 项目概述

## 📋 项目简介

长桥股票交易系统是一个基于 Node.js + Next.js 的量化交易平台，支持美股和港股的自动化交易、策略管理、订单追踪等功能。

## 🏗️ 技术栈

### 后端
- **运行时**: Node.js + TypeScript
- **框架**: Express.js
- **数据库**: PostgreSQL
- **交易API**: Longbridge SDK（长桥证券）
- **市场数据API**: Moomoo API（富途牛牛）

### 前端
- **框架**: Next.js 14 + React
- **UI库**: Tailwind CSS + Ant Design
- **状态管理**: React Hooks

## 🎯 核心功能

### 1. 量化交易策略系统
- **策略管理**: 创建、编辑、启动、停止策略
- **策略类型**: RECOMMENDATION_V1（基于市场分析的推荐策略）
- **状态管理**: IDLE → OPENING → HOLDING → CLOSING → IDLE
- **资金管理**: 策略资金分配、可用资金计算、标的级限制
- **动态持仓管理**: 动态止盈/止损调整

### 2. 订单管理
- **订单提交**: 买入/卖出订单提交
- **订单追踪**: 实时监控订单状态，自动更新价格
- **订单查询**: 今日订单、历史订单查询
- **状态同步**: 订单状态自动同步到数据库
- **重复提交防护**: 防止订单重复提交机制

### 3. 持仓监控
- **止盈/止损**: 自动检查止盈/止损触发条件
- **动态调整**: 根据市场波动动态调整止盈/止损
- **实时价格**: 获取当前价格，计算盈亏
- **卖出信号**: 策略生成卖出信号时自动执行

### 4. 交易记录
- **自动记录**: 订单成交时自动记录交易
- **盈亏计算**: 自动计算交易盈亏
- **交易查询**: 查询历史交易记录
- **数据源统一**: 统一使用 Longbridge API 作为数据源

---

# 2. 系统架构

## 📊 核心服务

### 1. StrategyScheduler (`strategy-scheduler.service.ts`)
**作用**: 策略调度器服务（核心服务）

**主要功能**:
- 策略生命周期管理（启动/停止）
- 策略周期执行（每分钟）
- 订单追踪（每30秒）
- 持仓监控
- 动态持仓管理（集成动态调整逻辑）
- 订单重复提交防护

**关键方法**:
- `runStrategyCycle`: 策略周期执行
- `processSymbol`: 标的处理（状态分支）
- `processHoldingPosition`: 持仓监控
- `processClosingPosition`: 平仓状态处理
- `trackPendingOrders`: 订单追踪（买入和卖出）
- `syncPositionState`: 状态同步
- `getTodayOrders`: 获取今日订单（使用缓存）

### 2. CapitalManager (`capital-manager.service.ts`)
**作用**: 资金管理器服务

**主要功能**:
- 资金分配管理
- 可用资金计算
- 标的级限制计算
- 资金申请和释放

**关键方法**:
- `getAvailableCapital`: 获取可用资金
- `requestAllocation`: 申请资金分配
- `releaseAllocation`: 释放资金分配

### 3. BasicExecutionService (`basic-execution.service.ts`)
**作用**: 订单执行服务

**主要功能**:
- 订单提交
- 订单等待成交
- 交易记录
- 订单价格更新

**关键方法**:
- `executeBuyIntent`: 执行买入意图
- `executeSellIntent`: 执行卖出意图
- `recordTrade`: 记录交易（公开方法，供订单追踪调用）

### 4. StateManager (`state-manager.service.ts`)
**作用**: 状态管理器服务

**主要功能**:
- 策略实例状态管理
- 状态持久化
- 状态恢复（服务重启时）

### 5. MarketDataService (`market-data.service.ts`)
**作用**: 市场数据服务

**主要功能**:
- 市场数据获取
- 数据缓存（减少API调用）
- 价格查询

### 6. TradingRecommendationService (`trading-recommendation.service.ts`)
**作用**: 交易推荐服务

**主要功能**:
- 交易信号生成
- 市场分析
- ATR（平均真实波幅）计算

### 7. DynamicPositionManager (`dynamic-position-manager.service.ts`)
**作用**: 动态持仓管理器服务

**主要功能**:
- 动态止盈/止损调整
- 根据市场波动调整风险参数
- 持仓风险管理

### 8. OrderPreventionMetrics (`order-prevention-metrics.service.ts`)
**作用**: 订单重复提交防护服务

**主要功能**:
- 订单提交缓存
- 重复提交检测
- 监控指标记录

## 🔄 数据流

```
策略周期触发（每分钟）
  ↓
生成交易信号
  ↓
申请资金
  ↓
提交订单（防重复提交）
  ↓
订单追踪（每30秒，监控状态）
  ↓
订单成交 → 更新状态 → 记录交易
  ↓
持仓监控（检查止盈/止损）
  ↓
动态调整止盈/止损（可选）
  ↓
触发卖出 → 提交卖出订单
  ↓
卖出订单追踪
  ↓
卖出成交 → 更新状态 → 释放资金
```

## 🔑 关键决策

### 1. 订单状态管理
- **方案**: 完全基于API实时状态，不依赖数据库状态
- **原因**: 避免数据库状态滞后导致的错误
- **实现**: 使用 `mapOrderData` 处理订单数据，根据 `executedQuantity` 自动修正状态

### 2. 订单追踪策略
- **方案**: 先筛选出未成交订单（基于API状态），后同步状态到数据库
- **原因**: 确保筛选基于最新的API状态，避免已成交订单进入价格更新流程
- **实现**: 完全基于API状态筛选（方案二）

### 3. 日志优化
- **方案**: 降低常规流程日志级别，只保留关键信息
- **原因**: 提高日志可读性，减少噪音
- **实现**: 将常规流程日志改为 `debug` 级别，关键操作保留 `log` 级别

### 4. 状态同步
- **方案**: 自动同步实际持仓到策略实例状态
- **原因**: 处理手动买入或状态不同步的情况
- **实现**: `syncPositionState` 方法，自动从实际持仓推断状态

### 5. 数据源统一
- **方案**: 统一使用 Longbridge API 作为数据源
- **原因**: 避免数据不一致，提高数据准确性
- **实现**: 移除冗余的交易记录，统一从 Longbridge API 获取

---

# 3. 策略逻辑和流程

## 🔄 策略状态流转

### 状态定义

| 状态 | 说明 | 处理逻辑 |
|------|------|----------|
| `IDLE` | 空闲状态 | 生成买入信号，提交买入订单 |
| `OPENING` | 买入中 | 监控买入订单状态，成交后转为 `HOLDING` |
| `HOLDING` | 持仓中 | 检查止盈/止损，触发卖出条件时转为 `CLOSING` |
| `CLOSING` | 卖出中 | 监控卖出订单状态，成交后转为 `IDLE` |
| `COOLDOWN` | 冷却期 | 暂未使用 |

### 状态流转图

```
IDLE → OPENING → HOLDING → CLOSING → IDLE
         ↓          ↓          ↓
      (买入)    (持仓监控)  (卖出监控)
```

## 🎯 核心流程

### 1. 策略周期执行 (`runStrategyCycle`)

**触发时机**: 每分钟执行一次（可配置）

**执行流程**:
1. 获取策略配置和股票池
2. 遍历每个标的，调用 `processSymbol` 处理
3. 订单追踪由独立的定时器处理（每30秒）

### 2. 标的处理 (`processSymbol`)

**处理逻辑**:

```typescript
if (currentState === 'IDLE') {
  // 检查是否有实际持仓
  if (hasPosition) {
    // 同步状态为 HOLDING
    await syncPositionState(...);
    return;
  }
  
  // 检查是否有未成交订单
  if (hasPendingOrder) {
    return; // 跳过处理
  }
  
  // 生成买入信号
  const signal = await generateSignal(...);
  if (signal === 'BUY') {
    // 申请资金并提交买入订单
    await executeBuyIntent(...);
  }
}

if (currentState === 'HOLDING') {
  // 持仓监控：检查止盈/止损
  await processHoldingPosition(...);
}

if (currentState === 'CLOSING') {
  // 平仓监控：检查卖出订单状态
  await processClosingPosition(...);
}

if (currentState === 'OPENING') {
  // 跳过处理，由订单追踪处理
  return;
}
```

### 3. 买入流程

1. **IDLE 状态** → 生成买入信号 → 申请资金 → 提交买入订单
2. **OPENING 状态** → 订单追踪监控 → 订单成交 → **HOLDING 状态**

### 4. 持仓监控流程 (`processHoldingPosition`)

**执行流程**:
1. 获取持仓上下文（入场价、止损、止盈、数量）
2. 获取当前价格
3. 检查触发条件：
   - 止损触发：`currentPrice <= stopLoss` → 执行卖出
   - 止盈触发：`currentPrice >= takeProfit` → 执行卖出
   - 策略信号：生成 `SELL` 信号 → 执行卖出
4. 如果触发卖出条件，执行卖出操作

**关键代码**:
```typescript
// 检查止盈/止损
if (stopLoss && currentPrice <= stopLoss) {
  shouldSell = true;
  exitReason = 'STOP_LOSS';
} else if (takeProfit && currentPrice >= takeProfit) {
  shouldSell = true;
  exitReason = 'TAKE_PROFIT';
}

// 检查策略信号
const signal = await strategyInstance.generateSignal(...);
if (signal === 'SELL') {
  shouldSell = true;
  exitReason = 'STRATEGY_SIGNAL';
}

// 执行卖出
if (shouldSell) {
  await executeSellIntent(...);
}
```

### 5. 卖出流程

1. **CLOSING 状态** → 订单追踪监控 → 订单成交 → **IDLE 状态**
2. 释放资金分配

### 6. 订单追踪 (`trackPendingOrders`)

**执行时机**: 每30秒执行一次（独立定时器）

**执行流程**:
1. **获取今日订单**：使用 `getTodayOrders(false)` 获取（使用60秒缓存）
2. **查询数据库订单**：查询所有订单（不限制状态）
3. **先筛选出未成交订单**（基于API实时状态）：
   - 严格排除所有已完成的订单（`FilledStatus`, `CanceledStatus`, `RejectedStatus` 等）
   - 只包含未成交的订单状态（`NotReported`, `NewStatus`, `WaitToNew` 等）
4. **同步订单状态到数据库**（在筛选之后）
5. **处理已成交订单**：更新策略实例状态，记录交易
6. **更新订单价格**（如果需要）：价格差异超过2%时自动更新

**关键优化**:
- 使用 `mapOrderData` 处理订单数据，确保状态正确（根据 `executedQuantity` 自动修正）
- 完全基于API实时状态筛选，不依赖数据库状态
- 先筛选后同步，避免状态滞后问题

### 7. 状态同步 (`syncPositionState`)

**触发时机**: 检测到有实际持仓但状态是 `IDLE` 时

**执行流程**:
1. 获取实际持仓信息（成本价、数量）
2. 计算默认止盈/止损（如果没有）：
   - 止损：成本价 × 0.95（-5%）
   - 止盈：成本价 × 1.10（+10%）
3. 更新策略实例状态为 `HOLDING`
4. 保存上下文（入场价、止损、止盈、数量）

## 💰 资金管理

### 资金分配流程

1. **获取可用资金** (`getAvailableCapital`)
   - 计算策略总资金
   - 扣除已分配资金
   - 返回可用资金

2. **申请资金** (`requestAllocation`)
   - 检查标的级限制（每个标的的最大持仓金额）
   - 检查可用资金是否充足
   - 分配资金并记录

3. **释放资金** (`releaseAllocation`)
   - 卖出订单成交时释放资金
   - 订单取消/拒绝时释放资金

### 标的级限制

**计算方式**:
```typescript
maxPositionPerSymbol = totalStrategyCapital / symbolPoolSize
```

**应用场景**:
- 计算买入数量时，使用 `Math.min(availableCapital, maxPositionPerSymbol)`
- 确保每个标的的持仓不超过限制

## 📊 订单管理

### 订单状态

| 状态 | 说明 | 处理方式 |
|------|------|----------|
| `NotReported` | 待提交 | 监控，不修改价格 |
| `NewStatus` | 已委托 | 监控，价格差异>2%时更新 |
| `WaitToNew` | 已提待报 | 监控，价格差异>2%时更新 |
| `FilledStatus` | 已成交 | 排除，更新策略状态 |
| `PartialFilledStatus` | 部分成交 | 排除（已成交部分不能修改） |
| `CanceledStatus` | 已取消 | 排除，释放资金 |
| `RejectedStatus` | 已拒绝 | 排除，释放资金 |

### 订单价格更新

**触发条件**:
- 订单状态为未成交（`NewStatus`, `WaitToNew` 等）
- 订单类型支持修改（限价单 `LO`，不支持市价单 `MO`）
- 当前价格与订单价格差异超过2%

**更新逻辑**:
```typescript
const priceDiff = Math.abs(currentPrice - orderPrice) / orderPrice;
if (priceDiff > 0.02) {
  const newPrice = currentPrice * 1.01; // 比当前价格高1%，确保能成交
  await replaceOrder({ orderId, quantity, price: newPrice });
}
```

---

# 4. 关键优化

## 🎯 优化时间线

### 2025-12-02: 订单修改逻辑修复 ✅

**问题**: 已成交订单（`FilledStatus`）仍然被尝试修改，导致错误码602012

**根本原因**:
1. SDK返回的状态可能是数字格式（如 `5`），而不是字符串 `FilledStatus`
2. `getTodayOrders` 直接使用SDK原始数据，没有经过 `mapOrderData` 处理
3. `mapOrderData` 函数会根据 `executedQuantity` 自动修正状态，但未被使用

**解决方案**:
1. **导出 `mapOrderData` 函数**：在 `orders.ts` 中将 `mapOrderData` 改为 `export function`
2. **在 `getTodayOrders` 中使用 `mapOrderData`**：确保所有订单数据都经过状态修正
3. **完全基于API状态筛选**：
   - 移除数据库状态过滤，查询所有订单
   - 先筛选出未成交订单（基于API实时状态）
   - 后同步订单状态到数据库

**效果**:
- ✅ 已成交订单不再进入价格更新流程
- ✅ 不再出现 `602012` 错误
- ✅ 订单状态自动修正（根据 `executedQuantity`）

### 2025-12-02: 卖出监控完善 ✅

**问题**:
- 原代码只监控买入订单，没有处理卖出订单
- `processSymbol` 方法只处理 `IDLE` 状态，没有处理 `HOLDING` 状态的持仓
- 没有检查止盈/止损触发条件

**解决方案**:
1. **扩展 `processSymbol` 方法**：添加对 `HOLDING` 和 `CLOSING` 状态的处理
2. **新增 `processHoldingPosition` 方法**：持仓监控，检查止盈/止损
3. **新增 `processClosingPosition` 方法**：平仓状态处理
4. **扩展订单追踪**：查询所有订单（买入和卖出），处理卖出订单成交

**效果**:
- ✅ 完整的买入→持仓→卖出流程
- ✅ 自动检查止盈/止损
- ✅ 卖出订单正确追踪

### 2025-12-02: 状态同步功能 ✅

**问题**: 状态是 `IDLE` 但实际有持仓，导致持仓监控不工作

**解决方案**:
- 添加 `syncPositionState` 方法
- 当检测到有实际持仓但状态是 `IDLE` 时，自动同步状态为 `HOLDING`
- 从实际持仓中获取成本价、数量等信息
- 如果没有止盈/止损，使用默认值（止损：-5%，止盈：+10%）

**效果**:
- ✅ 自动同步实际持仓到策略实例状态
- ✅ 处理手动买入或状态不同步的情况

### 2025-12-02: 日志优化 ✅

**优化内容**:
1. **降低日志级别**：将常规流程日志从 `log` 改为 `debug`
2. **移除冗余日志**：移除重复和不必要的日志
3. **简化日志内容**：使用更简洁的格式

**保留的关键日志**（`log` 级别）:
- 策略启动/停止
- 买入/卖出订单已成交
- 资金申请被拒绝
- 订单价格更新成功
- 生成交易信号

**效果**:
- ✅ 日志更简洁，关键信息更突出
- ✅ 减少日志噪音，提高可读性

### 2025-12-02: 交易记录管理完善 ✅

**问题**:
- `recordTrade` 方法只在订单立即成交时调用
- 如果订单在后续追踪中才成交，交易记录可能没有被记录

**解决方案**:
- 将 `recordTrade` 改为公开方法
- 在订单追踪中记录交易：当发现订单已成交时，获取订单详情和手续费，调用 `recordTrade` 方法

**效果**:
- ✅ 所有成交订单都被正确记录
- ✅ 交易记录完整准确

### 2025-12-11: 量化交易订单管理重构 ✅

**问题**:
- 交易记录数据源不统一
- 存在冗余的交易记录
- 交易数量统计不准确

**解决方案**:
- 统一使用 Longbridge API 作为数据源
- 移除冗余的交易记录
- 准确统计交易数量
- 更新信号日志状态

**效果**:
- ✅ 数据源统一，数据准确性提高
- ✅ 交易记录准确统计
- ✅ 信号日志状态正确更新

### 2025-12-12: 订单重复提交防护机制 ✅

**问题**:
- 订单可能被重复提交
- 缺少重复提交检测机制

**解决方案**:
- 添加订单提交缓存（60秒）
- 实现重复提交检测
- 添加监控指标记录

**效果**:
- ✅ 防止订单重复提交
- ✅ 提高系统稳定性
- ✅ 监控指标完善

---

# 5. 技术实现

## 🛠️ 关键文件

### 1. `api/src/services/strategy-scheduler.service.ts`
**核心服务文件**

**关键方法**:
- `processSymbol`: 状态分支处理
- `processHoldingPosition`: 持仓监控
- `processClosingPosition`: 平仓状态处理
- `trackPendingOrders`: 订单追踪（买入和卖出）
- `syncPositionState`: 状态同步
- `getTodayOrders`: 使用 `mapOrderData` 处理订单数据

**缓存机制**:
- 持仓缓存：30秒TTL
- 今日订单缓存：60秒TTL
- 订单提交缓存：60秒TTL（防重复提交）

### 2. `api/src/services/basic-execution.service.ts`
**订单执行服务**

**关键方法**:
- `recordTrade`: 改为公开方法，供订单追踪调用
- `executeBuyIntent`: 执行买入意图
- `executeSellIntent`: 执行卖出意图

### 3. `api/src/routes/orders.ts`
**订单路由**

**关键函数**:
- `mapOrderData`: 导出函数，根据 `executedQuantity` 自动修正订单状态

## 💻 关键代码片段

### 订单数据状态修正

```typescript
// mapOrderData 函数中的智能状态修正
if (executedQty > 0) {
  if (executedQty >= quantity) {
    // 全部成交
    if (status !== 'FilledStatus' && status !== 'PartialFilledStatus') {
      status = 'FilledStatus';
    }
  } else {
    // 部分成交
    if (status !== 'FilledStatus' && status !== 'PartialFilledStatus') {
      status = 'PartialFilledStatus';
    }
  }
}
```

### 基于API状态筛选

```typescript
// 先筛选出未成交的订单（基于API实时状态）
const pendingOrders = strategyOrders.rows.filter((dbOrder: any) => {
  const apiOrder = todayOrders.find(...);
  const status = normalizeOrderStatus(apiOrder.status);
  
  // 严格排除所有已完成的订单
  if (completedStatuses.includes(status)) {
    return false;
  }
  
  // 只包含未成交的订单状态
  return pendingStatuses.includes(status);
});
```

### 持仓监控

```typescript
// 检查止盈/止损
if (stopLoss && currentPrice <= stopLoss) {
  shouldSell = true;
  exitReason = 'STOP_LOSS';
} else if (takeProfit && currentPrice >= takeProfit) {
  shouldSell = true;
  exitReason = 'TAKE_PROFIT';
}
```

### 订单重复提交防护

```typescript
// 检查订单提交缓存
const cacheKey = `${strategyId}-${symbol}-${side}`;
const cached = this.orderSubmissionCache.get(cacheKey);
if (cached && Date.now() - cached.timestamp < this.ORDER_CACHE_TTL) {
  // 60秒内已提交过相同订单，跳过
  return;
}

// 记录提交时间
this.orderSubmissionCache.set(cacheKey, { timestamp: Date.now() });
```

---

# 6. 验证和诊断

## ✅ 验证要点

### 买入监控
- ✅ 买入订单提交后，状态更新为 `OPENING`
- ✅ 订单追踪检测到成交后，状态更新为 `HOLDING`
- ✅ 交易记录被正确记录到 `auto_trades` 表

### 持仓监控
- ✅ `HOLDING` 状态的标的会被检查止盈/止损
- ✅ 触发止损时，自动执行卖出
- ✅ 触发止盈时，自动执行卖出
- ✅ 策略生成卖出信号时，自动执行卖出

### 卖出监控
- ✅ 卖出订单提交后，状态更新为 `CLOSING`
- ✅ 订单追踪检测到成交后，状态更新为 `IDLE`
- ✅ 资金分配被正确释放
- ✅ 交易记录被正确更新（平仓记录）

### 订单修改逻辑
- ✅ 已成交订单不再进入价格更新流程
- ✅ 不再出现 `602012` 错误
- ✅ 订单状态自动修正（根据 `executedQuantity`）

### 状态同步
- ✅ 有实际持仓但状态是 `IDLE` 时，自动同步为 `HOLDING`
- ✅ 从实际持仓中获取成本价、数量等信息
- ✅ 自动设置默认止盈/止损

## 🔍 诊断方法

### 使用监控状态API

**API**: `GET /api/quant/strategies/:id/monitoring-status`

**返回数据示例**:
```json
{
  "success": true,
  "data": {
    "strategy": {
      "id": 3,
      "name": "测试策略",
      "type": "RECOMMENDATION_V1",
      "status": "RUNNING"
    },
    "instances": [
      {
        "symbol": "AAPL.US",
        "state": "HOLDING",
        "entryPrice": 150.00,
        "stopLoss": 145.00,
        "takeProfit": 160.00,
        "quantity": 10,
        "currentPrice": 155.00,
        "pnl": 50.00,
        "pnlPercent": 3.33,
        "hasActualPosition": true,
        "actualPositionQuantity": 10,
        "pendingBuyOrders": 0,
        "pendingSellOrders": 0
      }
    ],
    "summary": {
      "total": 5,
      "idle": 2,
      "opening": 0,
      "holding": 3,
      "closing": 0
    }
  }
}
```

### 日志关键词

搜索以下关键词来确认功能是否正常：

- ✅ `持仓监控 - 检查止盈/止损` - 持仓监控已执行
- ✅ `买入订单已成交，状态更新为HOLDING` - 买入成交
- ✅ `卖出订单已成交，状态更新为IDLE` - 卖出成交
- ✅ `已完成（FilledStatus），已排除` - 订单筛选正常
- ⚠️ `持仓状态但无上下文` - 上下文缺失
- ⚠️ `无法获取当前价格` - 价格获取失败

---

# 7. 后续优化建议

## 🚀 优化方向

### 1. 实时价格监控
- 考虑使用 WebSocket 实时推送价格，而不是每分钟轮询
- 减少 API 调用频率
- 提高价格更新实时性

### 2. 部分成交处理
- 当前只处理完全成交的情况
- 可以添加部分成交的处理逻辑
- 支持部分成交后的持仓管理

### 3. 冷却期管理
- 卖出后可以设置冷却期，避免立即重新买入
- 当前 `COOLDOWN` 状态已定义但未使用
- 可以添加冷却期配置

### 4. 策略信号优化
- 持仓状态下，策略可以生成更精确的卖出信号
- 考虑添加持仓时间、收益率等因素
- 优化信号生成算法

### 5. 动态持仓管理增强
- 完善动态止盈/止损调整逻辑
- 添加更多风险管理参数
- 优化市场波动响应机制

---

# 8. 相关文档

- [代码地图](../../CODE_MAP.md) - 项目文件结构和调用关系
- [订单修改逻辑审查](251212-订单修改逻辑审阅文档.md) - 订单修改逻辑修复详情
- [动态交易策略文档](../features/251203-动态交易策略文档.md) - 动态交易策略详细说明
- [量化交易订单管理重构文档](../features/251211-量化交易订单管理重构文档.md) - 订单管理重构详情

---

**文档版本**：v2.0  
**最后更新**：2025-12-16  
**状态**：已完成 ✅





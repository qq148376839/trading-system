# 为历史订单创建信号数据方案

## 📋 问题分析

### 当前情况

**回填脚本执行结果**：
- ❌ 匹配的订单数：0
- ⚠️ 未找到信号的订单数：45
- ⚠️ 未找到订单的信号数：29,858

**问题根源**：
1. **历史订单没有信号**：信号功能开发前的订单，没有对应的信号记录
2. **时间窗口匹配失败**：即使有信号，时间差可能超过匹配窗口
3. **数据不完整**：历史数据缺少信号关联

### 用户建议 ✅ **非常好的想法**

**建议**：对于匹配不到的已成交订单，可以根据订单情况（买入、卖出）来补充创建信号数据。

**优势**：
- ✅ 完善历史数据：为历史订单补充信号记录
- ✅ 数据完整性：订单和信号一一对应
- ✅ 便于分析：可以基于信号进行策略分析
- ✅ 不影响现有数据：只补充缺失的数据

---

## 🎯 解决方案

### 方案概述

创建一个新脚本，为历史订单补充信号数据：

1. **查找没有signal_id的已成交订单**
2. **为这些订单创建对应的信号记录**
3. **将订单关联到新创建的信号**
4. **设置信号状态为EXECUTED**（因为订单已成交）

---

## 📝 脚本功能

### 脚本名称

`create-signals-for-historical-orders.ts`

### 功能说明

1. **查找未关联订单**：
   - 查找`execution_orders`表中`signal_id IS NULL`的订单
   - 默认只处理已成交订单（`FilledStatus`, `PartialFilledStatus`）
   - 可选：处理所有订单（包括已取消、已拒绝）

2. **创建信号记录**：
   - 根据订单的`side`创建`BUY`或`SELL`信号
   - 使用订单的`executed_price`或`price`作为信号价格
   - 使用订单的`created_at`作为信号创建时间
   - 设置信号状态：
     - `EXECUTED`：订单已成交
     - `REJECTED`：订单被拒绝
     - `IGNORED`：订单被取消

3. **关联订单**：
   - 将新创建的信号ID更新到订单的`signal_id`字段
   - 确保订单和信号一一对应

4. **元数据记录**：
   - 在信号的`metadata`中记录订单信息
   - 标记信号来源为`historical_order_backfill`

---

## 🚀 使用方法

### 预览模式（推荐先运行）

```bash
# 只处理已成交订单（默认）
npm run create-signals-for-orders:dry-run

# 处理所有订单（包括已取消、已拒绝）
npm run create-signals-for-orders:dry-run -- --include-all
```

### 实际执行

```bash
# 只处理已成交订单（推荐）
npm run create-signals-for-orders

# 处理所有订单
npm run create-signals-for-orders -- --include-all
```

---

## 📊 预期效果

### 处理45个未关联订单

**预期结果**：
- ✅ 创建45个信号记录
- ✅ 关联45个订单到信号
- ✅ 信号状态：EXECUTED（因为订单已成交）

### 数据完整性提升

**清理前**：
- 未关联订单：45个
- 信号和订单不匹配

**清理后**：
- 未关联订单：0个（或大幅减少）
- 所有已成交订单都有对应的信号记录

---

## ⚠️ 注意事项

### 1. 数据备份

**执行前必须备份数据库**：
```bash
pg_dump -U your_user -d your_database > backup_$(date +%Y%m%d_%H%M%S).sql
```

### 2. 预览模式

**强烈建议先运行预览模式**：
- 查看会创建多少信号
- 确认信号数据正确
- 避免创建错误数据

### 3. 信号时间

**信号创建时间**：
- 使用订单的`created_at`作为信号创建时间
- 确保信号和订单的时间一致
- 便于后续时间窗口匹配

### 4. 信号状态

**信号状态设置**：
- 已成交订单 → `EXECUTED`
- 被拒绝订单 → `REJECTED`
- 已取消订单 → `IGNORED`

---

## 🔍 验证方法

### 执行后验证

```sql
-- 检查未关联订单数量（应该为0或大幅减少）
SELECT COUNT(*) as unlinked_orders
FROM execution_orders
WHERE signal_id IS NULL
  AND current_status IN ('FILLED', 'PARTIALLY_FILLED');

-- 检查新创建的信号
SELECT 
  COUNT(*) as new_signals,
  signal_type,
  status
FROM strategy_signals
WHERE metadata->>'source' = 'historical_order_backfill'
GROUP BY signal_type, status;

-- 检查订单和信号的关联
SELECT 
  eo.order_id,
  eo.symbol,
  eo.side,
  ss.signal_type,
  ss.status,
  ss.created_at
FROM execution_orders eo
JOIN strategy_signals ss ON eo.signal_id = ss.id
WHERE ss.metadata->>'source' = 'historical_order_backfill'
ORDER BY eo.created_at DESC
LIMIT 20;
```

---

## 📈 执行步骤

### 步骤1：预览模式

```bash
npm run create-signals-for-orders:dry-run
```

**查看结果**：
- 会创建多少信号
- 会关联多少订单
- 确认数据正确

### 步骤2：实际执行

```bash
npm run create-signals-for-orders
```

### 步骤3：验证结果

运行上述SQL查询，确认：
- 未关联订单数量减少
- 新创建的信号数据正确
- 订单和信号关联成功

### 步骤4：重新运行回填脚本

```bash
npm run backfill-signals:dry-run
```

**预期效果**：
- 未找到信号的订单数应该为0（或大幅减少）
- 匹配成功率提升

---

## 💡 建议

### 推荐执行顺序

1. ✅ **先执行**：为历史订单创建信号（本脚本）
2. ✅ **再执行**：运行回填脚本匹配剩余订单
3. ✅ **最后**：清理过期的PENDING信号

### 数据完整性

**完整的数据流程**：
1. 历史订单 → 创建信号 → 关联订单
2. 新订单 → 自动创建信号 → 自动关联
3. 定期清理 → 清理过期信号 → 保持数据量合理

---

## 📝 总结

### ✅ **方案优势**

1. ✅ **完善历史数据**：为历史订单补充信号记录
2. ✅ **数据完整性**：订单和信号一一对应
3. ✅ **便于分析**：可以基于信号进行策略分析
4. ✅ **不影响现有数据**：只补充缺失的数据

### 🎯 **预期效果**

- ✅ 45个未关联订单都有对应的信号记录
- ✅ 数据完整性大幅提升
- ✅ 回填脚本匹配成功率提升

---

**方案创建时间**：2025-12-16  
**执行结果**：✅ 成功为43个历史订单创建信号数据  
**详细结果**：请参考 [信号创建成功总结](251216-历史订单信号创建成功总结.md)





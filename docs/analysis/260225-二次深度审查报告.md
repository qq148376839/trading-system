# 260225 订单数据逆向审查报告 — 二次深度审查

**审查日期**: 2026-02-25
**审查目标**: `docs/analysis/260225-订单数据逆向审查报告.md`
**审查性质**: 第一性原理鞭尸级批判 + 遗漏补充
**审查范围**: 代码物理证据逐行验证

---

## 零、最业余的一个点

**Line 949 的 isTslpFill 诊断是整份报告的耻辱。**

报告声称：
> "SELECT 未包含 execution_stage/remark, 且 remark 列不存在于 DB"

实际物理证据：
- `000_init_schema.sql:360` 清清楚楚写着 `execution_stage INTEGER DEFAULT 1` — **列存在**
- `remark` 列确实不存在 — 这部分正确
- **真正的问题**：SELECT 查询（`strategy-scheduler.service.ts:551`）没有选 `execution_stage` 列：
  ```sql
  SELECT eo.order_id, eo.symbol, eo.side, eo.price, eo.quantity,
         eo.created_at, eo.current_status, eo.fill_processed
  -- 缺少: eo.execution_stage
  ```
- 所以 `dbOrder.execution_stage` 是 `undefined`（JS 层面），不是因为 DB 没有这列

**报告连 schema 都没验证就下结论"列不存在"，这不是分析，这是猜测。** 更致命的是：报告提出的 Fix 2（用 `protectionOrderId === dbOrder.order_id` 匹配）在逻辑上方向对了，但忽略了一个关键事实 —— **即使 isTslpFill 被修好，line 993 的 spread 语法意味着非 TSLP 退出永远不会清除 `protectionOrderId`**。报告修了检测，没修清理，SPY 686 Put 的 -62% 惨剧仍会重演。

---

## 一、报告结论的物理证据验证

### 1.1 发现 1（deviation 公式自杀）— 验证: 正确，但不够深入

**报告结论**: deviation 公式将 TSLPPCT 压到 8%。
**代码验证** (`strategy-scheduler.service.ts:874-892`):

```typescript
if (is0DTE && context.intent?.entryPrice) {
  const signalPrice = parseFloat(String(context.intent.entryPrice));
  const filledPrice = avgPrice;
  if (filledPrice > 0 && signalPrice > 0) {
    const actualDeviation = Math.abs((filledPrice - signalPrice) / signalPrice);
    if (actualDeviation > 0.02) {  // 2% 阈值太低
      const adjustment = Math.min(actualDeviation * 50, trailingPct - 8);  // 系数50太大
      if (adjustment > 0) {
        const adjustedTrailing = Math.max(trailingPct - adjustment, 8);  // 下限8%太低
        trailingPct = adjustedTrailing;
      }
    }
  }
}
```

**物理证据确认**: 代码确实存在，逻辑如报告所述。

**报告遗漏的补充**:
- 这个公式的数学含义是：信号价与成交价偏差每增加 1%，trailing 减少 0.5 个百分点
- 对于 0DTE 期权，信号价与成交价偏差 20-30% 很常见（期权价格波动大、延迟高）
- 偏差 20% → adjustment = min(10, 37) = 10 → trailing 从 45% 降到 35%
- 偏差 50% → adjustment = min(25, 37) = 25 → trailing 从 45% 降到 20%
- 偏差 74%+ → adjustment = 37（上限）→ trailing 降到 8%（最小值）
- **任何偏差超过 10% 都不应该调整 trailing — 大偏差说明行情剧烈波动，此时更需要宽 trailing 而非窄 trailing。公式的经济学逻辑是反的。**

### 1.2 发现 2（SPY 686 Put 无保护）— 验证: 正确，但根因分析不完整

**报告结论**: `protectionOrderId` 残留导致 `!context.protectionOrderId` 为 false，跳过 TSLPPCT。
**代码验证** (`strategy-scheduler.service.ts:860`):

```typescript
if (isOptionAsset && !context.protectionOrderId) {
  // 提交 TSLPPCT...
}
```

**物理证据确认**: 逻辑正确。如果 `protectionOrderId` 残留，条件为 false，跳过提交。

**报告遗漏的根因链**:
1. 第一轮买入 → TSLPPCT 提交成功 → `protectionOrderId` = "xxx"
2. 软件退出卖出 → 成交 → 转 IDLE
3. **但 IDLE 转换时不清除 `protectionOrderId`**（见下方遗漏 1）
4. 第二轮买入 → `!context.protectionOrderId` 为 false → 跳过 TSLPPCT
5. 同时 broker 端第一轮的 TSLPPCT 仍然挂着（见下方遗漏 2）

报告只说了第 4 步，没分析为什么第 3 步不清除（因为 isTslpFill 检测永远 false），也没提第 5 步的 TSLPPCT 悬挂风险。

### 1.3 发现 3（16-23 秒闪电平仓）— 验证: 正确

数据可信。dynamic-exit 在第一个 5 秒监控周期就触发退出，属于时间止损或结构确认逻辑过于激进。这是 `option-dynamic-exit.service.ts` 的设计问题，不在本次审查范围内，但应标记为后续优化项。

### 1.4 发现 4（TSLPPCT 提交被拒）— 验证: 正确，但竞态描述不精确

报告说"软件先退出 → TSLPPCT 后提交 → 被拒"。实际时间线更复杂：
1. 买入成交 → 进入 fill 处理
2. 更新状态为 HOLDING
3. 提交 TSLPPCT（async，需要 1-3 秒网络往返）
4. 同时，dynamic-exit monitor 在下一个 5 秒周期检测到 HOLDING → 立即评估退出
5. 如果退出条件满足 → 提交 SELL
6. SELL 成交 → qty 归零
7. TSLPPCT 提交到达 broker → broker 检测 qty=0 → REJECTED

**核心问题**: TSLPPCT 提交和退出评估之间没有互斥机制。

### 1.5 发现 5（LIT 全部取消）— 验证: 正确，无补充

commit 2fda7ae 移除 LIT 调用是正确决策。LIT 与 TSLPPCT + 软件退出三者并存会互相打架。

---

## 二、报告遗漏的 6 个致命细节

### 遗漏 1: `protectionOrderId` 在非 TSLP 退出时永远不清除 (P0-CRITICAL)

**位置**: `strategy-scheduler.service.ts:984-994`

```typescript
await strategyInstance.updateState(instanceKeySymbol, 'IDLE', {
  lastExitTime: new Date().toISOString(),
  dailyTradeCount: prevDailyTradeCount + 1,
  dailyRealizedPnL: newDailyPnL,
  consecutiveLosses: newConsecutiveLosses,
  lastTradeDirection: tradeDirection,
  lastTradePnL: tradePnL,
  takeProfitOrderId: undefined,    // ← 这个会被转为 null（Fix 4c）
  ...(isTslpFill
    ? { exitReason: 'TSLPPCT_FILLED',
        protectionOrderId: undefined,      // ← 只在 isTslpFill=true 时设置
        protectionTrailingPct: undefined }
    : {}),                                  // ← false 时展开为空对象：什么都不做
});
```

**逻辑推演**:
1. `isTslpFill` 的计算在 line 949: `dbOrder.execution_stage === 1 || dbOrder.remark === 'TSLP_AUTO'`
2. `execution_stage` 未被 SELECT → `dbOrder.execution_stage` = `undefined` → `undefined === 1` = `false`
3. `remark` 列不存在 → `dbOrder.remark` = `undefined` → `undefined === 'TSLP_AUTO'` = `false`
4. `isTslpFill` = `false || false` = **`false`** (永远)
5. spread `...(false ? {...} : {})` = `...{}` = 无操作
6. `protectionOrderId` 不在传入的 context 对象中
7. JSONB `||` merge 只覆盖传入的 key → `protectionOrderId` 保持原值不变

**结果**: `protectionOrderId` 一旦被设置，永远不会被清除（除非手动 SQL 清理）。这是 SPY 686 Put -$289 亏损（53% of total）的**直接根因**。

**报告的 Fix 2 为何不够**: 报告提出修复 isTslpFill 检测逻辑，使其在 TSLPPCT 成交时正确返回 true。但这只解决了 TSLPPCT 触发平仓的场景。在更常见的软件主动退出场景中（dynamic-exit 触发卖出），isTslpFill 仍然是 false，`protectionOrderId` 仍然不会被清除。

**正确修复**: `protectionOrderId` 应在所有 IDLE 转换中**无条件**清除：
```typescript
await strategyInstance.updateState(instanceKeySymbol, 'IDLE', {
  ...
  protectionOrderId: null,        // 无条件清除
  protectionTrailingPct: null,    // 无条件清除
  exitReason: isTslpFill ? 'TSLPPCT_FILLED' : null,
});
```

### 遗漏 2: 软件退出时不取消 broker 端 TSLPPCT 保护单 (P0)

**位置**: `strategy-scheduler.service.ts:923-1073`（整个卖出成交处理路径）

**物理证据**: 在卖出成交处理的 150 行代码中，没有对 `trailingStopProtectionService.cancelProtection()` 的调用。

搜索 `cancelProtection` 的调用点：
- `trailing-stop-protection.service.ts` 内部的 `adjustProtection()` 方法（fallback 逻辑）
- 无外部调用

**后果推演**:

**场景 A — 幽灵止损**:
1. 买入 QQQ Put 3x → TSLPPCT 提交成功（trailing 45%, orderId="TSLP-001"）
2. dynamic-exit 触发卖出 → 软件卖出 3x → 成交
3. broker 端 TSLPPCT "TSLP-001" 仍然挂着（45% trailing）
4. 系统重新入场买入 QQQ Put 5x → 获得新的 TSLPPCT "TSLP-002"
5. 市场下跌 → "TSLP-001" 触发：broker 尝试卖 3x，但持仓只有 5x
6. 5x 变成 2x（非预期），新的 "TSLP-002" 仍然认为保护 5x

**场景 B — 空头风险**:
1. 买入 → TSLPPCT 挂出 → 软件卖出 → 仓位归零
2. 市场继续下跌 → TSLPPCT 触发 → broker 卖出 0 份 → 拒绝（最好情况）
3. 或：如果此时有另一个策略持有同一标的 → TSLPPCT 意外卖出别的策略的仓位

### 遗漏 3: `fill_processed = TRUE` 标记时机不正确 (P1)

**位置**: `strategy-scheduler.service.ts:918-921`

```typescript
// line 854: logger.log 买入成交
// line 856-916: TSLPPCT 保护单提交（可能耗时 3-5 秒）
// line 917: 注释 "买入处理完成，标记 fill_processed"
// line 918-921:
await pool.query(
  `UPDATE execution_orders SET current_status = 'FILLED', fill_processed = TRUE, updated_at = NOW() WHERE order_id = $1`,
  [dbOrder.order_id]
);
```

**问题**: commit 2fda7ae 的说明称"标记 `fill_processed = TRUE` immediately at start of fill processing"，但代码实际将标记放在了 TSLPPCT 提交**之后**。

**时间窗口分析**:
- TSLPPCT 提交涉及：`getTradeContext()` + `submitOrder()` + rate limiter + retry + DB INSERT
- 在正常网络条件下耗时 1-3 秒
- 在 rate-limit 或 retry 场景下可能耗时 5-15 秒
- 监控循环每 5 秒执行一次
- **如果 TSLPPCT 提交耗时 > 5 秒，下一个监控周期会再次读取 `fill_processed IS NOT TRUE`，重新处理同一 fill**

**影响**:
- 重复更新 HOLDING 状态（多次 DB write，数据可能不一致）
- 重复提交 TSLPPCT（broker 端出现多个保护单，只有最后一个的 orderId 被保存）

### 遗漏 4: 熔断器只在 SELL 成交时触发 (P1)

**位置**: `strategy-scheduler.service.ts:1005`

```typescript
if (isOptionAssetSell && tradePnL < 0) {
  // 熔断检查...
}
```

**盲区清单**:

| 场景 | 是否触发熔断 | 实际亏损 |
|------|------------|---------|
| 软件正常 SELL | 是 | 正常记录 |
| TSLPPCT 触发 SELL | 是（如果 isTslpFill 修复后）| 正常记录 |
| 系统崩溃/进程重启 | **否** | 仓位悬挂，可能持续亏损 |
| Broker 强制平仓 (margin call) | **否** | 不经过软件 |
| 0DTE 到期归零 | **否** | 期权 100% 损失，无 SELL 订单 |
| API 断连 30分钟+ | **否** | 仓位失控 |

**特别危险**: 0DTE 到期归零不产生 SELL 订单 → 不触发熔断 → `dailyRealizedPnL` 不更新 → 第二天重置后继续交易，好像损失从未发生。

### 遗漏 5: DST 时区漏洞实际是 P0（报告定级 P2 错误）

**位置**: `option-dynamic-exit.service.ts:596`

```typescript
const closeTime = new Date(`${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}T16:00:00-05:00`);
```

**报告定级**: P2 — 一周内修复
**实际定级**: **P0** — 3月8日后每个交易日都是定时炸弹

**推演**:
- `-05:00` 是 EST（冬令时偏移量）
- 2026年3月8日起进入 EDT，偏移量变为 `-04:00`
- 用 `-05:00` 构造的 16:00 = 实际 ET 17:00（晚了 1 小时）
- `getMarketCloseTime()` 被 dynamic-exit 用于计算"距收盘还有 X 分钟"
- 所有基于"距收盘时间"的逻辑会晚 60 分钟触发

**致命影响**:
- FINAL 时段（收盘前 30 分钟）的强制退出 → 实际在收盘后 30 分钟才触发 → 期权已过期
- "距收盘 180 分钟禁止新开仓"窗口 → 实际只禁止 120 分钟（少了 60 分钟）
- **0DTE 期权当日到期归零 = 100% 本金损失**

**为什么报告定级错误**: 报告称"3月8日变成 P0"。但 3 月 8 日是周日（下一个交易日是 3 月 9 日周一），如果 3 月 6 日（周五）之前没修，3 月 9 日开盘就是灾难。距今不到 2 周。

### 遗漏 6: SELECT 查询缺少 `execution_stage` 列 — 连锁根因

**位置**: `strategy-scheduler.service.ts:551`

```sql
SELECT eo.order_id, eo.symbol, eo.side, eo.price, eo.quantity,
       eo.created_at, eo.current_status, eo.fill_processed
```

**缺少**: `eo.execution_stage`

**连锁影响**:
1. `dbOrder.execution_stage` = `undefined` (JS 层面)
2. → line 949: `isTslpFill` = `false` (永远)
3. → line 993: `protectionOrderId` 不清除
4. → line 860: 下次买入跳过 TSLPPCT
5. → 新仓位零保护
6. → -62% 亏损

一列未选，五步连锁，$289 亏损。

---

## 三、报告修复方案的批判

### Fix 1（deviation 公式重新设计）

报告给了两个方案：
- 方案 A: 完全移除 → **正确，推荐**
- 方案 B: 温和调整（阈值提高到 10%, 最低 30%）→ 不够彻底

**批判**: 方案 B 的问题在于它假设"大偏差 = 应该收紧 trailing"。这个经济学假设是**反的**。大偏差意味着市场波动剧烈，此时更需要宽 trailing 容忍波动，而非紧 trailing 被噪音触发。删掉比改好更安全。

### Fix 2（protectionOrderId 清理 + isTslpFill 修复）

报告提出：
```typescript
const isTslpFill = Boolean(
  context.protectionOrderId && context.protectionOrderId === dbOrder.order_id
);
```

**问题 1**: 这只解决了 TSLPPCT 触发成交的场景。非 TSLP 退出（占绝大多数）仍然不清除 `protectionOrderId`。

**问题 2**: 报告建议在 IDLE 转换中强制清除，但给出的代码片段没有展示如何修改 line 984-994 的 spread 逻辑。如果只是在 IDLE 转换中"添加" `protectionOrderId: null`，还需要确保它不在 isTslpFill 条件分支内。

### Fix 3（TSLPPCT 提交优先于软件退出）

**批判**: 报告建议"在第一个监控周期中跳过软件退出评估直到 TSLPPCT 确认"。这引入了新的复杂度 — 需要在 dynamic-exit 中感知 TSLPPCT 状态。更简单的做法是把 `fill_processed = TRUE` 移到 TSLPPCT 之前，然后在 TSLPPCT 失败时不影响 fill 处理。

### Fix 4（DST 时区修复）

报告的方案：
```typescript
const closeTime = new Date(
  new Date(`${year}-${month}-${day}T16:00:00`).toLocaleString('en-US', { timeZone: 'America/New_York' })
);
```

**批判**: 这行代码的行为取决于 Node.js 运行机器的本地时区。`toLocaleString` 输出格式不稳定。应使用 `Intl.DateTimeFormat` 或直接计算 UTC 偏移。

---

## 四、明日开盘死命令 (Kill Switch)

### 自动熔断（已有，需验证正常工作）:
- 日内累计亏损 >= $300 → `circuitBreakerActive = true`
- 连续亏损 >= 4 笔 → 同上

### 人工介入触发条件:

| # | 条件 | 动作 | 监控方式 |
|---|------|------|---------|
| K1 | 开盘跳空 > 3% | 暂停所有策略 30 分钟 | 手动观察 |
| K2 | TSLPPCT 提交失败 >= 2 次 | 该标的禁止开仓 | 日志: `TSLPPCT提交失败` |
| K3 | TSLPPCT trailing < 20% | deviation 公式未被删除，停机 | 日志: `trailing从...调整为` |
| K4 | protectionOrderId 残留 | 清除后再启动 | SQL 查询 |
| K5 | 首笔交易亏损 > 30% | 全策略暂停，人工审查 | 日志: `本笔PnL=` |

### 开盘前数据库清理（必做）:

```sql
-- 1. 清除所有 IDLE 状态的 protectionOrderId 残留
UPDATE strategy_instances
SET context = context - 'protectionOrderId' - 'protectionTrailingPct'
WHERE current_state = 'IDLE'
AND (context->>'protectionOrderId') IS NOT NULL;

-- 2. 检查是否有 stuck HOLDING 状态
SELECT strategy_id, symbol, current_state,
       context->>'protectionOrderId' as tslp_id,
       context->>'entryPrice' as entry,
       last_updated
FROM strategy_instances
WHERE current_state IN ('HOLDING', 'OPENING', 'CLOSING');

-- 3. 验证无未处理的 FILLED 订单
SELECT order_id, symbol, current_status, fill_processed
FROM execution_orders
WHERE current_status = 'FILLED' AND fill_processed IS NOT TRUE
AND created_at >= NOW() - INTERVAL '48 hours';

-- 4. 检查资金泄漏
SELECT s.id, s.name, ca.current_usage, ca.allocated_amount
FROM strategies s
JOIN capital_allocations ca ON s.capital_allocation_id = ca.id
WHERE ca.current_usage > 0
AND NOT EXISTS (
  SELECT 1 FROM strategy_instances si
  WHERE si.strategy_id = s.id AND si.current_state = 'HOLDING'
);

-- 5. 检查 broker 端残留保护单
-- 需通过 API 调用: GET /api/orders/today → 筛选 status=active AND remark='TSLP_AUTO'
```

---

## 五、修复优先级总表

| # | 修复项 | 优先级 | 类型 | 影响 |
|---|--------|-------|------|------|
| A | 删除 deviation 动态调整公式 (line 873-892) | P0 | 删除代码 | TSLPPCT 回归 45% 崩溃保护 |
| B | protectionOrderId 无条件清除 (line 984-994) | P0 | 修改逻辑 | 消除残留导致的零保护 |
| C | SELL 成交时取消 broker 端 TSLPPCT (line ~983) | P0 | 新增逻辑 | 消除幽灵止损/空头风险 |
| D | SELECT 加 execution_stage + 修复 isTslpFill (line 551, 949) | P1 | 修改查询 | 正确检测 TSLPPCT 成交 |
| E | fill_processed=TRUE 前移 (line 918→855) | P1 | 移动代码 | 消除重复处理窗口 |
| F | DST 时区修复 (option-dynamic-exit:596) | P0* | 重写方法 | *3月6日前必须完成 |
| G | PnL 手续费使用实际值 (line 966) | P2 | 微调 | 熔断阈值精度提升 |

**修复顺序**: A → B → C → D → E → F（按风险递减 + 依赖关系排列）

---

## 六、核心文件修改清单

| 文件 | 修改行 | Fix # | 操作 |
|------|--------|-------|------|
| `api/src/services/strategy-scheduler.service.ts` | 551 | D | SELECT 加 `eo.execution_stage` |
| `api/src/services/strategy-scheduler.service.ts` | 873-892 | A | 删除 deviation 代码块 |
| `api/src/services/strategy-scheduler.service.ts` | 918 → ~855 | E | `fill_processed=TRUE` 前移 |
| `api/src/services/strategy-scheduler.service.ts` | 949 | D | isTslpFill 检测重写 |
| `api/src/services/strategy-scheduler.service.ts` | ~983 (新增) | C | SELL 时取消 TSLPPCT |
| `api/src/services/strategy-scheduler.service.ts` | 984-994 | B | protectionOrderId 无条件清除 |
| `api/src/services/option-dynamic-exit.service.ts` | 590-607 | F | getMarketCloseTime 重写 |

---

## 七、结论

原报告识别了 7 个漏洞（2 P0 + 3 P1 + 2 P2），其中：
- **诊断正确但不完整**: 5 个（发现 1-5）
- **根因分析错误**: 1 个（发现 3 的 isTslpFill 根因诊断 — 列存在但未 SELECT）
- **优先级定级错误**: 1 个（DST 应为 P0 而非 P2）
- **完全遗漏**: 6 个致命细节（见第二章）

**两日 -$837 亏损的归因修正**:
- -$289 (34.5%): protectionOrderId 残留 → 新仓位零保护（遗漏 1 + 遗漏 6）
- -$163 (19.5%): deviation 公式压缩 TSLPPCT 到 8%（发现 1，报告正确）
- -$95 (11.3%): 正常交易亏损
- -$290 (34.7%): Feb 23 反转行情亏损（已有熔断修复，需验证有效性）

**如果只做报告的 Fix 1 + Fix 2 而不修本报告指出的遗漏 1-3，明日开盘后：**
- deviation 公式被删（Fix 1）→ TSLPPCT 恢复 45% → 改善
- isTslpFill 检测修复（Fix 2）→ TSLPPCT 触发时能正确清除 → 部分改善
- **但软件主动退出仍不清除 protectionOrderId** → 遗漏 1 未修
- **broker 端 TSLPPCT 仍然不取消** → 遗漏 2 未修
- **SPY 686 Put 惨剧可以精确重现**

---

## 八、修复执行状态

> 以下所有修复已于 2026-02-25 完成并通过 TypeScript 编译验证。

### Fix A-F 执行状态

| # | 修复项 | 状态 | 文件 |
|---|--------|------|------|
| A | 删除 deviation 动态调整公式 | **已完成** | `strategy-scheduler.service.ts:874` |
| B | protectionOrderId 无条件清除 | **已完成** | `strategy-scheduler.service.ts:984-996` |
| C | SELL 成交时取消 broker 端 TSLPPCT | **已完成** | `strategy-scheduler.service.ts:967-981` |
| D | SELECT 加 execution_stage + isTslpFill 修复 | **已完成** | `strategy-scheduler.service.ts:551, 928-932` |
| E | fill_processed=TRUE 前移 | **已完成** | `strategy-scheduler.service.ts:717-722` |
| F | DST 时区修复 | **已完成** | `option-dynamic-exit.service.ts:590-608` |
| G | PnL 手续费使用实际值 | 推迟 (P2) | — |

---

## 九、Iron Dome 三层准自动化防御

> 消除所有"需人工介入"的监控盲区。

### Layer 1: Shadow-Pricer（影子定价器）

**解决**: 0DTE 到期归零不触发熔断（无 SELL 订单 → 无 PnL 记录）

**实现**: 60 秒周期轮询所有 HOLDING 状态的 0DTE 仓位，使用 broker 持仓缓存获取 mark price。

**触发条件**: `currentPrice < entryPrice * 0.10`（亏损 90%+）
**动作**: 全策略 `circuitBreakerActive = true`，日志报警

**预警阈值**: `currentPrice < entryPrice * 0.30`（亏损 70%+）→ WARN 日志

**位置**: `strategy-scheduler.service.ts` — `shadowPricerCheck()` 方法

### Layer 2: Reconciliation Loop（账实核对）

**解决**: Broker 强平/期权到期后系统仍以为持有仓位

**实现**: 60 秒周期对比 broker `stockPositions()` 返回的实际持仓 vs DB `strategy_instances` 的 HOLDING 状态。

**触发条件**: DB 显示 HOLDING 但 broker 端该标的持仓数量 = 0
**动作**:
1. 标记该实例为 `IDLE`，`exitReason = 'BROKER_TERMINATED'`
2. 释放资金分配（`capitalManager.releaseAllocation`）
3. 全策略 `circuitBreakerActive = true`
4. 日志报警

**位置**: `strategy-scheduler.service.ts` — `reconciliationCheck()` 方法

### Layer 3: TSLPPCT 失败计数器

**解决**: TSLPPCT 提交失败后仍允许裸仓开新单

**实现**: 内存级 `tslpFailureCount` 计数器，per strategy。
- TSLPPCT 提交成功 → `resetTslpFailure()` 归零
- TSLPPCT 提交失败/异常 → `recordTslpFailure()` 递增

**触发条件**: `tslpFailureCount >= 2`
**动作**: 在信号生成阶段拦截所有 BUY 信号，`return` 跳过开仓

**位置**: `strategy-scheduler.service.ts` — `isTslpBlocked()` / `recordTslpFailure()` / `resetTslpFailure()`

### Iron Dome 生命周期

| 事件 | 动作 |
|------|------|
| `startStrategy()` | 启动 60 秒 Iron Dome interval（仅期权策略）|
| `stopStrategy()` | 清理 Iron Dome interval |
| `stop()` | 清理所有 Iron Dome intervals |
| TSLPPCT 提交成功 | `resetTslpFailure()` |
| TSLPPCT 提交失败 | `recordTslpFailure()` |
| BUY 信号生成 | `isTslpBlocked()` 检查 → 拦截或放行 |

---

## 十、最终 GO/NO-GO

**GO — 三条绝对阈值（代码自动执行，无需人工）:**

1. **Shadow-Pricer**: 0DTE 仓位残值 < 入场价 10% → 全策略熔断
2. **Reconciliation**: DB 与 broker 持仓不一致 → BROKER_TERMINATED + 全策略熔断
3. **TSLP Counter**: 保护单连续失败 2 次 → 禁止所有新开仓

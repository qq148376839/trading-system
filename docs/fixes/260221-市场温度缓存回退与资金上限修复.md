# 260221 市场温度缓存回退 + 资金上限一致性修复

## 关联分析

- 分析文档: `docs/analysis/260220-期权策略实盘日志分析.md`
- 触发事件: 2/20 市场温度 API 间歇性失败导致虚假信号 + 资金上限不一致导致订单被拒

---

## 修复项 1: 市场温度 API 失败时缓存回退未生效 (P0)

### 问题定位

**文件**: `api/src/services/market-data.service.ts`
**位置**: `getMarketTemperature()` 方法，第 534-646 行

**根因**: 内层 `try-catch` (line 544-562) 的 `catch` 块直接 `return null`，跳过了外层 `catch` (line 626-645) 中的缓存回退逻辑。

```
getMarketTemperature()
├── try {                          // 外层 try (line 535)
│   ├── try {                      // 内层 try (line 544)
│   │   └── quoteCtx.marketTemperature(Market.US)
│   │
│   └── catch (error) {            // 内层 catch (line 547)
│       └── return null;           // ← BUG: 直接返回，不走外层 catch
│
└── catch (error) {                // 外层 catch (line 626) — 有缓存回退
    ├── if (cache < 5min) → return cache
    ├── if (cache < 15min) → return cache
    └── return null
```

API 调用失败抛出的异常被内层 `catch` 捕获并 `return null`，这不是一个异常，所以外层 `catch` 永远不会执行。缓存回退逻辑变成了死代码。

### 修复方案

将内层 `catch` 的 `return null` 改为使用缓存回退，与外层 `catch` 保持一致：

```typescript
// market-data.service.ts — getMarketTemperature() 内层 catch (line 547-562)

catch (error: any) {
  logger.error(`[市场温度] 调用失败:`, error.message);
  logger.error(`[市场温度] 错误详情:`, error);

  // 如果方法不存在，检查SDK版本
  if (error.message && error.message.includes('is not a function')) {
    try {
      const longportPackage = require('longport/package.json');
      logger.error(`[市场温度] 当前SDK版本: ${longportPackage.version}`);
    } catch (e) { /* 忽略 */ }
  }

  // ★ 修复：使用缓存回退，而非直接返回 null
  if (this.temperatureCache) {
    const cacheAge = Date.now() - this.temperatureCache.timestamp;
    if (cacheAge < this.TEMPERATURE_CACHE_TTL) {
      logger.warn(
        `[市场温度] API调用失败，使用缓存值 ${this.temperatureCache.value}` +
        `（${Math.round(cacheAge / 1000)}秒前）`
      );
      return this.temperatureCache.value;
    }
    if (cacheAge < this.TEMPERATURE_CACHE_TTL * 3) {
      logger.warn(
        `[市场温度] API调用失败，使用过期缓存值 ${this.temperatureCache.value}` +
        `（${Math.round(cacheAge / 1000)}秒前，已过期）`
      );
      return this.temperatureCache.value;
    }
  }

  // 无可用缓存
  logger.warn(`[市场温度] API调用失败且无可用缓存，温度分量将缺失`);
  return null;
}
```

### 影响范围

- 仅修改 `market-data.service.ts` 的 `getMarketTemperature()` 方法内层 catch
- 不影响温度正常获取时的逻辑
- 不影响其他服务

### 验证方法

1. 观察后续日志中市场温度失败时是否出现 `使用缓存值` 日志
2. 确认温度失败时大盘评分不再出现 5+ 分的突变
3. 确认不再出现因温度失败触发的虚假信号

---

## 修复项 2: `getMaxPositionPerSymbol()` 未应用资金保护调整 (P1)

### 问题定位

**文件**: `api/src/services/capital-manager.service.ts`
**位置**: `getMaxPositionPerSymbol()` 方法，第 306-349 行

**根因**: `getMaxPositionPerSymbol()` 使用配置原值计算上限，未像 `requestAllocation()` 一样应用 `Math.min(configuredAmount, totalCapital)` 保护。

```
getMaxPositionPerSymbol():
  allocatedAmount = allocation_value        // = $2,000（配置原值）
  return allocatedAmount / symbolCount      // = $2,000 / 2 = $1,000

requestAllocation():
  allocatedAmount = min(allocation_value, totalCapital)  // = min($2,000, $1,123) = $1,123
  maxPositionPerSymbol = allocatedAmount / symbolCount   // = $1,123 / 2 = $561.52
```

期权策略的仓位计算（`option-intraday-strategy.ts:641`）调用 `getMaxPositionPerSymbol()` 获取预算 $1,000，按此计算 13 张合约 ($943)；但下单时 `requestAllocation()` 用 $561.52 上限校验 → 被拒。

### 修复方案

在 `getMaxPositionPerSymbol()` 中加入与 `requestAllocation()` 一致的资金保护逻辑：

```typescript
// capital-manager.service.ts — getMaxPositionPerSymbol() (line 323-330)

// 计算策略总资金
const totalCapital = await this.getTotalCapital();
let allocatedAmount = 0;
if (strategy.allocation_type === 'PERCENTAGE') {
  allocatedAmount = totalCapital * parseFloat(strategy.allocation_value.toString());
} else {
  // ★ 修复：与 requestAllocation() 保持一致，应用资金保护
  const configuredAmount = parseFloat(strategy.allocation_value.toString());
  allocatedAmount = Math.min(configuredAmount, totalCapital);
}
```

### 影响范围

- 仅修改 `capital-manager.service.ts` 的 `getMaxPositionPerSymbol()` 方法
- 影响所有调用 `getMaxPositionPerSymbol()` 的地方（期权策略仓位计算、调度器仓位计算）
- 修复后，策略会正确计算较少的合约数，避免被后续资金校验拒绝

### 预期效果

以 2/20 场景为例（即使温度 bug 不修，假设信号是真实的）：

| | 修复前 | 修复后 |
|---|---|---|
| 预算 | $1,000（错误） | $561.52（正确） |
| QQQ PUT $0.72 | 13张 $943 → 被拒 | 7张 $510 → 通过 |
| SPY PUT $1.05 | 9张 $950 → 被拒 | 5张 $531 → 通过 |

### 验证方法

1. 确认 `getMaxPositionPerSymbol()` 返回值与 `requestAllocation()` 内部计算一致
2. 观察后续日志中不再出现"资金申请被拒绝"与"准备买入"的金额明显不匹配

---

## 修复文件清单

| 文件 | 修改点 | 行号 |
|---|---|---|
| `api/src/services/market-data.service.ts` | 内层 catch 加入缓存回退 | 547-562 |
| `api/src/services/capital-manager.service.ts` | `getMaxPositionPerSymbol` 加入资金保护 | 328-330 |

## 风险评估

| 修复项 | 风险 | 说明 |
|---|---|---|
| 温度缓存回退 | **低** | 仅在 API 失败时生效，正常路径不变 |
| 资金上限一致性 | **低** | 使预算计算更保守（更少合约），不会增加风险敞口 |

## 不修改的文件

- `option-intraday-strategy.ts` — 无需改动，修复上游即可
- `option-recommendation.service.ts` — 无需改动
- `strategy-scheduler.service.ts` — 无需改动

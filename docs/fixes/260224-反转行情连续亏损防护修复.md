# 反转行情连续亏损防护修复 - 产品需求文档

## 文档信息
- **版本**: v1.0
- **创建时间**: 2026-02-24
- **状态**: 已完成
- **严重性**: P0 — 资金安全
- **关联文档**: [260224-反转行情连续亏损根因分析](../analysis/260224-反转行情连续亏损根因分析.md) | [260224-盈亏百分比归零与LIT止盈保护修复](./260224-盈亏百分比归零与LIT止盈保护修复.md)

---

## 1. 背景与目标

### 1.1 第一性原理拆解

交易系统的存在意义是**正期望值地分配风险资本**。当系统判断错误时（必然会发生），其生存能力取决于一个核心指标：**单日最大回撤是否在可承受范围内**。

从第一性原理出发，任何交易系统需要三层防护：

| 层级 | 作用 | 类比 | 当前状态 |
|------|------|------|----------|
| L1 单笔止损 | 限制单笔最大亏损 | 安全带 | 已有（option-dynamic-exit，根因D已修复） |
| L2 策略级熔断 | 限制同一策略日内累计亏损 | 熔断器 | **缺失** |
| L3 信号质量衰减 | 连续错误后降低信号置信度 | 自我纠错 | **缺失** |

2026-02-23 事件的本质：L1 存在但因 bug 部分失效（根因D），而 L2、L3 完全不存在。即使 L1 完美工作，在反转行情中依然会出现"每笔亏-3%、但连开10笔"的死循环，因为**没有任何机制在策略层面累计评估当天的表现并踩刹车**。

### 1.2 事件复盘

2026-02-23 交易日，策略10（0DTE PUT）：
- 反转前 6 轮交易：+$691（系统判断正确，PUT 方向获利）
- ~11:05 ET 市场反转上行，PUT 方向不再正确
- 反转后 7 轮交易：-$512（亏损 -> 平仓 -> 1分钟后重入 -> 再亏损）
- 净结果：+$179（扣手续费后接近盈亏平衡，将 $691 利润几乎全部回吐）

### 1.3 用户痛点

系统在赚到 $691 后，因为无法感知"我已经连续错了4次"，在1小时内把利润全部亏回去。用户被迫在 11:39 手动介入平仓。一个自动化交易系统不应该需要用户盯盘救火。

### 1.4 业务目标

1. 当策略日内累计亏损达到阈值时，自动暂停该策略至收盘（L2 熔断）
2. 连续亏损时延长冷却期，给市场时间形成新的趋势（L2 冷却升级）
3. 连续亏损后抑制同方向信号，降低"错误方向反复入场"的概率（L3 信号衰减）

### 1.5 成功标准

- 日内累计亏损触及阈值后，策略在当日余下时间不再产生新的买入信号
- 连续 3 笔亏损后，冷却期至少 10 分钟（而非当前的 1-3 分钟）
- 类似 2/23 的反转场景中，反转后亏损控制在 $200 以内（而非 $512）

---

## 2. 用户与场景

### 2.1 目标用户

系统自身（策略调度器）和系统运营者（需要在前端/日志中看到熔断状态）。

### 2.2 使用场景

| 场景 | 触发条件 | 期望行为 |
|------|----------|----------|
| 日内亏损熔断 | 策略10当日已实现亏损 >= $300 | 该策略暂停，不再开新仓，已有持仓正常管理（止盈止损继续生效） |
| 连续亏损冷却 | 最近连续 2 笔亏损 | 冷却期从 1 分钟升级到 5 分钟 |
| 连续亏损冷却 | 最近连续 3 笔亏损 | 冷却期升级到 15 分钟 |
| 连续亏损冷却 | 最近连续 >= 4 笔亏损 | 直接触发策略熔断至收盘 |
| 反转信号抑制 | 最近 3 笔中有 2 笔亏损 | 同方向信号被标记为 HOLD，不执行 |
| 熔断后恢复 | 新交易日开始 | 自动重置所有熔断状态 |
| 手动恢复 | 运营者判断可以恢复 | API 端点手动重置熔断 |

### 2.3 用户故事

- 作为交易系统，我想要在日内累计亏损超限时自动暂停策略，以便保住当日已实现的利润。
- 作为运营者，我想要在日志和前端看到熔断状态和原因，以便了解系统为什么停止交易。
- 作为运营者，我想要在必要时手动解除熔断，以便在确认市场环境改善后恢复交易。

---

## 3. 功能需求

### 3.1 修复A（P0）：日内累计亏损熔断

#### 底层逻辑

单笔止损保护单笔，但无法防止"每笔小亏、笔笔都亏"的累积伤害。日内熔断的本质是：**当策略在当天的表现显著低于预期时，承认"今天不是我的日子"并停止交易**。

#### 数据追踪

在 `strategy_instances.context` 中新增以下字段（利用现有 JSONB 结构，无需改表）：

```typescript
// 每次卖出成交时更新
interface DailyPnLContext {
  dailyRealizedPnL: number;        // 日内已实现盈亏（美元）
  dailyRealizedPnLPercent: number;  // 日内已实现盈亏（相对于策略分配资金的百分比）
  consecutiveLosses: number;        // 当前连续亏损笔数
  lastTradeDirection: 'CALL' | 'PUT' | null;  // 最近一笔交易方向
  lastTradePnL: number;            // 最近一笔交易盈亏（美元）
  circuitBreakerActive: boolean;   // 熔断是否激活
  circuitBreakerReason: string;    // 熔断原因
  circuitBreakerTime: string;      // 熔断触发时间（ISO string）
}
```

**计算时机**：每次卖出订单成交时（`strategy-scheduler.service.ts` 约第 965 行附近，现有 dailyTradeCount 递增的位置）。

**PnL 计算方法**：
```
tradePnL = (sellPrice - entryPrice) * quantity * multiplier - totalFees
```
其中 `entryPrice`、`quantity`、`multiplier` 已存在于 `context` 中，`sellPrice` = 卖出成交均价（`avgPrice`），`totalFees` 可从 `context.entryFees` 估算（买卖手续费近似）。

#### 熔断阈值设计

**核心改进：动态阈值（基于策略实际可用资金）**

固定金额阈值（如 $300）的问题：资金池大小不同的策略需要不同的保护力度。资金池 $5000 的策略，$300 是 6%；资金池 $1000 的策略，$300 是 30%。应该根据策略的实际可用资金动态计算。

| 参数 | 默认值 | 依据 | 可配置位置 |
|------|--------|------|-----------|
| `circuitBreakerPercent` | 30% | 策略实际可用资金（allocatedAmount - currentUsage）的 30%。例如可用资金 $1000 → 阈值 $300；可用资金 $2000 → 阈值 $600 | `strategies.config.riskLimits.circuitBreakerPercent` |
| `maxDailyLoss` | $300 (fallback) | 仅在无法获取可用资金时使用的兜底值 | `strategies.config.riskLimits.maxDailyLoss` |
| `maxConsecutiveLosses` | 4 | 0DTE 市场中连续 4 笔亏损几乎确定方向判断错误（胜率约 60%，连亏4笔概率仅 2.56%） | `strategies.config.riskLimits.maxConsecutiveLosses` |

**动态阈值计算公式**：
```
totalAllocated = availableCapital + 当前持仓已占用资金(allocationAmount)
maxDailyLoss = max(100, totalAllocated * circuitBreakerPercent / 100)
```

- 使用 `capitalManager.getAvailableCapital()` 获取实时可用资金
- 加上当前持仓已占用的资金（`context.allocationAmount`），还原为总分配额度
- 最低保护线 $100，防止资金池极小时阈值失去意义

为什么选 30% 而非更高/更低：
- 太低（10%-15%）：可用资金 $1000 时阈值仅 $100-$150，正常交易中1-2笔止损即触发
- 太高（50%+）：日内回撤一半才触发，保护力度不足
- 30% 在 $1000-$5000 资金池范围内（阈值 $300-$1500），都是 2-3 笔正常止损的累积空间

#### 熔断行为

触发后：
1. 将 `circuitBreakerActive = true` 写入 context
2. 该标的（underlying）后续调度周期中，检测到熔断标志后直接 `return`，不生成信号
3. **已有持仓不受影响**：止盈止损、TSLPPCT、LIT 继续正常工作
4. 记录日志：`[CIRCUIT_BREAKER] 策略 ${id} 标的 ${symbol}: 日内累计亏损 $${dailyRealizedPnL} 触及阈值 $${maxDailyLoss}，暂停至收盘`

恢复机制：
1. **自动恢复**：每日首次调度时（`dailyTradeCount === 0` 且为新交易日），清除 `circuitBreakerActive` 及相关字段
2. **手动恢复**：新增 API 端点 `POST /api/strategies/:id/reset-circuit-breaker`

#### 跨标的共享问题

策略10 有多个 underlying（SPY、QQQ 等），每个 underlying 有独立的 `strategy_instances` 行。日内 PnL 应该是**策略级**聚合，而非标的级。

**方案**：每次卖出时，从数据库查询当日该策略所有标的的已实现 PnL 总和：

```sql
SELECT SUM((context->>'lastTradePnL')::numeric) as total_daily_pnl
FROM strategy_instances
WHERE strategy_id = $1
  AND (context->>'dailyRealizedPnL') IS NOT NULL
```

或者更简洁：直接在每个标的的 context 中累加自身的 PnL，熔断检查时查询所有标的的 `dailyRealizedPnL` 求和。当任一标的的查询结果显示策略总亏损超限，则对**该策略所有标的**设置熔断。

### 3.2 修复B（P1）：冷却期升级（感知连续亏损）

#### 底层逻辑

当前冷却期仅基于 `dailyTradeCount`（交易笔数），完全不区分盈亏。打10笔全赢 vs. 打3笔全亏，冷却策略应该截然不同。冷却期的核心目的不是"等时间过去"，而是**等市场形成新的可判断状态**。

#### 改造方案

**替换现有冷却逻辑**（`strategy-scheduler.service.ts:1415-1440`）：

```
冷却时间 = f(consecutiveLosses, dailyTradeCount)

if (consecutiveLosses === 0):
  沿用现有逻辑（基于 dailyTradeCount）

if (consecutiveLosses === 1):
  cooldownMinutes = 3   // 一笔亏损是正常的，略微延长

if (consecutiveLosses === 2):
  cooldownMinutes = 5   // 两笔连亏，需要等更久让趋势明确

if (consecutiveLosses === 3):
  cooldownMinutes = 15  // 三笔连亏，很可能方向错了

if (consecutiveLosses >= 4):
  触发熔断（与修复A联动）
```

为什么不用指数退避（如 5min -> 10min -> 20min）：
- 0DTE 市场交易窗口只有约 6.5 小时，指数退避会导致后半段完全无法交易
- 分级冷却更可预测，运营者能明确知道"3笔亏后冷却15分钟"

#### 数据来源

复用修复A中新增的 `consecutiveLosses` 字段。每次卖出成交时：
- 若本笔盈利：`consecutiveLosses = 0`（重置）
- 若本笔亏损：`consecutiveLosses += 1`

### 3.3 修复C（P1）：信号反转抑制

#### 底层逻辑

信号系统（`option-intraday-strategy.ts` 的 `generateSignal`）基于当前市场快照评分，不参考"我最近的交易表现"。这在趋势明确时没问题，但在反转初期，技术指标存在惯性（均线、分时评分滞后），导致信号方向与实际市场背离。

**不应该**改造核心信号算法（`calculateOptionRecommendation`），那是另一个复杂度维度。我们需要的是一个**轻量级的信号质量门卫**：在信号发出后、执行前，用最近交易结果做一次 sanity check。

#### 方案：最近亏损方向抑制

在 `strategy-scheduler.service.ts` 的信号生成后（约第 1463 行 `generateSignal` 调用之后）新增检查：

```
if (consecutiveLosses >= 2 && lastTradeDirection === intent.direction):
  log("信号方向与最近连续亏损方向一致，抑制信号")
  return  // 跳过此信号
```

逻辑：
- 连续亏了 2 笔 PUT，再来一个 PUT 信号 -> 抑制
- 连续亏了 2 笔 PUT，来了一个 CALL 信号 -> 放行（方向已反转）
- 亏了 1 笔 -> 不抑制（单笔亏损是正常的）

为什么阈值是 2 而非 1 或 3：
- 1 太敏感：0DTE 策略胜率约 60%，单笔亏损太常见，抑制会严重影响正常盈利
- 3 太迟：2/23 事件中连亏3笔时已亏 $174+$104+$16 = $294，接近熔断线
- 2 是合理的平衡点：连续2笔同方向亏损的概率约 16%（0.4^2），已经是值得注意的信号

#### 数据来源

复用修复A中的 `consecutiveLosses` 和 `lastTradeDirection`。方向信息从 `context.optionMeta` 或 `intent.metadata` 中提取。

### 3.4 补充（P2）：同方向最大并发限制

#### 判断：暂不实现

当前已有 `checkExistingOptionPositionForUnderlying` 防止同一 underlying 重复开仓。补充说明中提到的"同方向不同 underlying 无限开仓"，在实际运行中受限于资金分配（capital-manager 的 symbol-level 限制 + 策略总额度限制），不会真正无限。且修复A的日内亏损熔断已能有效遏制过度开仓的后果。

**结论**：P2 暂缓，观察修复A/B/C效果后再决定是否需要。

### 3.5 边界条件

| 边界场景 | 处理方式 |
|----------|----------|
| 熔断后仍有持仓 | 正常管理：止盈止损、TSLPPCT、LIT、收盘前强制平仓均不受影响 |
| 熔断后持仓盈利平仓 | 盈利计入 dailyRealizedPnL，但不自动解除熔断（今日策略已被证明不可靠） |
| 跨策略共享 | 不共享。每个策略独立计算日内 PnL，独立触发熔断。策略间风格不同，混合计算无意义 |
| 手动恢复后再次触发 | 允许。手动恢复后若继续亏损，会再次触发熔断 |
| 参数可配置 | `maxDailyLoss` 和 `maxConsecutiveLosses` 存入策略配置 JSON，可通过前端/API 修改 |
| 新交易日判断 | 通过比较 `lastExitTime` 的日期（ET 时区）与当前日期，若不同则重置 |
| dailyRealizedPnL 精度 | 使用 Number 类型，保留2位小数，足够交易用途 |
| 多标的同时触发 | 检查逻辑在每个标的的调度循环中独立执行，通过数据库查询聚合策略级 PnL |

### 3.6 业务规则

1. 熔断只阻止**新开仓**，不影响已有持仓的管理
2. 日内 PnL 仅计入**已实现**盈亏（已平仓的交易），不计入浮动盈亏
3. 冷却期和熔断是**策略级**的，同一策略下所有标的共享状态
4. 连续亏损计数基于**时间顺序**（最近的连续亏损），一笔盈利即重置
5. 信号抑制只抑制**同方向**信号，反方向信号正常放行

---

## 4. 技术方案

### 4.1 修改文件清单

| 文件 | 改动内容 | 估计改动量 |
|------|----------|-----------|
| `api/src/services/strategy-scheduler.service.ts` | 卖出成交时计算 PnL 并更新 context；冷却期逻辑改造；信号抑制检查；熔断检查 | ~120行 |
| `api/src/services/strategies/option-intraday-strategy.ts` | generateSignal 返回值中携带方向信息（已有，确认即可） | ~5行 |
| `api/src/services/capital-manager.service.ts` | 无改动 | 0 |
| `api/src/services/option-dynamic-exit.service.ts` | 无改动 | 0 |

**不需要数据库迁移**：所有新增字段存储在 `strategy_instances.context` (JSONB) 中。

### 4.2 实现细节

#### 4.2.1 卖出成交时的 PnL 追踪

**位置**：`strategy-scheduler.service.ts` 约第 965-971 行（现有 dailyTradeCount 递增处）

```typescript
// 计算本笔交易 PnL
const entryPrice = parseFloat(String(context.entryPrice || 0));
const sellAvgPrice = avgPrice; // 卖出成交均价（已有变量）
const qty = parseFloat(String(context.quantity || 1));
const multiplier = Number(context.optionMeta?.multiplier) || 100;
const entryFees = parseFloat(String(context.entryFees || 0));
const exitFees = entryFees; // 近似：卖出手续费约等于买入手续费
const tradePnL = (sellAvgPrice - entryPrice) * qty * multiplier - entryFees - exitFees;

// 更新连续亏损计数
const prevConsecutiveLosses = context.consecutiveLosses ?? 0;
const newConsecutiveLosses = tradePnL < 0 ? prevConsecutiveLosses + 1 : 0;

// 更新日内累计 PnL
const prevDailyPnL = context.dailyRealizedPnL ?? 0;
const newDailyPnL = prevDailyPnL + tradePnL;

// 提取交易方向
const tradeDirection = context.optionMeta?.direction
  || context.intent?.metadata?.direction
  || null;

await strategyInstance.updateState(instanceKeySymbol, 'IDLE', {
  lastExitTime: new Date().toISOString(),
  dailyTradeCount: prevDailyTradeCount + 1,
  // 新增字段
  dailyRealizedPnL: Math.round(newDailyPnL * 100) / 100,
  consecutiveLosses: newConsecutiveLosses,
  lastTradeDirection: tradeDirection,
  lastTradePnL: Math.round(tradePnL * 100) / 100,
  // ... 保留现有字段
});
```

#### 4.2.2 策略级日内 PnL 聚合 + 熔断检查（卖出成交后触发）

**位置**：`strategy-scheduler.service.ts` 卖出成交处理块，PnL 计算之后

**实现方式**：熔断检查在每次亏损卖出成交时执行（而非在 IDLE 入口处），一旦触发则对**该策略所有标的**批量设置熔断标志。

```typescript
// 卖出成交且亏损时 → 检查是否需要熔断
if (isOptionAssetSell && tradePnL < 0) {
  const riskLimits = strategyConfig?.riskLimits || {};
  const maxConsecLosses = riskLimits.maxConsecutiveLosses ?? 4;
  const circuitBreakerPct = riskLimits.circuitBreakerPercent ?? 30;

  // 聚合策略级日内 PnL（所有标的）
  const pnlResult = await pool.query(
    `SELECT COALESCE(SUM((context->>'dailyRealizedPnL')::numeric), 0) as total_pnl
     FROM strategy_instances WHERE strategy_id = $1
     AND (context->>'dailyRealizedPnL') IS NOT NULL`,
    [strategyId]
  );
  const strategyDailyPnL = parseFloat(pnlResult.rows[0]?.total_pnl || '0');

  // 动态计算熔断阈值：基于策略可用资金池
  let maxDailyLoss = riskLimits.maxDailyLoss ?? 300; // fallback
  const availableCapital = await capitalManager.getAvailableCapital(strategyId);
  const totalAllocated = availableCapital + (context.allocationAmount || 0);
  if (totalAllocated > 0) {
    maxDailyLoss = Math.max(100, Math.round(totalAllocated * circuitBreakerPct / 100));
  }

  if (strategyDailyPnL <= -maxDailyLoss || newConsecutiveLosses >= maxConsecLosses) {
    // 对该策略所有标的批量设置熔断
    await pool.query(
      `UPDATE strategy_instances SET context = context || $1::jsonb WHERE strategy_id = $2`,
      [JSON.stringify({ circuitBreakerActive: true, circuitBreakerReason: reason, circuitBreakerTime: ... }), strategyId]
    );
  }
}
```

**IDLE 入口处**仅做简单的熔断标志检查（不再重复聚合查询）：

```typescript
if (cancelCtx?.circuitBreakerActive) {
  summary.idle.push(`${symbol}(CIRCUIT_BREAKER:${cancelCtx.circuitBreakerReason})`);
  return;
}
```

#### 4.2.3 冷却期改造

**替换** `strategy-scheduler.service.ts:1420-1432` 的冷却期计算逻辑：

```typescript
let cooldownMinutes: number;
if (is0DTEContext) {
  const consecLosses = cancelCtx?.consecutiveLosses ?? 0;

  if (consecLosses >= 3) {
    cooldownMinutes = 15;  // 3笔连亏：长冷却
  } else if (consecLosses === 2) {
    cooldownMinutes = 5;   // 2笔连亏：中等冷却
  } else if (consecLosses === 1) {
    cooldownMinutes = 3;   // 1笔亏损：短冷却
  } else {
    // 无连续亏损：沿用原有基于交易次数的逻辑
    if (dailyTradeCount <= 1) {
      cooldownMinutes = 0;
    } else if (dailyTradeCount <= 3) {
      cooldownMinutes = 1;
    } else {
      cooldownMinutes = 3;
    }
  }
} else {
  cooldownMinutes = strategyConfig?.latePeriod?.cooldownMinutes ?? 3;
}
```

#### 4.2.4 信号方向抑制

**位置**：`strategy-scheduler.service.ts` 约第 1463 行 `generateSignal` 调用之后

```typescript
const intent = await strategyInstance.generateSignal(symbol, undefined);

// 信号反转抑制：连续亏损同方向时拒绝同方向新信号
if (intent && intent.action === 'BUY' && isOptionStrategy) {
  const instState = await stateManager.getInstanceState(strategyId, symbol);
  const ctx = instState?.context;
  const consecLosses = ctx?.consecutiveLosses ?? 0;
  const lastDirection = ctx?.lastTradeDirection;
  const intentDirection = intent.metadata?.direction; // CALL or PUT

  if (consecLosses >= 2 && lastDirection && intentDirection && lastDirection === intentDirection) {
    logger.warn(
      `[SIGNAL_SUPPRESSED] 策略 ${strategyId} 标的 ${symbol}: ` +
      `信号方向 ${intentDirection} 与最近 ${consecLosses} 笔连亏方向一致，抑制信号`
    );
    summary.idle.push(`${symbol}(SIGNAL_SUPPRESSED_${intentDirection})`);
    return;
  }
}
```

#### 4.2.5 新交易日重置

**位置**：在 `strategy-scheduler.service.ts` 调度循环开始处，检测日期变更时重置

```typescript
// 检查是否为新交易日（ET时区）
if (isOptionStrategy && cancelCtx?.lastExitTime) {
  const lastExitDate = new Date(cancelCtx.lastExitTime);
  const etFormatter = new Intl.DateTimeFormat('en-US', {
    timeZone: 'America/New_York',
    year: 'numeric', month: '2-digit', day: '2-digit',
  });
  const lastExitETDate = etFormatter.format(lastExitDate);
  const nowETDate = etFormatter.format(new Date());

  if (lastExitETDate !== nowETDate) {
    // 新交易日：重置所有日内状态
    await strategyInstance.updateState(symbol, 'IDLE', {
      dailyTradeCount: 0,
      dailyRealizedPnL: 0,
      consecutiveLosses: 0,
      lastTradeDirection: null,
      lastTradePnL: 0,
      circuitBreakerActive: false,
      circuitBreakerReason: null,
      circuitBreakerTime: null,
    });
  }
}
```

### 4.3 Kill Switch 联动

现有的 `updateReverseStrategyKillSwitch`（第 979 行）被调用但未实现。本次不涉及其实现，但修复A的熔断机制在功能上已覆盖其预期作用（在亏损严重时停止交易）。后续可将 kill switch 实现为跨策略的联动熔断。

### 4.4 配置参数汇总

```json
{
  "riskLimits": {
    "circuitBreakerPercent": 30,
    "maxDailyLoss": 300,
    "maxConsecutiveLosses": 4
  }
}
```

- `circuitBreakerPercent`: 基于策略实际可用资金池的百分比，动态计算熔断阈值（默认30%）
- `maxDailyLoss`: 仅在无法获取可用资金时使用的兜底固定值（默认$300）
- `maxConsecutiveLosses`: 连续亏损笔数熔断阈值（默认4笔）

存储在 `strategies.config` JSONB 字段中，无需数据库迁移。

---

## 5. 不做什么（明确排除）

| 排除项 | 原因 |
|--------|------|
| 改造核心信号算法 | 复杂度太高，信号质量优化是独立项目 |
| 账户级（跨策略）熔断 | 当前只有策略10活跃，跨策略联动是过度工程 |
| 浮动盈亏计入日内 PnL | 浮动盈亏变化太频繁且不可靠，只用已实现盈亏 |
| 百分比制日内亏损阈值 | 策略分配资金波动较大，绝对金额更直观稳定 |
| 同方向最大并发限制（P2） | 已有 underlying 级重复开仓检查 + 资金限制，效果待观察 |
| 前端熔断状态展示 | 先做后端逻辑和日志，前端展示可后续迭代 |

---

## 6. 验收标准

### 6.1 功能验收

| # | 验收项 | 验证方法 |
|---|--------|----------|
| 1 | 卖出成交时正确计算 tradePnL 并写入 context | 查看日志：`dailyRealizedPnL` 数值合理，`consecutiveLosses` 正确递增/重置 |
| 2 | 策略级日内 PnL 聚合正确 | 多标的交易后，SQL 查询 `SUM(dailyRealizedPnL)` 与手算一致 |
| 3 | 日内亏损达 $300 时触发熔断 | 日志出现 `[CIRCUIT_BREAKER]`，后续调度周期该策略标的显示 `CIRCUIT_BREAKER` |
| 4 | 连续 4 笔亏损时触发熔断 | 同上 |
| 5 | 熔断后已有持仓正常管理 | 止盈止损仍触发，TSLPPCT/LIT 保护单不受影响 |
| 6 | 冷却期感知连续亏损 | 连亏2笔后冷却5分钟，连亏3笔后冷却15分钟（日志中 `COOLDOWN_Xm` 显示正确） |
| 7 | 信号方向抑制生效 | 连亏2笔PUT后，新PUT信号被抑制（日志 `SIGNAL_SUPPRESSED_PUT`），CALL信号放行 |
| 8 | 新交易日自动重置 | 次日首次调度时 `dailyRealizedPnL=0, consecutiveLosses=0, circuitBreakerActive=false` |
| 9 | TypeScript 编译通过 | `cd api && npx tsc --noEmit` 无错误 |
| 10 | 现有测试不受影响 | `cd api && npx jest --passWithNoTests` 全部通过 |

### 6.2 回归测试

- 正常盈利场景不受影响：单笔盈利后 `consecutiveLosses=0`，冷却期沿用原逻辑
- 冷却期向后兼容：`consecutiveLosses` 不存在时（旧 context），`?? 0` 兜底，行为等同现有逻辑
- 熔断标志不存在时（旧 context），`cancelCtx?.circuitBreakerActive` 为 falsy，不阻塞

---

## 7. 风险评估

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| PnL 计算不准确（手续费估算误差） | 中 | 低 | 手续费误差在 $1-$3 范围，对 $300 阈值影响 <1% |
| 误触发熔断（正常回撤被当作失控） | 低 | 中 | $300 阈值已为 2-3 笔正常止损空间；可手动恢复 |
| 策略级 PnL 聚合查询增加数据库负载 | 低 | 低 | 每个调度周期每个标的只查一次，且 `strategy_instances` 表数据量极小 |
| context JSONB 字段膨胀 | 极低 | 极低 | 新增约 7 个字段，每字段 <50 bytes |

---

## 8. 实施计划

| 阶段 | 内容 | 优先级 |
|------|------|--------|
| Phase 1 | PnL 追踪 + 日内亏损熔断（修复A） | P0，立即实施 |
| Phase 2 | 冷却期升级（修复B）+ 信号抑制（修复C） | P1，与 Phase 1 同批上线 |
| Phase 3 | 手动恢复 API + 前端熔断状态展示 | P2，后续迭代 |

建议 Phase 1 和 Phase 2 在同一次提交中完成——它们共享 `consecutiveLosses` 字段，拆分会导致重复改动同一区域。

---

## 9. 2/23 事件假设回测

若本方案在 2/23 已生效，事件演变：

| 时间 | 事件 | 原系统 | 新系统 |
|------|------|--------|--------|
| 11:19 | QQQ P599 亏 -$174 | 1分钟后重入 | consecutiveLosses=1, cooldown=3min |
| 11:20 | SPY P681 亏 -$104 | 立即入场 | 被3分钟冷却阻止 |
| 11:22 | (冷却中) | 11:20 又开了 SPY P682 | consecutiveLosses=2, 信号抑制（同方向PUT）, cooldown=5min |
| 11:25+ | 继续亏损 | -$16, -$159, -$38, -$21 | 已被信号抑制 + 冷却阻止 |
| 最终 | 反转后亏损 $512 | — | 反转后亏损约 $174（仅第一笔） |

**预计改善**：反转后亏损从 $512 降至约 $174，保住约 $338 利润。

---

## 10. 变更记录

| 版本 | 日期 | 变更内容 |
|-----|------|---------|
| v1.0 | 2026-02-24 | 初始版本：修复A/B/C 方案设计 |
| v1.1 | 2026-02-24 | 熔断阈值改为动态百分比（基于策略可用资金池），代码实现完成 |

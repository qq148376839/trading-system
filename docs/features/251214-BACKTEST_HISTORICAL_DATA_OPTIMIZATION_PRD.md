# 回测历史K线数据获取优化 - 产品需求文档（PRD）

## 📋 文档信息
- **文档版本**：v1.0
- **创建时间**：2025-12-14
- **最后更新**：2025-12-14
- **文档作者**：AI Product Manager
- **审核状态**：待审核

---

## 1. 背景与目标

### 1.1 业务背景

当前回测功能在获取历史K线数据时存在以下问题：

1. **标的历史K线获取效率低**：
   - 当前使用 `candlesticks()` API，只返回最近N条数据
   - 需要计算从开始日期到今天的天数，然后获取足够多的数据
   - 每个标的都需要单独调用API，效率低下

2. **市场数据获取方式不合理**：
   - 当前使用Moomoo API获取SPX、USD Index、BTC的日K数据
   - 每次回测都需要多次调用API获取数据
   - 实际只需要获取一次所有日K数据，然后从数据中切割提取即可

3. **分时数据不支持历史日期**：
   - Moomoo API的 `get-quote-minute` 只返回最新分时数据
   - 不支持历史日期参数
   - 回测中分时数据为空，影响市场环境模拟

### 1.2 用户痛点

- **回测效率低**：多个标的需要多次调用API，等待时间长
- **数据获取不准确**：需要计算天数，可能获取不到足够的历史数据
- **市场环境模拟不完整**：分时数据缺失，无法准确模拟市场环境

### 1.3 业务目标

- **主要目标**：优化回测历史数据获取方式，提升回测效率和准确性
- **成功指标**：
  - 回测数据获取时间减少50%以上
  - 数据获取准确率100%（确保获取到回测日期范围内的所有数据）
  - 市场环境模拟完整度提升（使用日K的OHLC数据模拟分时环境）

### 1.4 项目范围

- **包含范围**：
  - 使用Longbridge API的 `history_candlesticks_by_offset` 或 `history_candlesticks_by_date` 获取标的历史K线
  - 优化市场数据获取方式，一次性获取所有日K数据
  - 使用日K的OHLC数据模拟市场环境（替代分时数据）
  - 添加频次限制处理和错误处理
- **不包含范围**：
  - 不改变回测核心逻辑（资金计算、信号生成等）
  - 不改变策略计算逻辑
  - 不涉及实时数据获取优化

---

## 2. 用户与场景

### 2.1 目标用户

- **主要用户**：量化交易策略开发者、回测系统使用者
- **用户特征**：需要频繁进行回测，对数据准确性和回测效率要求高

### 2.2 使用场景

**场景1：多标的历史回测**
- **用户**：策略开发者
- **时间**：策略优化阶段
- **行为**：需要对多个标的进行历史回测，验证策略有效性
- **目标**：快速获取准确的历史数据，完成回测

**场景2：长期历史回测**
- **用户**：策略开发者
- **时间**：策略验证阶段
- **行为**：需要对标的进行1年以上的历史回测
- **目标**：确保能获取到足够的历史数据，数据准确无误

**场景3：市场环境模拟**
- **用户**：策略开发者
- **时间**：策略优化阶段
- **行为**：需要模拟历史市场环境，验证策略在不同市场条件下的表现
- **目标**：使用日K的OHLC数据准确模拟市场环境

### 2.3 用户故事

- As a 策略开发者, I want 使用Longbridge API获取标的历史K线, So that 我能快速准确地获取回测所需的历史数据
- As a 策略开发者, I want 一次性获取所有市场数据, So that 我能提升回测效率
- As a 策略开发者, I want 使用日K数据模拟市场环境, So that 我能准确模拟历史市场条件

---

## 3. 功能需求

### 3.1 功能概览

| 功能 | 优先级 | 说明 |
|------|--------|------|
| 使用Longbridge历史K线API | P0 | 改用history_candlesticks_by_offset或history_candlesticks_by_date |
| 数据格式转换层 | P0 | 统一Longbridge和Moomoo API返回的数据格式 |
| 交易日判断逻辑 | P0 | 添加交易日判断，确保只获取交易日数据 |
| 数据完整性检查 | P0 | 检查数据完整性，如果不足则降级到Moomoo |
| 优化市场数据获取 | P0 | Moomoo一次性获取所有日K数据，然后切割 |
| 分时数据处理策略 | P1 | 如果无法获取历史分时，则不使用分时数据 |
| 日K数据模拟市场环境 | P1 | 使用日K的OHLC数据模拟分时环境（线性插值或随机分布） |
| 频次限制处理 | P0 | 处理API频次限制（每30秒最多60次） |
| 配额监控 | P0 | 监控Longbridge API配额使用情况 |
| 错误处理优化 | P0 | 完善错误处理和错误码处理 |
| 降级方案 | P0 | Longbridge失败时降级到Moomoo日K接口 |

### 3.2 功能详细说明

#### 功能1：使用Longbridge历史K线API获取标的数据
**优先级**：P0

**功能描述**：
改用Longbridge SDK的 `historyCandlesticksByOffset` 或 `historyCandlesticksByDate` 方法获取标的历史K线数据，替代当前的 `candlesticks` 方法。

**技术方案**：

**方案A：使用 `historyCandlesticksByOffset`（推荐）**
- **优点**：
  - 支持按偏移量查询，灵活性高
  - 可以指定查询方向和数量
  - 适合需要获取固定数量历史数据的场景
- **缺点**：
  - 需要计算偏移量
- **实现方式**：
  ```typescript
  // 使用historyCandlesticksByOffset
  const candlesticks = await quoteCtx.historyCandlesticksByOffset(
    symbol,
    Period.Day,
    AdjustType.NoAdjust,
    false,  // direction: false表示向历史数据方向查找
    endDate,  // date: 查询日期，使用结束日期
    undefined,  // minute: 可选，分钟级查询时使用
    count  // count: 查询数量，最多1000条
  );
  ```

**方案B：使用 `historyCandlesticksByDate`**
- **优点**：
  - 直接指定日期范围，更直观
  - 自动处理日期区间内的数据
- **缺点**：
  - 如果日期范围很大，可能超过1000条限制
- **实现方式**：
  ```typescript
  // 使用historyCandlesticksByDate
  const candlesticks = await quoteCtx.historyCandlesticksByDate(
    symbol,
    Period.Day,
    AdjustType.NoAdjust,
    startDate,  // startDate: 开始日期
    endDate  // endDate: 结束日期
  );
  ```

**推荐方案**：方案A（`historyCandlesticksByOffset`）
- 原因：更灵活，可以精确控制获取的数据量，避免超过API限制

**数据获取策略**：
1. **缓存策略**：
   - Longbridge API最大支持返回1000根K线
   - 可以按照1000根K线一次性请求并缓存
   - 如果回测日期范围在1000天内，直接使用缓存数据

2. **分批获取**：
   - 如果回测日期范围超过1000天，需要分批获取
   - 每次获取1000根，从结束日期往前推
   - 合并所有批次的数据

3. **降级方案**：
   - 如果Longbridge API不可用或失败，降级到Moomoo日K接口
   - Moomoo日K接口一次性返回所有数据，不需要分批获取

**交互流程**：
1. 检查缓存（如果有1000根K线缓存且覆盖回测日期范围）
2. 如果缓存不足，计算回测日期范围（startDate到endDate）
3. 计算需要获取的数据量（最多1000根）
4. 调用 `historyCandlesticksByOffset` 获取历史K线
5. 如果失败，降级到Moomoo日K接口
6. 转换数据格式（统一为内部格式）
7. 交易日判断（过滤非交易日数据）
8. 数据完整性检查（如果不足，尝试Moomoo）
9. 过滤出回测日期范围内的数据
10. 返回标准格式的K线数据

**输入输出**：
- **输入**：
  - `symbol`: 标的代码（如 "700.HK"）
  - `startDate`: 回测开始日期
  - `endDate`: 回测结束日期
- **输出**：
  - K线数据数组：`Array<{ timestamp: Date; open: number; high: number; low: number; close: number; volume: number }>`

**边界条件**：
- **数据量超过1000条**：
  - 如果回测日期范围超过1000天，需要分批获取
  - 每次获取1000根，从结束日期往前推
  - 合并所有批次的数据
- **标的无历史数据**：
  - 如果Longbridge API返回无数据，降级到Moomoo日K接口
  - 如果Moomoo也无法获取，返回空数组，记录警告日志
- **API频次限制**：
  - 如果触发频次限制（每30秒60次），需要等待后重试
  - 添加请求间隔控制（至少0.5秒）
- **数据格式不一致**：
  - Longbridge和Moomoo返回的数据格式不同，需要统一转换
  - 确保timestamp、价格、成交量等字段格式一致

**验收标准**：
- [ ] 使用 `historyCandlesticksByOffset` 或 `historyCandlesticksByDate` 获取历史K线
- [ ] 实现数据格式转换（Longbridge格式 -> 内部格式）
- [ ] 实现交易日判断逻辑（过滤非交易日数据）
- [ ] 实现数据完整性检查（如果不足，降级到Moomoo）
- [ ] 实现降级方案（Longbridge失败 -> Moomoo日K接口）
- [ ] 实现缓存策略（1000根K线缓存）
- [ ] 实现分批获取（超过1000天的情况）
- [ ] 能够获取到回测日期范围内的所有数据
- [ ] 数据格式正确（包含timestamp、open、high、low、close、volume）
- [ ] 处理API频次限制
- [ ] 处理错误情况（无数据、无权限等）

---

#### 功能2：优化市场数据获取方式
**优先级**：P0

**功能描述**：
优化SPX、USD Index、BTC的市场数据获取方式，一次性获取所有日K数据，然后从数据中切割提取回测所需的数据。

**当前实现问题**：
- 每次回测都需要调用Moomoo API获取市场数据
- 需要计算从目标日期到今天的天数，然后获取数据
- 多个市场数据需要多次调用API

**重要说明**：
- **市场数据只能通过Moomoo获取**：Longbridge API无法获取SPX、USD Index、BTC等市场数据
- **Moomoo日K接口特性**：一次性返回所有日K数据，不需要分批获取

**优化方案**：
1. **一次性获取所有日K数据**：
   - 调用Moomoo API获取所有日K数据（一次性返回，不需要指定数量）
   - 接口：`/quote-api/quote-v2/get-kline`，参数 `type=2`（日K数据）

2. **数据切割提取**：
   - 获取到所有日K数据后，根据回测目标日期切割提取
   - 使用 `filterDataBeforeDate` 方法过滤数据

3. **数据缓存**：
   - Moomoo返回所有日K数据，可以缓存完整数据集
   - 如果回测日期范围相同，可以复用已获取的数据
   - 避免重复调用API

**交互流程**：
1. 检查是否有缓存的市场数据（相同日期范围）
2. 如果没有缓存，调用API获取所有日K数据（最多1000条）
3. 根据回测目标日期过滤数据
4. 缓存过滤后的数据
5. 返回市场数据

**输入输出**：
- **输入**：
  - `targetDate`: 目标日期（回测日期）
  - `count`: 需要的数据条数
- **输出**：
  - 市场数据对象：`{ spx: CandlestickData[], usdIndex: CandlestickData[], btc: CandlestickData[] }`

**边界条件**：
- **数据量超过1000条**：
  - 如果回测日期范围超过1000天，需要分批获取或使用其他方案
- **API限制**：
  - 注意Moomoo API的调用限制
  - 如果使用Longbridge API，注意频次限制

**验收标准**：
- [ ] 一次性获取所有日K数据（最多1000条）
- [ ] 能够正确切割提取回测所需的数据
- [ ] 数据获取时间减少50%以上
- [ ] 数据准确性100%（确保数据在目标日期范围内）

---

#### 功能3：分时数据处理策略
**优先级**：P1

**功能描述**：
处理历史分时数据的获取策略，如果无法获取历史分时数据，则不使用分时数据。

**背景**：
- Moomoo API的 `get-quote-minute` 只返回最新分时数据，不支持历史日期
- Longbridge API的历史分时数据是否可以获取当日数据，需要测试验证
- 如果两边都无法获取历史分时数据，分时数据不应该加入回测中

**处理策略**：
1. **尝试获取历史分时数据**：
   - 优先尝试Longbridge API获取历史分时数据（需要测试是否支持当日数据）
   - 如果Longbridge不支持，尝试Moomoo API（已知不支持历史日期）

2. **分时数据可用性判断**：
   - 如果能够获取到历史分时数据，使用分时数据
   - 如果无法获取历史分时数据，不使用分时数据，回测中分时数据为空

3. **回测逻辑调整**：
   - 如果分时数据为空，策略计算中不使用分时数据
   - 使用日K的OHLC数据替代分时数据（见功能4）

**验收标准**：
- [ ] 测试Longbridge API是否支持历史分时数据（当日数据）
- [ ] 如果无法获取历史分时数据，分时数据为空
- [ ] 回测逻辑能够正确处理分时数据为空的情况
- [ ] 不影响回测功能正常运行

---

#### 功能4：使用日K数据模拟市场环境
**优先级**：P1

**功能描述**：
当无法获取历史分时数据时，使用日K数据的开盘价、最低价、最高价来模拟市场环境。

**背景**：
- 历史分时数据无法获取（Moomoo不支持，Longbridge待测试）
- 回测中需要使用市场环境数据
- 使用日K的OHLC数据模拟分时环境

**模拟方案对比**：

**方案A：线性插值（推荐）**
- **优点**：
  - 价格变化平滑，符合市场实际走势
  - 实现简单，计算效率高
- **缺点**：
  - 无法模拟价格波动
- **实现方式**：
  - 在开盘价和收盘价之间线性插值
  - 确保价格在最高价和最低价范围内

**方案B：随机分布**
- **优点**：
  - 可以模拟价格波动
  - 更接近实际市场情况
- **缺点**：
  - 实现复杂，需要控制随机性
  - 可能导致回测结果不稳定
- **实现方式**：
  - 在最高价和最低价之间随机分布
  - 使用正态分布或其他分布模型

**推荐方案**：方案A（线性插值）
- 原因：实现简单，价格变化平滑，回测结果稳定

**解决方案**：
使用日K数据的OHLC（开盘价、最高价、最低价、收盘价）来模拟市场环境：

1. **开盘价（Open）**：模拟当日开盘时的价格
2. **最高价（High）**：模拟当日最高价格
3. **最低价（Low）**：模拟当日最低价格
4. **收盘价（Close）**：模拟当日收盘价格
5. **线性插值**：在开盘价和收盘价之间线性插值，生成分时价格序列

**应用场景**：
- 策略计算中需要使用分时数据时，使用日K的OHLC数据模拟
- 市场环境判断时，使用日K的OHLC数据

**交互流程**：
1. 检查是否有历史分时数据
2. 如果没有分时数据，获取日K数据（包含OHLC）
3. 使用线性插值生成分时价格序列
4. 在策略计算中使用模拟的分时数据

**输入输出**：
- **输入**：
  - 日K数据：`{ open: number, high: number, low: number, close: number }`
- **输出**：
  - 模拟的分时价格序列（用于策略计算）

**边界条件**：
- **数据缺失**：
  - 如果日K数据缺失，使用前一日的数据或抛出错误
- **价格异常**：
  - 如果OHLC数据异常（如high < low），需要处理
- **插值范围**：
  - 确保插值价格在最高价和最低价范围内

**验收标准**：
- [ ] 实现线性插值算法（开盘价到收盘价）
- [ ] 确保插值价格在最高价和最低价范围内
- [ ] 策略计算能够正常使用模拟数据
- [ ] 市场环境判断准确（基于日K数据）

---

#### 功能4：频次限制处理
**优先级**：P0

**功能描述**：
处理Longbridge API的频次限制（每30秒最多60次请求），避免触发限流。

**API限制**：
- 每30秒内最多请求60次历史K线接口
- 如果超过限制，会返回错误码 `301606`（限流）

**处理方案**：
1. **请求队列**：
   - 使用请求队列管理API请求
   - 控制请求频率，确保不超过限制

2. **请求间隔**：
   - 在请求之间添加间隔（至少0.5秒）
   - 确保30秒内不超过60次请求

3. **错误重试**：
   - 如果触发限流，等待后重试
   - 使用指数退避策略

**交互流程**：
1. 检查当前请求频率（30秒内的请求次数）
2. 如果接近限制，等待后再请求
3. 发送API请求
4. 如果返回限流错误，等待后重试

**输入输出**：
- **输入**：
  - API请求参数
- **输出**：
  - API响应数据或错误信息

**边界条件**：
- **触发限流**：
  - 返回错误码 `301606`
  - 等待后重试（使用指数退避）
- **请求队列满**：
  - 如果请求队列已满，等待或拒绝请求

**验收标准**：
- [ ] 实现请求频率控制（30秒内不超过60次）
- [ ] 处理限流错误（错误码301606）
- [ ] 实现错误重试机制
- [ ] 避免触发API限流

---

#### 功能5：数据格式转换层
**优先级**：P0

**功能描述**：
统一Longbridge API和Moomoo API返回的数据格式，转换为内部标准格式。

**背景**：
- Longbridge API和Moomoo API返回的数据格式不同
- 需要统一转换为内部标准格式，确保后续处理一致

**数据格式差异**：

**Longbridge API格式**：
```typescript
{
  close: string,      // 收盘价（字符串）
  open: string,       // 开盘价（字符串）
  low: string,        // 最低价（字符串）
  high: string,       // 最高价（字符串）
  volume: int64,      // 成交量（整数）
  turnover: string,   // 成交额（字符串）
  timestamp: int64,   // 时间戳（秒或毫秒）
  trade_session: int32 // 交易时段
}
```

**Moomoo API格式**（✅ 已确认实际返回格式）：
```typescript
// 实际API返回的完整结构：
{
  code: number,       // 状态码，0表示成功
  message: string,    // 消息，如 "成功"
  data: {
    list: Array<{
      k: number,      // 时间戳（秒级），如 1275364800
      o: string,      // 开盘价（字符串），如 "1.266654"
      c: string,      // 收盘价（字符串），如 "1.58865078"
      h: string,      // 最高价（字符串），如 "2.027926387"
      l: string,      // 最低价（字符串），如 "1.16932164"
      v: number,      // 成交量（数字），如 539665050
      t: number,      // 其他字段，如 0
      r: number,      // 其他字段，如 0.20715
      lc: string,     // 其他字段，如 "1.133322"
      cp: string      // 其他字段，如 "0.45532878"
    }>
  }
}

// 注意：
// - 数据在 data.list 数组中
// - 价格字段（o/c/h/l）是字符串类型，需要parseFloat()转换
// - 时间戳k是秒级时间戳
// - 成交量v是数字类型
// - 没有明确的成交额字段（turnover），设为0（与当前代码实现一致）
// - 分时数据（type=1）只支持当天，回测中不做处理
```

**内部标准格式**：
```typescript
{
  timestamp: Date,    // 时间戳（Date对象）
  open: number,       // 开盘价（数字）
  high: number,       // 最高价（数字）
  low: number,        // 最低价（数字）
  close: number,      // 收盘价（数字）
  volume: number,     // 成交量（数字）
  turnover?: number,  // 成交额（可选，数字）
  trade_session?: number // 交易时段（可选）
}
```

**转换逻辑**（✅ 已根据实际API返回格式确认）：

1. **价格字段转换**：
   - **Longbridge**（✅ 已确认）：
     - `open/high/low/close` 是字符串类型：`parseFloat(c.open)` -> `number`
     - 示例：`parseFloat("362.000")` -> `362.0`
   - **Moomoo**（✅ 已确认）：
     - 日K数据：`parseFloat(item.c)` -> `close` (number)
     - 日K数据：`parseFloat(item.o)` -> `open` (number)
     - 日K数据：`parseFloat(item.h)` -> `high` (number)
     - 日K数据：`parseFloat(item.l)` -> `low` (number)
     - 分时数据：不做处理（只支持当天，回测中不使用）

2. **时间戳转换**：
   - **Longbridge**（✅ 已确认）：
     - `timestamp` 是秒级时间戳（number类型）
     - 转换为Date对象：`new Date(c.timestamp * 1000)`
     - 转换为毫秒时间戳：`c.timestamp * 1000`
   - **Moomoo**（✅ 已确认）：
     - `k`字段是秒级时间戳（number类型）
     - 转换为毫秒时间戳：`item.k * 1000`
     - 转换为Date对象：`new Date(item.k * 1000)`

3. **成交量转换**：
   - **Longbridge**（✅ 已确认）：
     - `volume` 是number类型，直接使用
   - **Moomoo**（✅ 已确认）：
     - `v` 是number类型，直接使用

4. **成交额转换**：
   - **Longbridge**（✅ 已确认）：
     - `turnover` 是字符串类型：`parseFloat(c.turnover)` -> `number`
   - **Moomoo**（✅ 已确认处理方案）：
     - 没有明确的成交额字段
     - **推荐方案**：设为0（与当前代码实现一致）
     - **理由**：
       1. 成交额在回测中不是核心字段，主要用于市场分析
       2. 如果计算成交额，需要选择价格（开/高/低/收），选择哪个价格不明确
       3. 计算出的成交额可能与实际成交额有偏差，不如直接设为0
       4. 当前代码已经这样处理，保持一致性

**交互流程**：
1. 获取API响应数据
2. 识别数据源（Longbridge或Moomoo）
3. **Longbridge数据提取**：
   - 从 `response.candlesticks` 数组中提取数据
   - 每个元素包含：`close`, `open`, `low`, `high`, `volume`, `turnover`, `timestamp`
4. **Moomoo数据提取**：
   - 从 `response.data.list` 数组中提取数据
   - 每个元素包含：`c`, `o`, `h`, `l`, `v`, `k`
   - 成交额（turnover）设为0（Moomoo不提供此字段）
5. 根据数据源选择对应的转换逻辑
6. 转换为内部标准格式
7. 返回统一格式的数据

**验收标准**：
- [x] ✅ 确认Longbridge数据格式（已提供实际返回数据）
- [x] ✅ 确认Moomoo数据格式（已提供实际返回数据）
- [ ] 实现Longbridge数据格式转换（根据确认的格式实现）
- [ ] 实现Moomoo数据格式转换（代码中已实现，需要确认是否完整）
- [ ] 统一转换为内部标准格式
- [ ] 处理各种数据格式变体（`cc_price`, `price/100`等）
- [ ] 时间戳正确转换（秒级时间戳 -> 毫秒时间戳或Date对象）
- [ ] 处理Moomoo数据嵌套结构（`data.list`）

**⚠️ 代码问题发现**：
- ❌ `backtest.service.ts` 第100行：timestamp处理错误，应该是 `new Date(c.timestamp * 1000)` 而不是 `new Date(c.timestamp)`
- ❌ `trading-recommendation.service.ts` 第292行：timestamp处理错误，应该是毫秒时间戳
- ❌ 数据转换逻辑重复，需要提取为统一工具函数
- ❌ `backtest.service.ts` 缺少turnover字段处理

**✅ 已确认事项**：
- [x] `historyCandlesticksByOffset()` 和 `historyCandlesticksByDate()` 返回格式相同
- [x] Longbridge API返回的 `timestamp` 是秒级时间戳（number类型）
- [x] Longbridge API返回的 `open/high/low/close` 是字符串类型
- [x] Longbridge API返回的 `turnover` 是字符串类型
- [x] Longbridge API返回的 `volume` 是number类型
- [x] Moomoo日K数据使用 `c/o/h/l/v/k` 字段
- [x] Moomoo数据嵌套在 `data.list` 数组中

**✅ 已确认事项（补充）**：
- [x] ✅ Moomoo日K数据的成交额字段不存在，设为0（与当前代码实现一致）
- [x] ✅ Moomoo分时数据只支持当天，回测中不做Moomoo分时数据处理

---

#### 功能6：交易日判断逻辑
**优先级**：P0

**功能描述**：
添加交易日判断逻辑，确保只获取交易日的数据，过滤非交易日（周末、节假日等）。

**背景**：
- 不同市场的交易日不同（港股、美股、A股）
- 需要过滤非交易日数据，确保回测准确性

**交易日判断**：
1. **周末判断**：
   - 周六、周日为非交易日

2. **节假日判断**：
   - 港股：香港节假日
   - 美股：美国节假日
   - A股：中国节假日

3. **市场特定规则**：
   - 不同市场可能有不同的交易日规则
   - 需要根据标的代码判断市场类型

**实现方案**：
1. **使用Longbridge API获取交易日**：
   - 使用 `getTradingDays` API获取交易日列表
   - 或使用交易日历数据

2. **交易日过滤**：
   - 获取历史K线数据后，过滤出交易日数据
   - 确保数据只包含交易日

**交互流程**：
1. 获取历史K线数据
2. 获取交易日列表（或使用交易日历）
3. 过滤出交易日数据
4. 返回交易日数据

**验收标准**：
- [ ] 实现交易日判断逻辑
- [ ] 过滤周末数据
- [ ] 过滤节假日数据（如果能够获取节假日列表）
- [ ] 确保返回的数据只包含交易日

---

#### 功能7：数据完整性检查
**优先级**：P0

**功能描述**：
检查获取的数据是否完整，如果数据不足，降级到Moomoo日K接口。

**检查逻辑**：
1. **数据量检查**：
   - 检查获取的数据量是否满足回测需求
   - 如果数据量不足，尝试Moomoo日K接口

2. **日期范围检查**：
   - 检查数据是否覆盖回测日期范围
   - 如果日期范围不完整，尝试Moomoo日K接口

3. **数据质量检查**：
   - 检查数据是否有缺失值
   - 检查数据是否有异常值

**降级策略**：
1. **Longbridge API失败**：
   - 如果Longbridge API返回无数据或数据不足
   - 降级到Moomoo日K接口

2. **Moomoo日K接口**：
   - Moomoo日K接口一次性返回所有数据
   - 不需要分批获取
   - 如果Moomoo也无法获取，记录错误并返回空数组

**交互流程**：
1. 尝试使用Longbridge API获取数据
2. 检查数据完整性（数据量、日期范围、数据质量）
3. 如果数据不足，降级到Moomoo日K接口
4. 再次检查数据完整性
5. 如果仍然不足，记录错误并返回空数组

**验收标准**：
- [ ] 实现数据完整性检查（数据量、日期范围、数据质量）
- [ ] 实现降级方案（Longbridge -> Moomoo）
- [ ] 如果数据不足，正确降级到Moomoo
- [ ] 记录详细的错误日志

---

#### 功能8：配额监控
**优先级**：P0

**功能描述**：
监控Longbridge API的配额使用情况，提前预警配额不足。

**配额限制**：
根据用户资产和交易情况，不同类型的用户每月可查询历史数据的标的数量不同：
- 用户开户：基础额度
- 总资产达1万HKD：提升额度
- 总资产达8万HKD：进一步提升
- 总资产达40万HKD或月交易笔数>160笔：更高额度
- 总资产达400万HKD或月交易笔数>1600笔：更高额度
- 总资产达600万HKD或月交易笔数>2500笔：最高额度

**监控指标**：
1. **当月查询标的数量**：
   - 统计当月已查询的标的数量
   - 对比配额上限

2. **配额使用率**：
   - 计算配额使用率（已使用/总配额）
   - 如果使用率超过80%，发出警告

3. **配额重置时间**：
   - 配额按照自然月计算，每月初重置
   - 记录配额重置时间

**实现方案**：
1. **配额统计**：
   - 记录每次查询的标的代码
   - 统计当月查询的标的数量（去重）

2. **配额检查**：
   - 查询前检查配额使用情况
   - 如果接近配额上限，发出警告

3. **配额预警**：
   - 如果配额使用率超过80%，记录警告日志
   - 如果配额使用率超过95%，拒绝新的查询请求

**交互流程**：
1. 查询前检查配额使用情况
2. 如果配额充足，执行查询
3. 记录查询的标的代码
4. 更新配额统计
5. 如果配额不足，发出警告或拒绝查询

**验收标准**：
- [ ] 实现配额统计（当月查询标的数量）
- [ ] 实现配额检查（查询前检查）
- [ ] 实现配额预警（使用率超过80%警告）
- [ ] 记录配额使用日志

---

#### 功能9：错误处理优化
**优先级**：P0

**功能描述**：
完善错误处理，处理Longbridge API的各种错误情况。

**错误码处理**：

| 协议错误码 | 业务错误码 | 描述 | 处理方式 |
|-----------|-----------|------|---------|
| 3 | 301600 | 无效的请求 | 检查请求参数，记录错误日志 |
| 3 | 301606 | 限流 | 等待后重试（见功能4） |
| 7 | 301602 | 服务端内部错误 | 重试或联系技术支持 |
| 7 | 301600 | 请求数据非法 | 检查symbol、count、adjust_type、period参数 |
| 7 | 301603 | 标的无行情 | 返回空数组，记录警告日志 |
| 7 | 301604 | 无权限 | 检查权限配置，记录错误日志 |
| 7 | 301607 | 接口限制 | 超过当月查询标的数量上限，记录错误日志 |

**处理策略**：
1. **可重试错误**：
   - 301606（限流）：等待后重试
   - 301602（服务端错误）：重试1-2次

2. **不可重试错误**：
   - 301600（无效请求）：检查参数，不重试
   - 301603（无行情）：返回空数组，不重试
   - 301604（无权限）：检查配置，不重试
   - 301607（接口限制）：记录错误，不重试

**交互流程**：
1. 发送API请求
2. 检查响应状态
3. 如果错误，根据错误码处理
4. 记录错误日志
5. 返回结果或抛出错误

**输入输出**：
- **输入**：
  - API请求参数
- **输出**：
  - 成功：返回数据
  - 失败：抛出错误或返回空数组

**边界条件**：
- **网络错误**：
  - 网络超时或连接失败，重试1-2次
- **数据格式错误**：
  - 如果返回数据格式不正确，记录错误并返回空数组

**验收标准**：
- [ ] 处理所有错误码（301600、301606、301602、301603、301604、301607）
- [ ] 实现错误重试机制（可重试错误）
- [ ] 记录详细的错误日志
- [ ] 用户友好的错误提示

---

## 4. 非功能需求

### 4.1 性能要求

- **数据获取时间**：
  - 单个标的历史K线获取时间 ≤ 2秒
  - 市场数据获取时间 ≤ 3秒
  - 总体回测数据获取时间减少50%以上

- **API调用频率**：
  - 遵守Longbridge API频次限制（每30秒最多60次）
  - 实现请求频率控制

- **数据准确性**：
  - 数据获取准确率100%
  - 确保获取到回测日期范围内的所有数据

### 4.2 安全要求

- **API密钥管理**：
  - 使用环境变量或数据库存储API密钥
  - 不在代码中硬编码密钥

- **错误信息**：
  - 不暴露敏感信息（如API密钥）
  - 错误日志中不包含敏感数据

### 4.3 兼容性要求

- **Longbridge SDK版本**：
  - 确保使用支持 `historyCandlesticksByOffset` 和 `historyCandlesticksByDate` 的SDK版本
  - 参考文档：https://longportapp.github.io/openapi/nodejs/classes/QuoteContext.html#historycandlesticksbyoffset

- **数据格式兼容**：
  - 确保返回的数据格式与现有代码兼容
  - 不破坏现有的回测逻辑

### 4.4 可维护性要求

- **代码规范**：
  - 遵循项目代码规范
  - 添加详细的注释和文档

- **日志记录**：
  - 记录关键操作日志（数据获取、错误处理等）
  - 便于问题排查和调试

---

## 5. 技术方案

### 5.1 技术选型

**Longbridge SDK**：
- 使用Node.js SDK：`@longportapp/openapi`
- 参考文档：https://longportapp.github.io/openapi/nodejs/classes/QuoteContext.html#historycandlesticksbyoffset

**API方法选择**：
- 优先使用 `historyCandlesticksByOffset`（更灵活）
- 备选 `historyCandlesticksByDate`（日期范围查询）

**市场数据获取**：
- **只能使用Moomoo API**：Longbridge API无法获取SPX、USD Index、BTC等市场数据
- Moomoo日K接口一次性返回所有数据，不需要分批获取
- 优化为一次性获取所有日K数据，然后切割

### 5.2 架构设计

**数据获取流程**：
```
回测服务
  ↓
getHistoricalCandlesticks() (标的K线)
  ↓
尝试Longbridge API: historyCandlesticksByOffset/ByDate
  ↓
数据格式转换（Longbridge格式 -> 内部格式）
  ↓
交易日判断（过滤非交易日）
  ↓
数据完整性检查
  ↓
如果数据不足，降级到Moomoo日K接口
  ↓
数据格式转换（Moomoo格式 -> 内部格式）
  ↓
过滤日期范围
  ↓
返回K线数据

回测服务
  ↓
getHistoricalMarketData() (市场数据)
  ↓
Moomoo API: 一次性获取所有日K数据（只能使用Moomoo）
  ↓
数据格式转换（Moomoo格式 -> 内部格式）
  ↓
filterDataBeforeDate() 过滤到目标日期
  ↓
返回市场数据
```

**请求频率控制**：
```
请求队列
  ↓
检查30秒内请求次数
  ↓
如果 < 60次，立即请求
  ↓
如果 >= 60次，等待后请求
  ↓
发送API请求
```

### 5.3 接口设计

**getHistoricalCandlesticks接口**：
```typescript
/**
 * 获取标的历史K线数据
 * @param symbol 标的代码（如 "700.HK"）
 * @param startDate 回测开始日期
 * @param endDate 回测结束日期
 * @param period K线周期（默认Period.Day）
 * @param adjustType 复权类型（默认AdjustType.NoAdjust）
 * @returns K线数据数组
 */
async getHistoricalCandlesticks(
  symbol: string,
  startDate: Date,
  endDate: Date,
  period: Period = Period.Day,
  adjustType: AdjustType = AdjustType.NoAdjust
): Promise<Array<{
  timestamp: Date;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}>>
```

**getHistoricalMarketData接口**（优化后）：
```typescript
/**
 * 获取历史市场数据（优化版）
 * @param targetDate 目标日期
 * @param count 需要的数据条数
 * @returns 市场数据对象
 */
async getHistoricalMarketData(
  targetDate: Date,
  count: number = 100
): Promise<{
  spx: CandlestickData[];
  usdIndex: CandlestickData[];
  btc: CandlestickData[];
}>
```

### 5.4 数据模型

**K线数据格式**：
```typescript
interface CandlestickData {
  timestamp: Date;      // 时间戳
  open: number;         // 开盘价
  high: number;         // 最高价
  low: number;          // 最低价
  close: number;        // 收盘价
  volume: number;       // 成交量
  turnover?: string;    // 成交额（可选）
  trade_session?: number; // 交易时段（可选）
}
```

---

## 6. 风险评估

### 6.1 技术风险

**风险1：API频次限制**
- **风险描述**：Longbridge API有频次限制（每30秒60次），可能影响数据获取速度
- **影响程度**：中
- **应对措施**：
  - 实现请求频率控制
  - 使用请求队列管理请求
  - 添加请求间隔

**风险2：数据量限制**
- **风险描述**：单次最多获取1000条数据，如果回测日期范围很大，可能需要分批获取
- **影响程度**：中
- **应对措施**：
  - 如果日期范围超过1000天，分批获取
  - 或使用 `historyCandlesticksByDate` 方法

**风险3：SDK版本兼容性**
- **风险描述**：SDK版本可能不支持新的API方法
- **影响程度**：低
- **应对措施**：
  - 检查SDK版本，确保支持新方法
  - 如果不支持，使用备选方案

### 6.2 业务风险

**风险1：数据准确性**
- **风险描述**：如果数据获取不准确，会影响回测结果
- **影响程度**：高
- **应对措施**：
  - 添加数据验证逻辑
  - 确保数据在回测日期范围内
  - 添加数据完整性检查

**风险2：回测效率**
- **风险描述**：如果优化不当，可能反而降低回测效率
- **影响程度**：中
- **应对措施**：
  - 充分测试优化后的性能
  - 对比优化前后的性能指标
  - 如果性能下降，回滚优化

### 6.3 时间风险

**风险1：开发时间**
- **风险描述**：优化涉及多个模块，可能需要较长时间
- **影响程度**：中
- **应对措施**：
  - 分阶段实施（先实现核心功能，再优化）
  - 充分测试，避免返工

---

## 7. 迭代计划

### 7.1 MVP范围（第一阶段）

**核心功能**：
1. ✅ 使用 `historyCandlesticksByOffset` 获取标的历史K线
2. ✅ 实现数据格式转换层（Longbridge和Moomoo格式统一）
3. ✅ 实现交易日判断逻辑
4. ✅ 实现数据完整性检查
5. ✅ 实现降级方案（Longbridge失败 -> Moomoo日K接口）
6. ✅ 优化市场数据获取方式（Moomoo一次性获取所有日K数据）
7. ✅ 添加频次限制处理
8. ✅ 添加配额监控
9. ✅ 完善错误处理

**验收标准**：
- 回测数据获取时间减少50%以上
- 数据获取准确率100%
- 不触发API频次限制
- 数据格式统一（Longbridge和Moomoo）
- 交易日数据正确（过滤非交易日）
- 降级方案正常工作（Longbridge失败时使用Moomoo）

### 7.2 后续迭代（第二阶段）

**优化功能**：
1. 测试Longbridge API是否支持历史分时数据（当日数据）
2. 实现分时数据处理策略（如果无法获取，不使用分时数据）
3. 使用日K数据模拟市场环境（线性插值或随机分布）
4. 数据缓存优化（复用相同日期范围的数据）
5. 性能进一步优化

---

## 8. 测试计划

### 8.1 单元测试

**测试用例**：
1. 测试 `getHistoricalCandlesticks` 方法：
   - 正常获取历史K线数据
   - 处理日期范围过滤
   - 处理空数据情况

2. 测试 `getHistoricalMarketData` 方法：
   - 一次性获取所有日K数据
   - 正确切割提取数据
   - 处理数据缺失情况

3. 测试频次限制处理：
   - 测试请求频率控制
   - 测试限流错误处理
   - 测试错误重试机制

### 8.2 集成测试

**测试场景**：
1. 多标的历史回测：
   - 测试多个标的的数据获取
   - 验证数据准确性
   - 验证回测效率

2. 长期历史回测：
   - 测试1年以上的历史回测
   - 验证数据完整性
   - 验证性能表现

### 8.3 性能测试

**测试指标**：
1. 数据获取时间：
   - 单个标的：≤ 2秒
   - 市场数据：≤ 3秒
   - 总体：减少50%以上

2. API调用频率：
   - 30秒内不超过60次
   - 不触发限流

---

## 9. 注意事项

### 9.1 重要提醒

1. **不要编造代码**：
   - 所有代码实现必须基于实际API和SDK
   - 参考Longbridge SDK文档：https://longportapp.github.io/openapi/nodejs/classes/QuoteContext.html#historycandlesticksbyoffset

2. **API参数注意**：
   - `period`: K线周期（1-4000，详见文档）
   - `adjustType`: 复权类型（0=除权，1=前复权）
   - `count`: 查询数量，范围[1,1000]

3. **历史K线区间限制**：
   - 港股：日K线2004-6-1至今，分钟K线2022-09-28至今
   - 美股：日K线2010-6-1至今，分钟K线2023-12-4至今

4. **频次限制**：
   - 每30秒内最多请求60次历史K线接口
   - 必须实现请求频率控制

### 9.2 关键实现要点

1. **数据格式转换**（已包含）：
   - ✅ Longbridge和Moomoo返回的数据格式不同，需要统一转换
   - ✅ 实现数据格式转换层，统一为内部标准格式

2. **交易日判断**（已包含）：
   - ✅ 添加交易日判断逻辑，过滤非交易日数据
   - ✅ 注意不同市场的交易日规则不同

3. **数据完整性检查**（已包含）：
   - ✅ 检查数据量、日期范围、数据质量
   - ✅ 如果Longbridge数据不足，降级到Moomoo日K接口

4. **市场数据获取**（已明确）：
   - ✅ 市场数据（SPX、USD Index、BTC）只能通过Moomoo获取
   - ✅ Longbridge API无法获取市场数据

5. **频次限制**（已包含）：
   - ✅ 每30秒内最多请求60次历史K线接口
   - ✅ 必须实现请求频率控制

6. **缓存策略**（已包含）：
   - ✅ Longbridge API：按照1000根K线一次性请求缓存
   - ✅ Moomoo API：一次性返回所有日K数据，不需要分批获取

7. **降级方案**（已包含）：
   - ✅ 如果Longbridge API不可用，降级到Moomoo日K接口
   - ✅ Moomoo日K接口一次性返回所有数据

8. **分时数据处理**（已包含）：
   - ✅ 测试Longbridge API是否支持历史分时数据（当日数据）
   - ✅ 如果两边都无法获取历史分时数据，分时数据不应该加入回测中
   - ✅ 使用日K的OHLC数据模拟分时环境（线性插值或随机分布）

9. **分批获取**（已包含）：
   - ✅ Longbridge API：如果超过1000天，需要分批获取
   - ✅ Moomoo API：不需要分批获取（一次性返回所有数据）

10. **配额监控**（已包含）：
    - ✅ 监控Longbridge API配额使用情况
    - ✅ 提前预警配额不足

11. **时区处理**：
    - 注意时间戳的时区问题
    - 确保日期比较的准确性

12. **数据排序**：
    - 确保返回的数据按时间顺序排序
    - 便于后续处理

13. **日志记录**：
    - 记录关键操作日志（数据获取、错误处理、配额使用等）
    - 便于问题排查和性能分析

14. **向后兼容**：
    - 确保优化后的代码不影响现有功能
    - 如果API不可用，需要有降级方案

---

## 10. 相关文档

- [Longbridge历史K线API文档](https://open.longbridge.com/zh-CN/docs/quote/pull/history-candlestick)
- [Longbridge Node.js SDK文档](https://longportapp.github.io/openapi/nodejs/classes/QuoteContext.html#historycandlesticksbyoffset)
- [回测逻辑修复PRD](./251212-BACKTEST_LOGIC_FIX_PRD.md)
- [Moomoo历史市场数据说明](./251214-MOOMOO_HISTORICAL_MARKET_DATA.md)
- **[API数据格式核对清单](./251214-API_DATA_FORMAT_VERIFICATION.md)** ⚠️ 重要：需要确认各API的实际返回格式
- **[代码核对清单](./251214-CODE_REVIEW_CHECKLIST.md)** ⚠️ 重要：代码实现核对，发现的问题和待实现功能

---

## 11. 变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|------|------|----------|--------|
| v1.0 | 2025-12-14 | 初始版本，完整需求分析 | AI Product Manager |

---

**文档状态**：待开发  
**下一步行动**：开发团队根据PRD文档进行技术实现，优先实现MVP范围的功能


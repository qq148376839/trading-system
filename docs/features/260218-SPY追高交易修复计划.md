# SPY260217P676000 追高交易修复计划

**制定日期**: 2026-02-18  
**基于复盘**: `docs/analysis/260218-SPY260217P676000-追高交易复盘.md`  
**优先级**: P0（致命问题）→ P1（高优先级）→ P2（中优先级）→ P3（长期策略优化）

---

## 📋 执行摘要

### ⚠️ 关键决策更新（2026-02-19）

基于产品经理确认，修复计划已更新以下三个关键决策：

1. **开盘前30分钟保护的必要性** → **直接移除所有延迟类过滤（RSI过滤、价格确认等待、连续确认），0DTE禁入窗口缩短至15分钟并1周后评估**
   - 产品经理确认直接移除过滤层，期权需要快速抓住入场机会
   - RSI/价格确认/连续确认一次性移除，配合动态风控控制风险
   - 0DTE 总共只有 6.5 小时，禁入 30 分钟损失 7.7% 交易窗口

2. **0DTE 订单类型** → **采用市价单 + 动态调整盈亏比例（而非强制限价单）**
   - 理由：错过入场机会的成本 > 追价成交的成本
   - 方案：根据实际成交价与信号价的偏差动态收紧止损/止盈
   - 价差越大，trailing 和止损越紧，自适应控制风险

3. **策略修订** → **直接修订核心逻辑（非评估，已确认系统性缺陷）**
   - 复盘 Section 14 明确证明策略有系统性缺陷（2/17 + 2/18 连续反向入场）
   - 产品经理确认：历史数据不足无法回测，但继续使用当前策略只会每日亏损
   - 接受反向策略的亏损风险，依靠动态调整风控降低亏损
   - 添加 kill switch 作为安全网：连续亏损超阈值时自动回退
   - 修订方向：精简过滤层 + 反向指标策略 + 可选波动率交易

4. **VWAP 结构确认与反向策略冲突** → **极端信号（|score| >= 15）时跳过 VWAP 结构确认**
   - 问题：反向策略入场方向与 VWAP 结构天然矛盾，极端看空时价格在 VWAP 下方，反向买 CALL 会被 VWAP 拦截
   - 方案：当反向策略触发时跳过 VWAP 结构确认；非极端信号仍保留 VWAP 作为安全网

5. **退出后冷却期** → **0DTE 根据当日交易次数动态调整（0→1→3 分钟递增）**
   - 问题：固定 3 分钟冷却期在 0DTE 场景下浪费交易窗口，部分导致每天只交易一只股票
   - 方案：前 1-2 笔无冷却，第 3-4 笔 1 分钟，第 5 笔起 3 分钟，非 0DTE 不变

6. **0DTE 冷却窗口动态化** → **极端信号（|score| >= 15）绕过冷却窗口，非极端保留 15 分钟冷却**
   - 问题：固定 15 分钟冷却可能错过开盘极端机会（重大事件驱动的极端信号）
   - 方案：与 VWAP 跳过逻辑一致，形成统一的"极端信号快速通道"
   - 极端信号：跳过冷却，直接 0DTE 入场
   - 非极端信号：保留 15 分钟冷却，降级 1DTE/2DTE

7. **策略类型全覆盖与前端配置集成** → **各修复项需适配所有已启用的策略类型，反向策略需验证目标策略是否在前端配置中启用**
   - 问题：修复计划主要以 PUT/CALL 单边为例，未覆盖跨式买入(STRADDLE_BUY)、牛市价差(BULL_SPREAD)、熊市价差(BEAR_SPREAD)
   - 问题：反向策略(Fix 8b)反转方向后未检查目标策略类型是否在前端配置中启用
   - 方案：
     - Fix 8b 反向策略仅适用于 DIRECTIONAL_CALL / DIRECTIONAL_PUT（方向反转对跨式/价差无意义）
     - 反向策略触发时，检查反转后的策略类型是否在 config.strategyTypes.buyer 中启用
     - Fix 8a/8c/Fix 4/Fix 11 对所有策略类型生效（它们是通用的入场过滤/冷却逻辑）
     - STRADDLE_BUY 基于 VIX 触发，不受方向/VWAP/反向策略影响
     - BULL_SPREAD / BEAR_SPREAD 与 DIRECTIONAL_CALL/PUT 共享方向逻辑，受 Fix 8a/8c 影响但不受 Fix 8b 反向策略影响

---

### 核心问题
系统在 2026-02-17 的 SPY 0DTE Put 交易中亏损 -$66.14 (-31.4%)，根因包括：
1. **VWAP 结构确认因技术故障失效**，降级放行策略导致安全网被绕过
2. **评分信号滞后性**，在趋势末端产生最强信号
3. **禁入窗口边界效应**，窗口结束后立即入场
4. **策略本质不适合期权交易**，多层确认机制导致追高入场

### 修复目标
- **短期（P0/P1）**: 修复技术故障，增强安全网，减少类似亏损
- **中期（P2）**: 优化入场机制，提升执行质量
- **长期（P3）**: **直接修订策略核心逻辑**（非评估，已确认系统性缺陷）

### 预期效果
根据复盘文档 Section 10 的 5-Fix 模拟：
- **修复前**: -$66.14 (-31.4%)
- **修复后（5-Fix）**: -$17.64 (-8.3%) 或 -$1.64 (-0.8%)（TSLPPCT trailing=10%）
- **改善幅度**: $48.50 ~ $64.50 (23.1 ~ 30.3 个百分点)

---

## 🎯 修复项清单

### P0 - 致命问题（立即修复）

#### Fix 1: VWAP 降级策略改为保守拒绝
**问题**: VWAP 获取失败时，系统跳过结构确认并降级放行，导致唯一能识别反转的安全网失效。

**修复方案**:
```typescript
// 文件: api/src/services/strategies/option-intraday-strategy.ts
// 位置: ~line 910-915

// 修改前:
if (!vwapData) {
  logger.debug(`[结构确认] ${symbol} VWAP数据不可用，跳过结构确认（降级放行）`);
}

// 修改后:
if (!vwapData) {
  // 0DTE 入场必须通过 VWAP 结构确认，不可降级放行
  if (is0DTEEntry) {
    logger.warn(
      `[结构确认] ${symbol} VWAP数据不可用，拒绝0DTE入场（安全网失效）`
    );
    logData.finalResult = 'NO_SIGNAL';
    logData.rejectionReason = 'VWAP_UNAVAILABLE_0DTE_BLOCKED';
    logData.rejectionCheckpoint = 'structure_confirm';
    this.logDecision(logData);
    return null;
  }
  // 1DTE/2DTE 允许降级放行（容错空间更大）
  logger.debug(`[结构确认] ${symbol} VWAP数据不可用，跳过结构确认（降级放行，非0DTE）`);
}
```

**预期效果**: 直接阻止本次亏损场景，VWAP 不可用时 0DTE 拒绝入场。

**实现复杂度**: ⭐ 低（逻辑修改，约 10 行代码）

**测试验证**:
- [ ] 单元测试：VWAP 不可用时，0DTE 信号应返回 `NO_SIGNAL`
- [ ] 集成测试：模拟 VWAP 获取失败，验证 0DTE 入场被拒绝
- [ ] 日志验证：确认 `rejectionReason: 'VWAP_UNAVAILABLE_0DTE_BLOCKED'` 正确记录

---

#### Fix 2: 修复 VWAP 数据获取的 napi 错误
**问题**: `Failed to convert napi value into enum TradeSessions` 导致 VWAP 全天不可用。

**修复方案**:
```typescript
// 文件: api/src/services/market-data.service.ts
// 位置: ~line 1126-1134

// 修改前:
const TradeSessions = (longport as any).TradeSessions;
const candles = await quoteCtx.candlesticks(
  symbol,
  Period.Min_1,
  240,
  AdjustType.NoAdjust,
  TradeSessions?.All || 100 // 问题：TradeSessions 可能未正确导入
);

// 修改后（方案A - 显式枚举值）:
// 根据 LongPort SDK 文档，TradeSessions.All 的值为 100
const candles = await quoteCtx.candlesticks(
  symbol,
  Period.Min_1,
  240,
  AdjustType.NoAdjust,
  100 // 直接使用数值，避免枚举转换问题
);

// 修改后（方案B - 安全的枚举获取）:
let tradeSessionsValue = 100; // 默认值
try {
  const TradeSessions = (longport as any).TradeSessions;
  if (TradeSessions && typeof TradeSessions.All === 'number') {
    tradeSessionsValue = TradeSessions.All;
  } else if (TradeSessions && TradeSessions.All !== undefined) {
    tradeSessionsValue = Number(TradeSessions.All) || 100;
  }
} catch (e) {
  logger.warn(`[VWAP] ${symbol} TradeSessions枚举获取失败，使用默认值100: ${e.message}`);
}
const candles = await quoteCtx.candlesticks(
  symbol,
  Period.Min_1,
  240,
  AdjustType.NoAdjust,
  tradeSessionsValue
);
```

**后备方案**: 如果 SDK 问题无法短期修复，实现基于 1 分钟 K 线的 VWAP 自行计算：
```typescript
// 使用 marketDataService.getKlines() 获取 1m K 线
// 自行计算 VWAP = Σ(TP × Volume) / Σ(Volume)
// 作为 LongPort SDK 失败时的回退路径
```

**预期效果**: 恢复 VWAP 结构确认能力，修复技术故障。

**实现复杂度**: ⭐⭐ 中（需要排查 SDK 版本和参数传递）

**测试验证**:
- [ ] 单元测试：验证 TradeSessions 枚举的正确获取方式
- [ ] 集成测试：在真实市场环境下测试 VWAP 获取成功率
- [ ] 错误处理：模拟 napi 错误，验证降级路径
- [ ] SDK 版本检查：确认当前 LongPort SDK 版本，查看是否有已知问题

**依赖项**:
- 确认 LongPort SDK 版本和 TradeSessions 枚举的正确用法
- 如 SDK 有 bug，考虑升级 SDK 或提交 issue

---

#### Fix 2.5: 修复 TSLPPCT 到期日设置错误（P0 新增）
**问题**: 2/18 Docker 日志显示 TSLPPCT 提交失败：
`TSLPPCT提交失败(openapi error: code=602001: expire date should be after today's date)`

对于 0DTE/1DTE 期权，期权到期日就是当天或次日，直接作为 TSLPPCT 的 expireDate 会被券商拒绝。**这导致 TSLPPCT 完全无法提交，券商侧保护不存在。Fix 5 调整 trailing 到 10% 的前提是 TSLPPCT 能成功提交。**

**修复方案**:
```typescript
// 文件: api/src/services/trailing-stop-protection.service.ts
// 位置: extractOptionExpireDate() 方法或 submitTSLPPCT 逻辑

// 修改前: 直接使用期权到期日作为 TSLPPCT 订单到期日
const expireDate = extractOptionExpireDate(optionSymbol); // e.g. 2026-02-18

// 修改后: 确保 TSLPPCT 到期日至少为明天
const optionExpiry = extractOptionExpireDate(optionSymbol);
const tomorrow = addBusinessDays(new Date(), 1); // 下一个交易日
const tslpExpireDate = optionExpiry > tomorrow ? optionExpiry : tomorrow;

// 如果期权今天到期 (0DTE)，TSLPPCT 到期日设为明天
// 如果期权明天到期 (1DTE)，TSLPPCT 到期日设为后天
// 确保券商不会因为 "expire date should be after today's date" 拒绝
```

**预期效果**: TSLPPCT 能正确提交，券商侧追踪止损生效。这是 Fix 5 (trailing 10%) 的前置依赖。

**实现复杂度**: ⭐ 低（日期计算逻辑修改）

**测试验证**:
- [ ] 单元测试：0DTE 期权的 TSLPPCT 到期日 > today
- [ ] 单元测试：1DTE 期权的 TSLPPCT 到期日 > today
- [ ] 集成测试：验证 TSLPPCT 提交不再返回 code=602001 错误

---

### P1 - 高优先级（本周完成）

#### Fix 3: 入场动量衰减检测
**问题**: 只检查绝对得分是否超过阈值，不考虑得分变化方向。得分从极值回归时仍可能触发入场。

**修复方案**:
```typescript
// 文件: api/src/services/strategies/option-intraday-strategy.ts
// 位置: 在信号生成逻辑中，得分检查之后

// 新增：动量衰减检测
const previousScore = this.getPreviousScore(symbol); // 需要维护历史得分
const scoreTrend = finalScore - previousScore; // 正值 = 向中性回归

// 检测得分向中性方向回归（无论多空方向）
const isDecaying = Math.abs(finalScore) < Math.abs(previousScore);
if (is0DTEEntry && isDecaying && Math.abs(finalScore) >= Math.abs(previousScore) * 0.8) {
  // 得分正在从极值回归，且当前得分仍接近极值（80%以上）
  // 说明趋势可能已经见顶/见底
  logger.warn(
    `[动量衰减] ${symbol} 得分从极值回归中: ${previousScore.toFixed(1)} → ${finalScore.toFixed(1)} ` +
    `(|${Math.abs(finalScore).toFixed(1)}| < |${Math.abs(previousScore).toFixed(1)}|)，暂缓0DTE入场`
  );
  logData.finalResult = 'NO_SIGNAL';
  logData.rejectionReason = `动量衰减：得分回归${scoreTrend.toFixed(1)}`;
  logData.rejectionCheckpoint = 'momentum_decay';
  this.logDecision(logData);
  return null;
}

// 更新历史得分
this.setPreviousScore(symbol, finalScore);
```

**数据结构**:
```typescript
// 在 OptionIntradayStrategy 类中新增
private scoreHistory: Map<string, { score: number; timestamp: number }> = new Map();

private getPreviousScore(symbol: string): number {
  const history = this.scoreHistory.get(symbol);
  if (!history || Date.now() - history.timestamp > 60_000) {
    // 超过 60 秒的历史数据视为无效
    return 0;
  }
  return history.score;
}

private setPreviousScore(symbol: string, score: number): void {
  this.scoreHistory.set(symbol, { score, timestamp: Date.now() });
}
```

**预期效果**: 过滤趋势末端的滞后信号，避免在得分从极值回归时入场。

**实现复杂度**: ⭐ 低（增加判断逻辑和历史得分维护）

**测试验证**:
- [ ] 单元测试：验证得分从 -17.6 回归至 -15.7 时被拒绝
- [ ] 边界测试：得分持续恶化（-15 → -17）应允许入场
- [ ] 时间窗口：超过 60 秒的历史得分应视为无效

---

#### Fix 4: 0DTE 禁入窗口必要性评估与调整
**问题**: 复盘显示禁入窗口在本次交易中反而延迟了入场（14:58:55 被阻止，15:00:42 才入场），导致追高。但复盘也提到"在绝大多数交易日, 开盘 30 分钟的信号确实包含大量噪声"。

**关键问题**: **开盘前30分钟的保护是否有绝对的必要性？**

**分析**:
- **支持保留的理由**: 开盘30分钟噪声大，禁入窗口能过滤假信号
- **反对保留的理由**: 
  - 0DTE 总共只有 6.5 小时，禁入 30 分钟 = 损失 7.7% 的交易窗口
  - 本次交易中，禁入窗口阻止了最佳入场时机（14:58:55 @ $2.00），等待到窗口结束后入场反而追高（15:00:42 @ $2.09）
  - 复盘 Section 14.1 指出：期权交易需要"快进快出抓时间窗口"，"等一等更安全"的股票逻辑不适合期权

**修复方案（分阶段实施）**:

**阶段1 - 缩短窗口（立即实施）**:
```typescript
// 数据库配置修改（代码默认值为 0，当前通过 DB 配置 zdteCooldownMinutes 设置为 30）
// 修改 DB 配置: zdteCooldownMinutes 从 30 改为 15
// 禁入窗口: 09:30-09:45 ET（而非 09:30-10:00）

// 新增：极端信号绕过冷却窗口
// 文件: api/src/services/strategies/option-intraday-strategy.ts
// 位置: ~line 560-567
const zdteCooldownMinutes = this.cfg.tradeWindow?.zdteCooldownMinutes ?? 0;
const isInZdteCooldown = minutesSinceOpen >= 0 && minutesSinceOpen < zdteCooldownMinutes;

// 修改后: 极端信号豁免冷却
let skip0DTE = false;
if (isInZdteCooldown) {
  // 冷却窗口内：检查是否有极端信号可豁免
  const absScore = Math.abs(optionRec.finalScore);
  if (absScore >= 15) { // EXTREME_THRESHOLD
    logger.info(
      `[0DTE冷却] ${symbol} 冷却窗口内但得分${optionRec.finalScore.toFixed(1)}达极端值，` +
      `豁免冷却，允许0DTE入场`
    );
    skip0DTE = false; // 不跳过 0DTE
  } else {
    skip0DTE = true; // 非极端信号，降级为 1DTE/2DTE
  }
}
```

**阶段2 - 数据验证（1周后评估）**:
- [ ] 统计缩短窗口后的入场时机分布
- [ ] 对比缩短前后：入场价格质量、胜率、平均盈亏
- [ ] 分析：是否有更多"追高"案例，还是更多"错过机会"案例

**阶段3 - 决策（基于数据）**:
- **如果数据支持**: 进一步缩短至 10 分钟或完全取消
- **如果数据不支持**: 恢复至 30 分钟，但增加冷却缓冲（见下方）

**备选方案 - 冷却缓冲（如果保留窗口）**:
```typescript
// 窗口结束后增加 3 分钟冷却期，要求重新积累连续确认
const ZDTE_COOLDOWN_AFTER_WINDOW_MINUTES = 3;
const windowEndTime = '10:00'; // 或 '09:45'（如果缩短窗口）
const cooldownEndTime = addMinutes(windowEndTime, ZDTE_COOLDOWN_AFTER_WINDOW_MINUTES);

if (isInCooldownPeriod(etTime, windowEndTime, cooldownEndTime)) {
  consecutiveConfirmCount = 0; // 重置，要求重新确认
  skip0DTE = true;
}
```

**预期效果**: 
- 缩短窗口：减少交易窗口损失，允许更早入场
- 冷却缓冲：消除边界效应，避免"一开闸就冲进去"

**实现复杂度**: ⭐ 低（配置修改 + 可选的时间判断逻辑）

**测试验证**:
- [ ] 配置测试：验证 `ZDTE_COOLDOWN_MINUTES` 可配置
- [ ] 时间窗口测试：验证 09:30-09:45 ET 期间 0DTE 被阻止
- [ ] 数据收集：记录缩短窗口后的入场时机和价格质量
- [ ] 极端信号绕过测试：冷却窗口内 |score|>=15 时允许 0DTE
- [ ] 非极端信号保留测试：冷却窗口内 |score|<15 时降级 1DTE

---

#### Fix 5: TSLPPCT 0DTE 默认 trailing 下调至 10%
**问题**: 当前 0DTE 默认 trailing=15%，在复盘模拟中产生 -8.3% 亏损。trailing=10% 可实现近乎保本。

**修复方案**:
```typescript
// 文件: api/src/services/trailing-stop-protection.service.ts
// 位置: getTrailingPercentForPhase() 方法

// 修改前:
if (is0DTE) {
  // 0DTE 强制覆盖为 15%
  return Math.min(current, 15);
}

// 修改后:
if (is0DTE) {
  // 0DTE 强制覆盖为 10%（基于复盘分析优化）
  return Math.min(current, 10);
}
```

**预期效果**: 根据复盘 Section 10.7.1 敏感性分析，trailing=10% 在本次交易中可实现 -0.8%（近乎保本），相比 15% 的 -8.3% 改善显著。

**实现复杂度**: ⭐ 极低（单行配置修改）

**测试验证**:
- [ ] 单元测试：验证 0DTE 时 trailing 强制为 10%
- [ ] 回测验证：使用历史数据验证 trailing=10% vs 15% 的效果
- [ ] 配置验证：确认配置可通过环境变量或配置文件覆盖

**风险评估**: 
- ⚠️ trailing=10% 可能过于敏感，正常波动可能提前触发
- ✅ 但复盘显示 10% 在本次场景中效果最佳
- 💡 建议：先实施，通过实盘数据验证后再调整

---

### P2 - 中优先级（下周完成）

#### Fix 6: 0DTE 入场市价单 + 动态调整盈亏比例
**问题**:
- **方案A（强制限价单）**: 可能错过市场，限价单不成交导致错过入场机会
- **方案B（市价单+动态调整）**: 允许市价单成交，但根据实际成交价与信号价的偏差动态调整止损/止盈比例

**决策**: **采用方案B（市价单+动态调整）**，理由：
1. 0DTE 期权时间窗口极短，错过入场机会的成本 > 追价成交的成本
2. 如果市价单成交价高于预期，说明市场波动大，应该收紧止损/止盈以控制风险
3. 复盘显示：本次交易中市价单成交价 $2.09 反而优于报价 $2.15（有利滑点），说明市价单不一定是坏事

**现状**: `basic-execution.service.ts` 中所有期权订单已默认使用市价单（line 737-752），无需修改订单类型逻辑。本 Fix 重点在于**订单成交后的动态调整**：根据实际成交价与信号价的偏差，动态收紧 trailing 和止损参数。

**动态调整逻辑（订单成交后）**:
```typescript
// 文件: api/src/services/strategy-scheduler.service.ts
// 位置: 订单成交后的 TSLPPCT 提交逻辑

// 在提交 TSLPPCT 时，根据实际成交价与信号价的偏差调整 trailing
const actualPriceDeviation = Math.abs((filledPrice - signalPrice) / signalPrice);

if (is0DTE && actualPriceDeviation > 0.02) { // 价差 > 2%
  // 价差越大，说明市场波动越大，收紧 trailing
  // 基础 trailing = 10%，价差每增加 1%，trailing 收紧 0.5%
  const trailingAdjustment = Math.min(actualPriceDeviation * 50, 5); // 最多收紧 5%
  const adjustedTrailing = Math.max(10 - trailingAdjustment, 8); // 最低 8%
  
  logger.info(
    `[动态调整] ${symbol} 0DTE入场价差${(actualPriceDeviation * 100).toFixed(2)}%，` +
    `TSLPPCT trailing从10%调整为${adjustedTrailing.toFixed(1)}%`
  );
  
  trailingPercent = adjustedTrailing;
}

// 同时调整系统侧止损阈值
if (is0DTE && actualPriceDeviation > 0.02) {
  // 价差大时，收紧止损阈值（从 -25% 收紧至 -20% 或更紧）
  const stopLossAdjustment = Math.min(actualPriceDeviation * 100, 5); // 最多收紧 5%
  const adjustedStopLoss = Math.max(25 - stopLossAdjustment, 20); // 最低 -20%
  
  // 更新 context 中的止损阈值
  context.adjustedStopLossPercent = adjustedStopLoss;
}
```

**预期效果**: 
- ✅ 不错过市场：允许市价单成交，抓住入场机会
- ✅ 风险控制：根据实际成交价动态收紧止损/止盈，价差越大越保守
- ✅ 自适应：系统根据市场波动自动调整风险参数

**实现复杂度**: ⭐⭐ 中（需要修改订单类型逻辑 + 动态调整逻辑）

**测试验证**:
- [ ] 单元测试：验证价差计算和动态调整逻辑
- [ ] 集成测试：模拟不同价差场景，验证 trailing 和止损的调整
- [ ] 回测验证：使用历史数据验证动态调整的效果
- [ ] 对比测试：对比强制限价单 vs 市价单+动态调整的长期效果

**风险评估**:
- ⚠️ 市价单可能在极端波动中成交在不利价位
- ✅ 但动态调整机制会根据价差收紧止损，限制最大亏损
- 💡 建议：先实施，通过实盘数据验证动态调整的效果

---

#### Fix 7: 入场价格相对于近期 K 线位置检测
**问题**: 不检查入场价格在近期 K 线中的位置，可能买在蜡烛上半部分（追高）。

**修复方案**:
```typescript
// 文件: api/src/services/strategies/option-intraday-strategy.ts
// 位置: 合约选择之后，订单提交之前

// 新增：期权价格位置检测
async checkOptionPricePosition(
  optionSymbol: string,
  entryPrice: number,
  direction: 'PUT' | 'CALL'
): Promise<{ allowed: boolean; reason?: string }> {
  try {
    // 获取期权最近 3 根 5 分钟 K 线
    const klines = await marketDataService.getOptionKlines(optionSymbol, '5m', 3);
    if (!klines || klines.length < 2) {
      return { allowed: true }; // 数据不足，放行
    }

    const recentHigh = Math.max(...klines.map(k => k.high));
    const recentLow = Math.min(...klines.map(k => k.low));
    const priceRange = recentHigh - recentLow;
    
    if (priceRange <= 0) {
      return { allowed: true }; // 无波动，放行
    }

    const pricePosition = (entryPrice - recentLow) / priceRange;

    if (direction === 'PUT') {
      // PUT 入场：价格位于近期高点 70% 以上视为追高
      if (pricePosition > 0.7 && is0DTEEntry) {
        logger.warn(
          `[价格位置] ${optionSymbol} PUT入场价${entryPrice.toFixed(2)}位于近期高点` +
          `${recentHigh.toFixed(2)}的${(pricePosition * 100).toFixed(1)}%分位，追高风险`
        );
        return {
          allowed: false,
          reason: `OPTION_PRICE_NEAR_HIGH: ${(pricePosition * 100).toFixed(1)}%`
        };
      }
    } else {
      // CALL 入场：价格位于近期高点 70% 以上同样视为追高
      if (pricePosition > 0.7 && is0DTEEntry) {
        logger.warn(
          `[价格位置] ${optionSymbol} CALL入场价${entryPrice.toFixed(2)}位于近期高点` +
          `${recentHigh.toFixed(2)}的${(pricePosition * 100).toFixed(1)}%分位，追高风险`
        );
        return {
          allowed: false,
          reason: `OPTION_PRICE_NEAR_HIGH: ${(pricePosition * 100).toFixed(1)}%`
        };
      }
    }

    return { allowed: true };
  } catch (error: any) {
    logger.warn(`[价格位置] ${optionSymbol} 检测失败: ${error.message}，放行`);
    return { allowed: true }; // 检测失败时保守放行
  }
}
```

**依赖项**: 需要实现 `marketDataService.getOptionKlines()` 方法（获取期权 K 线数据）

**预期效果**: 识别追高入场，过滤"买在蜡烛上半部分"的高风险入场。

**实现复杂度**: ⭐⭐ 中（需要获取期权 K 线数据，可能需要新增 API 调用）

**测试验证**:
- [ ] 单元测试：验证价格位置计算逻辑
- [ ] 集成测试：使用真实期权 K 线数据验证检测准确性
- [ ] 边界测试：价格位于 69% vs 71% 分位的差异

---

### P3 - 策略系统性修订（立即开始，2周内完成核心修订）

#### Fix 8: 策略核心逻辑修订（非评估，直接修订）
**问题**: 复盘 Section 14 明确证明当前策略有**系统性缺陷**，不是随机问题：
- 2/17 SPY: 底部 V 型反转时买入 PUT → -31.4%
- 2/18 TSLA: 顶部开始下跌时买入 CALL → -63.1%
- **每次都在趋势即将反转的极端点产生最强信号**

**核心矛盾**: 
- 当前策略：趋势追踪 + 多层确认 = 在趋势末端入场
- 期权买方：需要在趋势早期或反转初期入场

**修订方案（分阶段实施）**:

**阶段1 - 移除所有延迟类过滤（立即实施，一次性移除）**:
```typescript
// 文件: api/src/services/strategies/option-intraday-strategy.ts
// 产品经理确认：直接移除，不分阶段

// 修订1: 完全移除 RSI 超买/超卖过滤
// 理由: RSI 超买时 PUT 正是最佳入场点，超卖时 CALL 正是最佳入场点
// 修改: 移除 RSI 过滤逻辑

// 修订2: 完全移除价格确认等待（移动 > 0.03%）
// 理由: 期权价格变化剧烈，等待确认 = 追高入场
// 修改: 直接移除价格确认等待逻辑，信号生成即入场

// 修订3: 完全移除连续确认机制
// 理由: 期权需要抓住第一波动，等确认时行情可能已结束
// 修改: 移除 consecutiveConfirmCycles 逻辑
```

**注意**: 这是已确认的风险决策。移除过滤层会增加假信号，但动态风控（trailing 10% + 动态调整）是主要风险控制手段。

**阶段2 - 反向指标策略（核心修订，直接实施）**:
```typescript
// 修订4: 利用评分系统在趋势末端产生极端信号的特性，做反向交易
// 逻辑修改:
// 当前: finalScore ≤ -12 → 买 PUT（追趋势）
// 修订: finalScore ≤ -15（极端值）→ 买 CALL（赌反弹）
//        finalScore ≥ +15（极端值）→ 买 PUT（赌回调）

// 实现:
const EXTREME_THRESHOLD = 15; // 极端值阈值

if (Math.abs(finalScore) >= EXTREME_THRESHOLD) {
  // 极端值：反向交易
  const reverseDirection = finalScore <= -EXTREME_THRESHOLD ? 'CALL' : 'PUT';
  logger.info(
    `[反向策略] ${symbol} 得分${finalScore.toFixed(1)}达到极端值，` +
    `采用反向交易：${reverseDirection}（而非${direction}）`
  );
  direction = reverseDirection;
} else {
  // 非极端值：保持原有趋势追踪逻辑
  direction = finalScore >= 12 ? 'CALL' : 'PUT';
}

// Kill Switch: 连续亏损超阈值时自动回退到原有逻辑
const KILL_SWITCH_THRESHOLD = 3; // 连续亏损笔数
const KILL_SWITCH_LOSS_PERCENT = -20; // 单笔亏损阈值

if (consecutiveReverseLosses >= KILL_SWITCH_THRESHOLD
    && avgReverseLossPercent <= KILL_SWITCH_LOSS_PERCENT) {
  logger.warn(
    `[Kill Switch] 反向策略连续${consecutiveReverseLosses}笔亏损，` +
    `平均亏损${avgReverseLossPercent.toFixed(1)}%，自动回退到原有逻辑`
  );
  useReverseStrategy = false; // 回退到原有趋势追踪逻辑
}

// 修订4.5: 反向策略前端配置验证
// 问题: 反向策略将方向从 PUT 反转为 CALL（或反之），但用户可能未在前端启用对应策略类型
// 例如: 用户只启用了「单边买Put」，极端信号反转后想买 CALL，但 DIRECTIONAL_CALL 未启用
// 方案: 反向策略触发前检查目标策略类型是否在配置中启用
const reverseTargetType = reverseDirection === 'CALL' ? 'DIRECTIONAL_CALL' : 'DIRECTIONAL_PUT';
const enabledBuyerStrategies = this.cfg.strategyTypes?.buyer ?? [];
if (!enabledBuyerStrategies.includes(reverseTargetType)) {
  logger.warn(
    `[反向策略] ${symbol} 反向目标${reverseTargetType}未在前端配置中启用，跳过反向策略`
  );
  // 保持原方向，不执行反向
} else {
  direction = reverseDirection;
}

// 修订5: 反向策略跳过 VWAP 结构确认
// 问题: 反向策略入场方向与 VWAP 结构天然矛盾
//   - 极端看空时(score <= -15)，价格在 VWAP 下方 → 反向买 CALL → VWAP 要求收盘 > VWAP → 被拦截
//   - 极端看多时(score >= +15)，价格在 VWAP 上方 → 反向买 PUT → VWAP 要求收盘 < VWAP → 被拦截
// 方案: 当 |score| >= EXTREME_THRESHOLD（反向策略触发）时，跳过 VWAP 结构确认
// 非极端信号(|score| < 15)仍保留 VWAP 结构确认作为安全网
const skipVwapForReverse = Math.abs(finalScore) >= EXTREME_THRESHOLD && !this.reverseStrategyKillSwitch.disabled;
// skipVwapForReverse 会在后续 VWAP 结构确认处使用
```

**风险说明**: 产品经理确认接受反向策略的亏损风险。历史数据不足无法回测，但继续使用当前策略只会每日亏损。Kill switch 作为安全网，连续3笔亏损超过-20%时自动暂停反向策略并回退到原有逻辑。

**阶段3 - 波动率交易（可选，Week 4+）**:
```typescript
// 修订5: 当评分极端但方向不确定时，转为波动率交易
// 如果 finalScore 绝对值很大但方向信号不明确，买入跨式组合
if (Math.abs(finalScore) >= 20 && Math.abs(finalScore - previousScore) < 2) {
  // 评分极端但变化不大，可能进入震荡，买入跨式
  strategyType = 'STRADDLE';
}
```

**预期效果**:
- ✅ 精简过滤层：减少延迟，更快入场
- ✅ 反向策略：直接解决"买在顶/底"的问题，2/17 和 2/18 的案例中都能盈利
- ✅ 波动率交易：在方向不确定时仍能获利

**实现复杂度**: ⭐⭐⭐ 高（核心策略逻辑修改）

**测试验证**:
- [ ] 回测验证：使用 2/17 和 2/18 数据验证反向策略效果
- [ ] Kill switch 测试：验证连续亏损超阈值时自动回退
- [ ] VWAP 跳过测试：验证极端得分时 VWAP 结构确认被跳过
- [ ] VWAP 保留测试：验证非极端得分时 VWAP 结构确认仍生效
- [ ] 实盘验证：直接部署，通过 kill switch + 动态风控控制风险

**风险评估**:
- ⚠️ 反向策略需要严格的止损，因为趋势也可能继续（极端值之后可能更极端）
- ⚠️ 移除过滤层会增加假信号，动态风控是主要风险控制手段
- ✅ 已确认的风险决策：继续使用当前策略只会每日亏损，接受反向策略的风险
- ✅ Kill switch 作为安全网，连续3笔亏损超-20%时自动回退

**各策略类型影响矩阵**:

| 修复项 | DIRECTIONAL_CALL | DIRECTIONAL_PUT | STRADDLE_BUY | BULL_SPREAD | BEAR_SPREAD |
|--------|:---:|:---:|:---:|:---:|:---:|
| Fix 8a (移除过滤) | ✅ 影响 | ✅ 影响 | ✅ 影响 | ✅ 影响 | ✅ 影响 |
| Fix 8b (反向策略) | ✅ 影响 | ✅ 影响 | ❌ 不适用 | ❌ 不适用 | ❌ 不适用 |
| Fix 8c (VWAP跳过) | ✅ 影响 | ✅ 影响 | ❌ 无方向限制 | ✅ 影响 | ✅ 影响 |
| Fix 4 (冷却窗口) | ✅ 影响 | ✅ 影响 | ✅ 影响 | ✅ 影响 | ✅ 影响 |
| Fix 11 (动态冷却) | ✅ 影响 | ✅ 影响 | ✅ 影响 | ✅ 影响 | ✅ 影响 |

说明:
- **STRADDLE_BUY**: 基于 VIX 触发，不受方向/VWAP/反向策略影响
- **BULL_SPREAD / BEAR_SPREAD**: 与 DIRECTIONAL 共享方向逻辑，但反向策略不适用（价差策略用于方向确认，不适合逆向操作）
- **反向策略(Fix 8b)**: 仅反转 DIRECTIONAL_CALL ↔ DIRECTIONAL_PUT，触发前验证目标类型在前端配置中已启用

**时间表**:
- **Week 2**: 完成阶段1（移除所有过滤层，立即实施）+ 完成阶段2（反向指标策略）
- **Week 3+**: 实盘观察 + 参数动态调整

---

### P1 - 补充修复项

#### Fix 9: 日志 NaN 显示修复
**问题**: 2/18 TSLA 止损日志显示 `净盈亏=$NaN, 手续费=$NaN, 保本价=$NaN`。止损决策已正确使用 `grossPnLPercent`，但日志格式化路径仍使用 `netPnLPercent`，影响监控和复盘。

**修复方案**: 排查持仓监控日志的 PnL 格式化路径，统一切换到 `grossPnLPercent`。

**实现复杂度**: ⭐ 低

#### Fix 10: 资金差异修复
**问题**: 2/18 日志显示资金差异从 8.51% 扩大到 27.15%（策略记录值 $546.97 vs 实际 $3.90），可能影响后续交易的资金验证。

**修复方案**: 排查资金同步逻辑，确认释放和扣除路径一致。重点排查订单成交后的资金释放是否与策略记录同步。

**实现复杂度**: ⭐⭐ 中

---

#### Fix 11: 退出后冷却期动态调整
**问题**: 当前退出后固定 3 分钟冷却期（LATE 时段），对于 0DTE 期权交易窗口短（6.5 小时），固定冷却期不合理。每天只交易一只股票的问题部分由此导致。

**修复方案**:
```typescript
// 文件: api/src/services/strategy-scheduler.service.ts
// 位置: LATE 时段冷却期逻辑（~line 1333-1341）

// 修改前: 固定 3 分钟冷却
const cooldownMinutes = strategyConfig?.latePeriod?.cooldownMinutes ?? 3;

// 修改后: 根据当日已交易次数动态调整冷却期
const dailyTradeCount = cancelCtx?.dailyTradeCount ?? 0;
let cooldownMinutes: number;
if (is0DTE) {
  // 0DTE 动态冷却：前几笔无冷却，后续递增
  if (dailyTradeCount <= 1) {
    cooldownMinutes = 0; // 前 1-2 笔：无冷却，快速入场
  } else if (dailyTradeCount <= 3) {
    cooldownMinutes = 1; // 第 3-4 笔：1 分钟冷却
  } else {
    cooldownMinutes = 3; // 第 5 笔起：3 分钟冷却（防止过度交易）
  }
} else {
  cooldownMinutes = strategyConfig?.latePeriod?.cooldownMinutes ?? 3; // 非 0DTE 保持默认
}
```

**预期效果**:
- 0DTE 前几笔交易快速进出，最大化时间窗口利用率
- 交易次数增多后自动收紧冷却，防止过度交易
- 非 0DTE 不受影响

**实现复杂度**: ⭐⭐ 中（需要维护 dailyTradeCount 计数器）

**测试验证**:
- [ ] 0DTE 第 1 笔退出后无冷却期
- [ ] 0DTE 第 3 笔退出后 1 分钟冷却
- [ ] 0DTE 第 5 笔退出后 3 分钟冷却
- [ ] 非 0DTE 固定 3 分钟冷却不受影响

---

## 📅 实施时间表

### Week 1 (2026-02-19 ~ 2026-02-24)
- [x] **Day 1-2**: Fix 1 (VWAP 降级策略) - 开发 + 测试
- [ ] **Day 2-3**: Fix 2 (VWAP napi 错误) - 排查 + 修复
- [ ] **Day 3-4**: Fix 2.5 (TSLPPCT 到期日 bug) - 开发 + 测试（Fix 5 前置依赖）
- [ ] **Day 4-5**: Fix 5 (TSLPPCT trailing 10%) - 配置修改 + 验证

### Week 2 (2026-02-25 ~ 2026-03-03)
- [ ] **Day 1**: Fix 3 (动量衰减检测) - 开发 + 测试
- [ ] **Day 2**: Fix 4 (禁入窗口缩短至15分钟) - DB 配置修改 + 数据收集
- [ ] **Day 2-3**: Fix 8 阶段1 (移除所有过滤层) - 一次性移除 RSI/价格确认/连续确认
- [ ] **Day 3-4**: Fix 8 阶段2 (反向指标策略 + kill switch) - 核心逻辑开发
- [ ] **Day 4-5**: Fix 9 (NaN 日志修复) + Fix 11 (动态冷却期) - 排查 + 开发

### Week 3 (2026-03-04 ~ 2026-03-10)
- [ ] **Day 1-2**: Fix 6 (动态调整盈亏比例) - 成交后动态调整逻辑开发 + 测试
- [ ] **Day 3**: Fix 7 (价格位置检测) - 开发 + 测试（需先实现期权 K 线获取）
- [ ] **Day 4**: Fix 10 (资金差异修复) - 排查资金同步逻辑
- [ ] **Day 5**: 所有修复项集成测试

### Week 4+ (2026-03-11 ~)
- [ ] **持续**: 实盘观察 + 参数动态调整（反向策略阈值、trailing 参数、kill switch 阈值等）
- [ ] **持续**: 监控 kill switch 触发情况，评估反向策略效果
- [ ] **持续**: 根据 Fix 4 数据评估是否进一步缩短或取消禁入窗口

---

## 🧪 测试验证方案

### 单元测试
- [ ] Fix 1: VWAP 不可用时 0DTE 拒绝逻辑
- [ ] Fix 2: TradeSessions 枚举获取和错误处理
- [ ] Fix 2.5: TSLPPCT 到期日计算（0DTE/1DTE 场景）
- [ ] Fix 3: 动量衰减检测逻辑（得分回归场景，多空双向）
- [ ] Fix 4: 禁入窗口 DB 配置读取和时间判断
- [ ] Fix 5: TSLPPCT trailing 10% 配置验证
- [ ] Fix 6: 成交后动态调整 trailing 和止损逻辑
- [ ] Fix 7: 期权价格位置计算（PUT/CALL 双向）
- [ ] Fix 8: Kill switch 连续亏损回退逻辑
- [ ] Fix 8c: 极端得分时 VWAP 结构确认跳过逻辑
- [ ] Fix 11: 0DTE 动态冷却期计算（交易次数递增）

### 集成测试
- [ ] 模拟 2026-02-17 市场环境，验证修复后行为
- [ ] VWAP 获取失败场景的完整流程测试
- [ ] 禁入窗口边界场景测试
- [ ] TSLPPCT 提交和触发流程测试

### 回测验证
- [ ] 使用历史数据回测 5-Fix 组合效果
- [ ] 对比修复前后的盈亏分布
- [ ] 验证 TSLPPCT trailing=10% vs 15% 的长期效果

### 实盘验证
- [ ] 直接部署所有修复项，通过 kill switch + 动态风控控制风险
- [ ] 监控指标：入场拒绝率、TSLPPCT 触发率、平均持仓时长、盈亏分布
- [ ] Kill switch 监控：反向策略连续亏损触发回退的频率

---

## 📊 成功指标

### 短期指标（1 个月内）
- ✅ **VWAP 可用率**: > 95%（修复 napi 错误后）
- ✅ **0DTE 入场拒绝率**: VWAP 不可用时 100% 拒绝
- ✅ **动量衰减拦截率**: 得分回归场景下拦截率 > 80%
- ✅ **TSLPPCT 触发率**: 0DTE 持仓中 > 60% 通过 TSLPPCT 出场
- ✅ **平均亏损幅度**: 相比修复前减少 50% 以上

### 中期指标（3 个月内）
- ✅ **0DTE 交易胜率**: > 45%（当前约 30-35%）
- ✅ **平均持仓时长**: < 10 分钟（当前约 20-30 分钟）
- ✅ **最大单笔亏损**: < -20%（当前 -31.4%）
- ✅ **TSLPPCT trailing=10% 效果**: 相比 15% 改善 > 5 个百分点

---

## ⚠️ 风险评估

### 技术风险
| 风险项 | 影响 | 概率 | 缓解措施 |
|--------|------|------|---------|
| VWAP SDK 问题无法短期修复 | 高 | 中 | 实现自行计算 VWAP 的后备方案 |
| TSLPPCT trailing=10% 过于敏感 | 中 | 中 | 先灰度验证，根据数据调整 |
| 价格位置检测误杀率过高 | 中 | 低 | 设置保守阈值（70%），失败时放行 |

### 业务风险
| 风险项 | 影响 | 概率 | 缓解措施 |
|--------|------|------|---------|
| 移除过滤层后假信号增加 | 高 | 高 | 动态风控（trailing 10% + 动态调整）控制风险 |
| 反向策略连续亏损 | 高 | 中 | Kill switch: 连续3笔亏损超-20%自动回退 |
| 修复后入场机会大幅减少 | 中 | 低 | 监控入场拒绝率，如过高则调整阈值 |

---

## 📝 相关文档

- **复盘文档**: `docs/analysis/260218-SPY260217P676000-追高交易复盘.md`
- **0DTE 风控文档**: `docs/features/260216-0DTE单腿动态风控开发文档.md`
- **TSLPPCT 文档**: `docs/features/260218-期权信号系统动态化改造开发文档.md`
- **代码地图**: `CODE_MAP.md`

---

## ✅ 检查清单

### 开发阶段
- [ ] 所有 P0/P1 修复项代码完成
- [ ] 单元测试覆盖率 > 80%
- [ ] 代码审查通过
- [ ] 文档更新完成

### 测试阶段
- [ ] 集成测试全部通过
- [ ] 回测验证完成
- [ ] 性能测试通过（延迟 < 100ms）

### 部署阶段
- [ ] Kill switch 配置和测试完成
- [ ] 监控告警配置完成
- [ ] 回滚方案准备就绪（kill switch 自动回退 + 手动回退）
- [ ] 生产环境部署完成

### 验证阶段
- [ ] 实盘运行 1 周无异常
- [ ] 关键指标达到预期
- [ ] 复盘文档更新（记录修复效果）

---

**版本**: v4.0
**最后更新**: 2026-02-19
**负责人**: 待指定
**审核状态**: 待审核

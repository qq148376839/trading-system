# 期权策略决策日志数据库持久化

**版本**: 1.0
**创建日期**: 2026-02-05
**作者**: Rio Wang + Claude Code
**相关Issue**: 期权策略日志增强 - 数据库持久化

---

## 目录

- [背景](#背景)
- [问题描述](#问题描述)
- [解决方案](#解决方案)
- [技术实现](#技术实现)
- [使用方法](#使用方法)
- [数据库查询示例](#数据库查询示例)
- [部署说明](#部署说明)
- [相关文档](#相关文档)

---

## 背景

在2026-02-04实施的期权策略日志增强功能中，我们为期权策略添加了9个关键检查点的详细日志输出。这些日志帮助开发者实时了解策略的决策过程。

然而，当前实现存在以下局限：

1. **日志仅输出到控制台（console）**：无法事后分析
2. **非交易时间也输出日志**：造成信息噪音
3. **缺乏历史数据**：无法统计分析未下单的原因

## 问题描述

### 核心需求

1. **持久化决策日志**：将9个检查点的数据写入数据库，便于后续分析
2. **仅在交易时间记录**：非交易时间不写入数据库，减少数据污染
3. **支持原因统计**：可以查询和统计为什么没有产生交易信号

### 用户场景

- **场景1**：策略连续多天没有产生信号，需要分析原因
- **场景2**：想统计最近一周哪些检查点最常拒绝信号
- **场景3**：调试策略参数时，需要查看历史决策数据

## 解决方案

### 设计原则

1. **交易时间判断**：
   - 只在美股交易时间（9:30-16:00 ET）写入数据库
   - 包括盘前交易时间（4:00-9:30 ET）
   - 非交易时间只输出console日志

2. **完整记录9个检查点**：
   - 检查点1: 市场数据充足性
   - 检查点2: 信号方向判定
   - 检查点3: 风险等级评估
   - 检查点4: 0DTE期权可用性
   - 检查点5: 期权链数据
   - 检查点6+7: 流动性和Greeks筛选
   - 检查点8: 入场价格有效性
   - 检查点9: 信号生成结果

3. **结构化存储**：
   - 每次策略执行生成一条日志记录
   - 记录最终结果（成功/失败/错误）
   - 记录被拒绝的检查点和原因

## 技术实现

### 数据库表结构

新增表：`option_strategy_decision_logs`

```sql
CREATE TABLE option_strategy_decision_logs (
    id BIGSERIAL PRIMARY KEY,
    strategy_id INTEGER,
    underlying_symbol VARCHAR(20),
    execution_time TIMESTAMPTZ,

    -- 检查点1: 数据检查
    data_check_spx_count INTEGER,
    data_check_usd_count INTEGER,
    data_check_btc_count INTEGER,
    data_check_vix_available BOOLEAN,
    data_check_temperature_available BOOLEAN,
    data_check_passed BOOLEAN,

    -- 检查点2: 信号判定
    signal_direction VARCHAR(10),
    signal_confidence INTEGER,
    signal_market_score DECIMAL(10, 2),
    signal_intraday_score DECIMAL(10, 2),
    signal_final_score DECIMAL(10, 2),

    -- 检查点3: 风险评估
    risk_level VARCHAR(20),
    risk_vix_value DECIMAL(10, 2),
    risk_temperature_value DECIMAL(10, 2),
    risk_blocked BOOLEAN,

    -- 检查点4-9: 其他检查点...

    -- 最终结果
    final_result VARCHAR(20) CHECK (final_result IN ('SIGNAL_GENERATED', 'NO_SIGNAL', 'ERROR')),
    rejection_reason TEXT,
    rejection_checkpoint VARCHAR(50)
);
```

**详细字段说明**见迁移文件：`api/migrations/012_create_option_decision_logs.sql`

### 核心服务

#### 1. 决策日志服务 (`option-decision-logger.service.ts`)

```typescript
interface OptionDecisionLog {
  strategyId: number;
  underlyingSymbol: string;
  dataCheck?: { ... };
  signal?: { ... };
  risk?: { ... };
  // ... 其他检查点
  finalResult: 'SIGNAL_GENERATED' | 'NO_SIGNAL' | 'ERROR';
  rejectionReason?: string;
  rejectionCheckpoint?: string;
}

class OptionDecisionLoggerService {
  async logDecision(log: OptionDecisionLog): Promise<number | null> {
    // 1. 检查是否在交易时间
    const shouldWriteToDb = isTradingHours() || isPreMarketHours();

    if (!shouldWriteToDb) {
      console.log(`[非交易时间] 跳过数据库写入`);
      return null;
    }

    // 2. 写入数据库
    // ...
  }
}
```

**关键特性**：

- ✅ 自动判断交易时间
- ✅ 非交易时间跳过数据库写入
- ✅ 支持部分数据记录（某些检查点可能为空）
- ✅ 错误处理不影响策略执行

#### 2. 交易时间判断 (`utils/trading-hours.ts`)

```typescript
// 判断是否在交易时间（9:30-16:00 ET）
export function isTradingHours(date?: Date): boolean {
  // 自动处理夏令时/冬令时
  const { hour, minute } = getETTime(date || new Date());
  const timeInMinutes = hour * 60 + minute;
  const marketOpen = 9 * 60 + 30; // 9:30 AM
  const marketClose = 16 * 60; // 4:00 PM
  return timeInMinutes >= marketOpen && timeInMinutes < marketClose;
}

// 判断是否在盘前时间（4:00-9:30 ET）
export function isPreMarketHours(date?: Date): boolean {
  const { hour, minute } = getETTime(date || new Date());
  const timeInMinutes = hour * 60 + minute;
  const preMarketOpen = 4 * 60; // 4:00 AM
  const marketOpen = 9 * 60 + 30; // 9:30 AM
  return timeInMinutes >= preMarketOpen && timeInMinutes < marketOpen;
}
```

**使用示例**：

```typescript
// 决策日志服务中的使用
const shouldWriteToDb = isTradingHours() || isPreMarketHours();

if (!shouldWriteToDb) {
  console.log('[非交易时间] 跳过数据库写入');
  return null;
}
```

### 集成点

#### 期权日内策略 (`option-intraday-strategy.ts`)

```typescript
async generateSignal(symbol: string): Promise<TradingIntent | null> {
  // 初始化决策日志对象
  const decisionLog: OptionDecisionLog = {
    strategyId: this.strategyId,
    underlyingSymbol: symbol,
    finalResult: 'ERROR',
  };

  try {
    // 1. 获取推荐
    const optionRec = await optionRecommendationService.calculateOptionRecommendation(symbol);

    // 记录检查点1: 数据检查
    decisionLog.dataCheck = {
      spxCount: optionRec.dataCheck.spxCount,
      // ...
    };

    // 2. 检查信号方向
    if (optionRec.direction === 'HOLD') {
      decisionLog.finalResult = 'NO_SIGNAL';
      decisionLog.rejectionReason = '推荐方向为HOLD';
      decisionLog.rejectionCheckpoint = 'checkpoint_2_signal';
      await optionDecisionLoggerService.logDecision(decisionLog);
      return null;
    }

    // 3. 检查风险等级
    if (optionRec.riskLevel === 'EXTREME') {
      decisionLog.finalResult = 'NO_SIGNAL';
      decisionLog.rejectionReason = '风险等级为EXTREME';
      decisionLog.rejectionCheckpoint = 'checkpoint_3_risk';
      await optionDecisionLoggerService.logDecision(decisionLog);
      return null;
    }

    // 4-9. 其他检查点...

    // 成功生成信号
    decisionLog.finalResult = 'SIGNAL_GENERATED';
    decisionLog.signalGenerated = { success: true, signalId, ... };
    await optionDecisionLoggerService.logDecision(decisionLog);

    return intent;
  } catch (error) {
    decisionLog.finalResult = 'ERROR';
    decisionLog.rejectionReason = `策略执行异常: ${error.message}`;
    await optionDecisionLoggerService.logDecision(decisionLog);
    return null;
  }
}
```

## 使用方法

### 1. 部署数据库迁移

```bash
# 在PostgreSQL中执行迁移
psql -U trading_user -d trading_db -f api/migrations/012_create_option_decision_logs.sql
```

**或者在Docker环境中**：

```bash
# 进入容器
docker exec -it trading-postgres psql -U trading_user -d trading_db

# 执行迁移
\i /docker-entrypoint-initdb.d/012_create_option_decision_logs.sql
```

### 2. 重启服务

```bash
# 本地环境
cd api
pnpm run dev

# Docker环境
docker-compose restart app
```

### 3. 查看日志输出

**控制台输出**（所有时间都会有）：

```
📍 [QQQ.US数据检查] SPX=100, USD=100, BTC=100, VIX=✓, 温度=✓
📍 [QQQ.US信号] BUY_CALL | 得分=23.5 | 置信度=23%
📍 [风险评估] MEDIUM | 积分=1
✅ [决策日志已写入] ID=1234 | QQQ.US -> SIGNAL_GENERATED
```

**非交易时间**：

```
📍 [QQQ.US数据检查] SPX=100, USD=100, BTC=100, VIX=✓, 温度=✓
📍 [QQQ.US信号] HOLD | 得分=5.2 处于中性区间[-15, 15]
[非交易时间] 跳过数据库写入: QQQ.US -> NO_SIGNAL
```

## 数据库查询示例

### 查询1：统计最近24小时未生成信号的原因

```sql
SELECT
  rejection_checkpoint,
  rejection_reason,
  COUNT(*) as count
FROM option_strategy_decision_logs
WHERE execution_time > NOW() - INTERVAL '24 hours'
  AND final_result = 'NO_SIGNAL'
GROUP BY rejection_checkpoint, rejection_reason
ORDER BY count DESC;
```

**示例输出**：

| rejection_checkpoint | rejection_reason | count |
|---------------------|------------------|-------|
| checkpoint_2_signal | 推荐方向为HOLD，信号得分在中性区间 | 45 |
| checkpoint_3_risk | 风险等级为EXTREME | 12 |
| checkpoint_4_7_contract_selection | 未找到合适的期权合约 | 8 |
| checkpoint_8_pricing | 入场价格无效 | 3 |

### 查询2：查看特定标的的决策历史

```sql
SELECT
  execution_time,
  signal_direction,
  signal_confidence,
  risk_level,
  final_result,
  rejection_reason
FROM option_strategy_decision_logs
WHERE underlying_symbol = 'QQQ.US'
  AND execution_time > NOW() - INTERVAL '7 days'
ORDER BY execution_time DESC
LIMIT 50;
```

### 查询3：分析信号生成成功率

```sql
SELECT
  underlying_symbol,
  COUNT(*) as total_attempts,
  SUM(CASE WHEN final_result = 'SIGNAL_GENERATED' THEN 1 ELSE 0 END) as successful,
  ROUND(100.0 * SUM(CASE WHEN final_result = 'SIGNAL_GENERATED' THEN 1 ELSE 0 END) / COUNT(*), 2) as success_rate
FROM option_strategy_decision_logs
WHERE execution_time > NOW() - INTERVAL '7 days'
GROUP BY underlying_symbol
ORDER BY total_attempts DESC;
```

### 查询4：查看因风险过高被阻止的记录

```sql
SELECT
  underlying_symbol,
  execution_time,
  risk_level,
  risk_vix_value,
  risk_temperature_value,
  signal_final_score
FROM option_strategy_decision_logs
WHERE risk_blocked = true
  AND execution_time > NOW() - INTERVAL '7 days'
ORDER BY execution_time DESC;
```

### 查询5：按时间段统计决策分布

```sql
SELECT
  DATE_TRUNC('hour', execution_time) as hour,
  final_result,
  COUNT(*) as count
FROM option_strategy_decision_logs
WHERE execution_time > NOW() - INTERVAL '3 days'
GROUP BY hour, final_result
ORDER BY hour DESC, final_result;
```

## 部署说明

### 本地开发环境

1. **应用迁移**：
   ```bash
   psql -U trading_user -d trading_db -f api/migrations/012_create_option_decision_logs.sql
   ```

2. **验证表创建**：
   ```sql
   \d option_strategy_decision_logs
   \d+ option_strategy_decision_logs  -- 查看注释
   ```

3. **启动服务**：
   ```bash
   cd api
   pnpm run dev
   ```

4. **测试交易时间判断**：
   ```bash
   npx tsx test-option-decision-log.ts
   ```

### Docker生产环境

1. **确保迁移文件在镜像中**：
   ```dockerfile
   # Dockerfile中应该包含
   COPY api/migrations /app/api/migrations
   ```

2. **手动应用迁移**（如果未自动执行）：
   ```bash
   # 进入容器
   docker exec -it trading-postgres bash

   # 执行迁移
   psql -U trading_user -d trading_db -f /app/api/migrations/012_create_option_decision_logs.sql
   ```

3. **重启服务**：
   ```bash
   docker-compose restart app
   ```

4. **验证日志写入**：
   ```bash
   # 查看容器日志
   docker logs -f trading-app | grep "决策日志"

   # 查询数据库
   docker exec -it trading-postgres psql -U trading_user -d trading_db \
     -c "SELECT COUNT(*) FROM option_strategy_decision_logs;"
   ```

### 注意事项

1. **时区配置**：
   - 数据库使用UTC时区存储时间戳
   - 交易时间判断自动处理夏令时/冬令时
   - 查询时可能需要转换时区：`execution_time AT TIME ZONE 'America/New_York'`

2. **磁盘空间**：
   - 每条记录约1-2KB
   - 每天约500-1000条记录（取决于策略执行频率）
   - 建议定期清理30天以上的历史数据

3. **性能优化**：
   - 已创建索引：`strategy_id + execution_time`
   - 已创建索引：`underlying_symbol`
   - 已创建索引：`rejection_checkpoint`
   - JSONB字段使用GIN索引

4. **监控建议**：
   - 监控决策日志写入失败率
   - 监控非交易时间的跳过次数
   - 定期检查数据库表大小

## 相关文档

- [期权策略决策链路日志增强](./260204-期权策略决策链路日志增强.md) - 原始9个检查点设计
- [交易时间工具函数](../../api/src/utils/trading-hours.ts) - 交易时间判断实现
- [决策日志服务](../../api/src/services/option-decision-logger.service.ts) - 核心服务代码
- [数据库迁移文件](../../api/migrations/012_create_option_decision_logs.sql) - 完整表结构

## 版本历史

| 版本 | 日期 | 作者 | 变更说明 |
|-----|------|------|---------|
| 1.0 | 2026-02-05 | Rio Wang | 初始版本，实现决策日志数据库持久化 |

---

**文档状态**: ✅ 已完成
**最后更新**: 2026-02-05
**维护者**: Rio Wang

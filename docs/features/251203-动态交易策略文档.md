# 动态交易策略文档

**创建日期**: 2025-12-03  
**最后更新**: 2025-12-05  
**状态**: 已完成 ✅

---

## 📚 文档索引

### 文档结构

本文档整合了动态交易策略的所有相关文档，包括：
- 设计文档：核心策略框架和设计思路
- 实施总结：已完成功能和代码变更
- Bug修复说明：问题分析和修复方案（包括高买低卖、重复卖出单、资金使用差异等问题）
- 测试指南：测试方法和验证步骤

### 快速导航

**想了解设计思路？** → 查看「1. 设计文档」

**想了解实施情况？** → 查看「2. 实施总结」

**想了解Bug修复？** → 查看「3. Bug修复说明」

**想了解测试方法？** → 查看「4. 测试指南」

---

# 1. 设计文档

## 📋 文档信息

- **版本**: v1.0  
- **创建日期**: 2025-12-03  
- **状态**: 已实施 ✅

## 🔍 问题分析

### 当前问题

1. **高买低卖问题**
   - 现象：IONQ买入49.175，卖出47.11；CRSP买入52.8，卖出51.86
   - 原因：持仓时简单根据市场环境变化就卖出，没有考虑持仓成本和盈亏情况
   - 影响：造成不必要的亏损

2. **错过机会问题**
   - 现象：如果完全移除市场环境检查，可能错过最佳卖出时机
   - 原因：市场环境变化可能预示着趋势反转，但需要智能判断
   - 影响：可能错过止盈机会或增加亏损风险

### 根本原因

- **策略过于简单**：只考虑市场环境变化，没有综合考虑持仓成本、盈亏、时间等因素
- **缺乏动态调整**：止盈/止损设置后不再调整，无法适应市场变化
- **缺乏风险保护**：没有考虑持仓时间、波动性等因素

## 🎯 设计目标

### 核心目标

1. **避免高买低卖**：持仓时不应该简单地因为市场环境变化就卖出
2. **抓住机会**：在市场环境明显恶化时，应该能够及时止损或止盈
3. **动态调整**：根据市场变化动态调整止盈/止损，而不是固定不变
4. **风险控制**：综合考虑持仓成本、盈亏、时间、波动性等因素

### 设计原则

1. **成本优先**：优先考虑持仓成本，避免亏损卖出
2. **盈亏平衡**：在盈亏平衡点附近设置保护机制
3. **动态调整**：根据市场变化动态调整止盈/止损
4. **风险控制**：设置多重风险保护机制

## 🏗️ 核心策略框架

### 策略状态机

```
IDLE → OPENING → HOLDING → CLOSING → IDLE
         ↓          ↓          ↓
      (买入)    (持仓监控)  (卖出监控)
```

### 持仓监控决策树

```
持仓监控
├── 固定止盈/止损检查
│   ├── 触发止损 → 立即卖出
│   └── 触发止盈 → 立即卖出
│
├── 动态止盈/止损调整
│   ├── 市场环境变化 → 调整止盈/止损
│   ├── 持仓时间 → 调整止盈/止损
│   └── 波动性变化 → 调整止盈/止损
│
├── 市场环境响应
│   ├── 市场环境恶化 + 盈利 → 收紧止盈/止损
│   ├── 市场环境恶化 + 亏损 → 评估是否止损
│   └── 市场环境改善 + 亏损 → 放宽止损
│
└── 风险保护机制
    ├── 盈亏平衡保护
    ├── 持仓时间保护
    └── 波动性保护
```

## 📊 持仓管理策略

### 1. 持仓状态分类

根据持仓成本和当前价格，将持仓分为以下状态：

| 状态 | 条件 | 策略 |
|------|------|------|
| **深度亏损** | `currentPrice < entryPrice × 0.95` | 严格止损，不轻易卖出 |
| **轻度亏损** | `entryPrice × 0.95 ≤ currentPrice < entryPrice` | 谨慎持有，设置保护止损 |
| **盈亏平衡** | `entryPrice ≤ currentPrice < entryPrice × 1.02` | 设置盈亏平衡保护 |
| **轻度盈利** | `entryPrice × 1.02 ≤ currentPrice < takeProfit` | 正常持有，动态调整止盈 |
| **接近止盈** | `takeProfit × 0.95 ≤ currentPrice < takeProfit` | 收紧止盈，准备卖出 |
| **超过止盈** | `currentPrice ≥ takeProfit` | 立即卖出或分批卖出 |

### 2. 持仓时间分类

根据持仓时间，设置不同的策略：

| 持仓时间 | 策略调整 |
|----------|----------|
| **< 1小时** | 严格止损，避免快速亏损 |
| **1-4小时** | 正常持有，动态调整 |
| **4-24小时** | 放宽止损，给更多时间 |
| **> 24小时** | 考虑时间成本，收紧止盈 |

### 3. 盈亏情况响应

根据盈亏情况，设置不同的响应策略：

```typescript
// 盈亏百分比
const pnlPercent = ((currentPrice - entryPrice) / entryPrice) * 100;

if (pnlPercent < -5) {
  // 深度亏损：严格止损，不轻易卖出
  // 除非市场环境极度恶化，否则持有
} else if (pnlPercent < 0) {
  // 轻度亏损：谨慎持有，设置保护止损
  // 如果市场环境恶化，考虑止损
} else if (pnlPercent < 2) {
  // 盈亏平衡：设置盈亏平衡保护
  // 如果市场环境恶化，考虑止盈
} else if (pnlPercent < 5) {
  // 轻度盈利：正常持有，动态调整止盈
} else {
  // 接近或超过止盈：准备卖出
}
```

## 🔄 动态止盈止损调整

### 1. 调整触发条件

止盈/止损调整在以下情况下触发：

1. **市场环境变化**
   - 市场环境从"良好"变为"较差" → 收紧止盈/止损
   - 市场环境从"较差"变为"良好" → 放宽止损

2. **持仓时间变化**
   - 持仓时间超过阈值 → 调整止盈/止损

3. **波动性变化**
   - ATR变化超过阈值 → 调整止盈/止损

4. **价格变化**
   - 价格接近止盈/止损 → 动态调整

### 2. 调整策略

#### 市场环境恶化时的调整

```typescript
// 市场环境从"良好"变为"较差"或"中性利空"
if (previousMarketEnv === '良好' && currentMarketEnv === '较差') {
  if (pnlPercent > 0) {
    // 盈利状态：收紧止盈，保护利润
    // 将止盈调整为当前价格 + 1% 或 原止盈的 95%，取较小值
    takeProfit = Math.min(
      currentPrice * 1.01,
      originalTakeProfit * 0.95
    );
  } else if (pnlPercent > -2) {
    // 轻度亏损：收紧止损，避免进一步亏损
    // 将止损调整为当前价格 - 1% 或 原止损的 105%，取较大值
    stopLoss = Math.max(
      currentPrice * 0.99,
      originalStopLoss * 1.05
    );
  } else {
    // 深度亏损：保持原止损，不轻易调整
    // 除非市场环境极度恶化，否则持有
  }
}
```

#### 市场环境改善时的调整

```typescript
// 市场环境从"较差"变为"良好"或"中性利好"
if (previousMarketEnv === '较差' && currentMarketEnv === '良好') {
  if (pnlPercent < 0) {
    // 亏损状态：放宽止损，给更多时间
    // 将止损调整为原止损的 95%
    stopLoss = originalStopLoss * 0.95;
  } else {
    // 盈利状态：放宽止盈，追求更高收益
    // 将止盈调整为原止盈的 105%
    takeProfit = originalTakeProfit * 1.05;
  }
}
```

#### 持仓时间调整

```typescript
// 持仓时间超过阈值
const holdingHours = (Date.now() - entryTime) / (1000 * 60 * 60);

if (holdingHours > 24) {
  // 持仓超过24小时：收紧止盈，考虑时间成本
  if (pnlPercent > 0) {
    // 盈利状态：收紧止盈，尽快卖出
    takeProfit = Math.min(
      currentPrice * 1.02,
      originalTakeProfit * 0.98
    );
  }
} else if (holdingHours < 1) {
  // 持仓不足1小时：严格止损，避免快速亏损
  if (pnlPercent < -2) {
    // 快速亏损：收紧止损
    stopLoss = Math.max(
      currentPrice * 0.98,
      originalStopLoss * 1.02
    );
  }
}
```

#### 波动性调整

```typescript
// ATR变化超过阈值
const atrChange = (currentATR - originalATR) / originalATR;

if (Math.abs(atrChange) > 0.2) {
  // ATR变化超过20%：调整止盈/止损
  if (atrChange > 0) {
    // 波动性增加：放宽止盈/止损
    takeProfit = originalTakeProfit * (1 + atrChange * 0.5);
    stopLoss = originalStopLoss * (1 - atrChange * 0.5);
  } else {
    // 波动性减少：收紧止盈/止损
    takeProfit = originalTakeProfit * (1 + atrChange * 0.5);
    stopLoss = originalStopLoss * (1 - atrChange * 0.5);
  }
}
```

## 🌍 市场环境响应机制

### 1. 市场环境评估

市场环境分为以下等级：

| 等级 | 条件 | 持仓策略 |
|------|------|----------|
| **良好** | 趋势一致利好 + 综合强度 > 50 | 正常持有，追求更高收益 |
| **中性利好** | 综合强度 > 10 | 正常持有，动态调整 |
| **中性** | 综合强度在 -10 到 10 之间 | 谨慎持有，设置保护 |
| **中性利空** | 综合强度 < -10 | 收紧止盈/止损 |
| **较差** | 趋势一致利空 + 综合强度 < -50 | 考虑止损或止盈 |

### 2. 市场环境响应策略

#### 市场环境恶化响应

**场景**: 市场环境从"良好"变为"较差"或"中性利空"

**策略**:
- **盈利超过3%**: 收紧止盈，保护利润；如果极度恶化，立即止盈
- **轻度盈利**: 收紧止盈，保护利润
- **轻度亏损**: 收紧止损，避免进一步亏损；如果极度恶化，考虑止损
- **深度亏损**: 保持原止损，不轻易调整；除非极度恶化，否则持有

#### 市场环境改善响应

**场景**: 市场环境从"较差"变为"良好"或"中性利好"

**策略**:
- **亏损状态**: 放宽止损，给更多时间
- **盈利状态**: 放宽止盈，追求更高收益

### 3. 市场环境变化计算

```typescript
function calculateMarketDeterioration(
  previousEnv: string,
  currentEnv: string,
  previousStrength: number,
  currentStrength: number
): number {
  // 市场环境等级映射
  const envLevels: Record<string, number> = {
    '良好': 5,
    '中性利好': 4,
    '中性': 3,
    '中性利空': 2,
    '较差': 1,
  };
  
  const previousLevel = envLevels[previousEnv] || 3;
  const currentLevel = envLevels[currentEnv] || 3;
  
  // 环境等级变化（0-4）
  const levelChange = previousLevel - currentLevel;
  
  // 强度变化（归一化到0-1）
  const strengthChange = Math.max(0, (previousStrength - currentStrength) / 100);
  
  // 综合恶化程度（0-1）
  const deterioration = Math.min(1, (levelChange / 4) * 0.6 + strengthChange * 0.4);
  
  return deterioration;
}
```

## 🛡️ 风险控制机制

### 1. 盈亏平衡保护

在盈亏平衡点附近设置保护机制：

```typescript
// 盈亏平衡保护
const breakEvenPrice = entryPrice * 1.01; // 考虑交易费用

if (currentPrice >= breakEvenPrice && currentPrice < breakEvenPrice * 1.02) {
  // 在盈亏平衡点附近：设置保护止损
  // 止损不低于盈亏平衡点
  stopLoss = Math.max(stopLoss, breakEvenPrice * 0.99);
  
  // 如果市场环境恶化，考虑止盈
  if (currentMarketEnv === '较差' || currentMarketEnv === '中性利空') {
    shouldSell = true;
    exitReason = 'BREAK_EVEN_PROTECTION';
  }
}
```

### 2. 持仓时间保护

根据持仓时间设置保护机制：

```typescript
// 持仓时间保护
const holdingHours = (Date.now() - entryTime) / (1000 * 60 * 60);

if (holdingHours > 48) {
  // 持仓超过48小时：强制评估
  if (pnlPercent > 0) {
    // 盈利状态：考虑止盈
    if (currentPrice >= takeProfit * 0.95) {
      shouldSell = true;
      exitReason = 'HOLDING_TIME_PROFIT';
    }
  } else if (pnlPercent < -3) {
    // 亏损超过3%：考虑止损
    if (currentPrice <= stopLoss * 1.05) {
      shouldSell = true;
      exitReason = 'HOLDING_TIME_LOSS';
    }
  }
}
```

### 3. 波动性保护

根据波动性设置保护机制：

```typescript
// 波动性保护
const currentATR = calculateATR(candlesticks, 14);
const atrPercent = currentATR / currentPrice;

if (atrPercent > 0.05) {
  // 波动性超过5%：收紧止盈/止损
  if (pnlPercent > 0) {
    // 盈利状态：收紧止盈，保护利润
    takeProfit = Math.min(
      currentPrice * 1.03,
      originalTakeProfit * 0.97
    );
  } else {
    // 亏损状态：收紧止损，避免进一步亏损
    stopLoss = Math.max(
      currentPrice * 0.97,
      originalStopLoss * 1.03
    );
  }
}
```

## 💻 数据结构设计

```typescript
interface PositionContext {
  // 基础信息
  entryPrice: number;
  quantity: number;
  entryTime: string;
  
  // 止盈止损
  originalStopLoss: number;
  originalTakeProfit: number;
  currentStopLoss: number;
  currentTakeProfit: number;
  
  // 市场环境
  entryMarketEnv?: string;
  entryMarketStrength?: number;
  previousMarketEnv?: string;
  previousMarketStrength?: number;
  
  // 波动性
  originalATR?: number;
  currentATR?: number;
  
  // 调整历史
  adjustmentHistory?: Array<{
    timestamp: string;
    reason: string;
    stopLoss: number;
    takeProfit: number;
  }>;
}
```

---

# 2. 实施总结

## 📋 实施概述

**实施日期**: 2025-12-03  
**状态**: 已完成 ✅

本次实施完成了动态交易策略的核心功能，包括动态持仓管理、市场环境响应、风险保护等机制，解决了高买低卖和错过机会的问题。

## ✅ 已完成功能

### 1. 动态持仓管理服务

**文件**: `api/src/services/dynamic-position-manager.service.ts`

**功能**:
- ✅ 持仓上下文管理（PositionContext）
- ✅ 动态止盈/止损调整
- ✅ 市场环境响应机制
- ✅ 持仓时间调整
- ✅ 波动性调整
- ✅ 风险保护机制

**核心方法**:
- `getPositionContext()` - 获取持仓上下文
- `getCurrentMarketEnvironment()` - 获取当前市场环境
- `calculateMarketDeterioration()` - 计算市场环境恶化程度
- `adjustByMarketEnvironment()` - 根据市场环境调整
- `adjustByHoldingTime()` - 根据持仓时间调整
- `adjustByVolatility()` - 根据波动性调整
- `checkRiskProtection()` - 风险保护检查
- `adjustStopLossTakeProfit()` - 综合调整止盈/止损

### 2. 策略调度器集成

**文件**: `api/src/services/strategy-scheduler.service.ts`

**修改内容**:
- ✅ 集成动态持仓管理服务
- ✅ 修改 `processHoldingPosition()` 函数，集成动态调整逻辑
- ✅ 修改买入逻辑，保存完整的 PositionContext（包括市场环境、ATR等）
- ✅ 添加市场环境获取和ATR获取逻辑

**关键改进**:
1. **持仓监控流程**:
   - 获取持仓上下文
   - 获取当前市场环境
   - 检查固定止盈/止损（使用调整后的值）
   - 动态调整止盈/止损
   - 根据调整结果决定是否卖出

2. **买入时保存完整上下文**:
   - 保存入场价、数量、时间
   - 保存原始和当前止盈/止损
   - 保存市场环境（entryMarketEnv, entryMarketStrength）
   - 保存ATR（originalATR, currentATR）
   - 保存调整历史（adjustmentHistory）

## 🔄 工作流程

### 买入流程

```
1. 生成买入信号
2. 申请资金
3. 执行买入订单
4. 订单成交后：
   - 获取当前市场环境
   - 获取当前ATR
   - 保存完整的 PositionContext 到数据库
   - 更新状态为 HOLDING
```

### 持仓监控流程

```
1. 获取持仓上下文（从数据库）
2. 获取当前价格
3. 获取当前市场环境
4. 计算盈亏百分比
5. 检查固定止盈/止损（使用调整后的值）
   - 如果触发，执行卖出
6. 动态调整止盈/止损：
   - 市场环境变化调整
   - 持仓时间调整
   - 波动性调整
   - 风险保护检查
7. 如果调整建议卖出，执行卖出
8. 如果有调整，更新数据库上下文
```

## 🎯 核心策略

### 市场环境恶化响应

**场景**: 市场环境从"良好"变为"较差"或"中性利空"

**策略**:
- **盈利超过3%**: 收紧止盈，保护利润；如果极度恶化，立即止盈
- **轻度盈利**: 收紧止盈，保护利润
- **轻度亏损**: 收紧止损，避免进一步亏损；如果极度恶化，考虑止损
- **深度亏损**: 保持原止损，不轻易调整；除非极度恶化，否则持有

### 市场环境改善响应

**场景**: 市场环境从"较差"变为"良好"或"中性利好"

**策略**:
- **亏损状态**: 放宽止损，给更多时间
- **盈利状态**: 放宽止盈，追求更高收益

### 持仓时间调整

**策略**:
- **持仓超过24小时**: 收紧止盈，考虑时间成本
- **持仓不足1小时**: 严格止损，避免快速亏损
- **持仓超过48小时**: 强制评估，考虑止盈或止损

### 波动性调整

**策略**:
- **波动性超过5%**: 收紧止盈/止损
  - 盈利状态：收紧止盈，保护利润
  - 亏损状态：收紧止损，避免进一步亏损

## 📊 数据存储

### 数据库表结构

**表**: `strategy_instances`

**context 字段** (JSONB):
```json
{
  "entryPrice": 100.0,
  "quantity": 10,
  "entryTime": "2025-12-03T10:00:00Z",
  "originalStopLoss": 95.0,
  "originalTakeProfit": 110.0,
  "currentStopLoss": 95.0,
  "currentTakeProfit": 110.0,
  "entryMarketEnv": "良好",
  "entryMarketStrength": 60,
  "previousMarketEnv": "良好",
  "previousMarketStrength": 60,
  "originalATR": 2.5,
  "currentATR": 2.5,
  "adjustmentHistory": []
}
```

## 🔍 日志输出

### 持仓监控日志

```
策略 {strategyId} 标的 {symbol}: 持仓监控 - 当前价={currentPrice}, 盈亏={pnl} ({pnlPercent}%)
策略 {strategyId} 标的 {symbol}: 动态调整止盈/止损 - 止损: {oldStopLoss} -> {newStopLoss}, 止盈: {oldTakeProfit} -> {newTakeProfit}
策略 {strategyId} 标的 {symbol}: 动态调整建议卖出 - {exitReason}
```

## 📝 代码变更

### 新增文件

1. `api/src/services/dynamic-position-manager.service.ts` - 动态持仓管理服务

### 修改文件

1. `api/src/services/strategy-scheduler.service.ts` - 集成动态调整逻辑

## 🚀 后续优化建议

### 前端增强

1. **策略实例详情页面**:
   - 显示止盈/止损（原始值和当前值）
   - 显示市场环境变化历史
   - 显示调整历史
   - 显示持仓时间和盈亏情况

2. **持仓监控面板**:
   - 实时显示动态调整的止盈/止损
   - 显示市场环境变化
   - 显示调整原因

### 功能增强

1. **分批卖出**:
   - 接近止盈时，可以考虑分批卖出
   - 市场环境恶化时，可以分批止盈

2. **更智能的调整**:
   - 根据股票特性调整策略
   - 根据历史表现调整参数

3. **更多风险保护**:
   - 最大持仓时间限制
   - 最大亏损限制
   - 最大盈利回撤保护

---

# 3. Bug修复说明

## 🐛 问题分析

### 问题1: 高买低卖

**现象**:
- IONQ: 买入 49.175，卖出 47.11（亏损）
- CRSP: 买入 52.8，卖出 51.86（亏损）
- NVDA: 买入 184.63，卖出 180.14/180.2（亏损）

**根本原因**:
- 在 `processHoldingPosition` 函数中，持仓时会调用 `strategyInstance.generateSignal` 生成信号
- 如果策略生成 `SELL` 信号（用于做空），就会立即卖出持仓
- **关键问题**: 策略的 `SELL` 信号是用于做空的，不是用于平仓的！
- 当市场环境变差时，策略会生成 `SELL` 信号，导致高买低卖

### 问题2: 重复卖出单

**现象**:
- NVDA: 同时提交了两个卖出单（180.14 和 180.2）
- PLTR: 同时提交了两个卖出单（170.03 和 170.21）

**根本原因**:
- `checkPendingSellOrder` 使用60秒缓存，但订单可能在30秒内就提交了
- 存在竞态条件：两个策略周期同时执行，都检查到没有未成交订单，然后都提交卖出单
- 缓存更新不及时，导致检查时看不到刚提交的订单

## ✅ 修复方案

### 修复1: 移除持仓时的策略信号检查

**修改文件**: `api/src/services/strategy-scheduler.service.ts`

**修改内容**:
```typescript
// 修改前：会调用 generateSignal 生成卖出信号
else {
  const intent = await strategyInstance.generateSignal(symbol, undefined);
  if (intent && intent.action === 'SELL') {
    shouldSell = true;
    exitReason = 'STRATEGY_SIGNAL';
    ...
  }
}

// 修改后：只检查止盈/止损
else {
  // 没有触发卖出条件，记录监控状态
  // 注意：移除了根据策略信号卖出的逻辑，避免高买低卖
  // 持仓时应该只基于止盈/止损卖出，不应该根据市场环境变化而卖出
  logger.debug(`策略 ${strategyId} 标的 ${symbol}: 持仓监控 - 未触发卖出条件 ...`);
}
```

**修复效果**:
- 持仓时只检查止盈/止损，不会因为市场环境变化而卖出
- 避免高买低卖问题
- 策略的 `SELL` 信号仅用于做空，不用于平仓

### 修复2: 加强重复卖出单检查

**修改内容**:

1. **添加强制刷新参数**:
```typescript
// 修改前
const hasPendingSellOrder = await this.checkPendingSellOrder(strategyId, symbol);

// 修改后
const hasPendingSellOrder = await this.checkPendingSellOrder(strategyId, symbol, true);
```

2. **添加双重检查（数据库查询）**:
```typescript
// 双重检查：在更新状态前再次检查（防止竞态条件）
const dbCheckResult = await pool.query(
  `SELECT eo.order_id, eo.current_status 
   FROM execution_orders eo
   WHERE eo.strategy_id = $1 
   AND eo.symbol = $2 
   AND eo.side IN ('SELL', 'Sell', '2')
   AND eo.current_status IN ('SUBMITTED', 'NEW', 'PARTIALLY_FILLED')
   AND eo.created_at >= NOW() - INTERVAL '1 hour'
   ORDER BY eo.created_at DESC
   LIMIT 1`,
  [strategyId, symbol]
);

if (dbCheckResult.rows.length > 0) {
  logger.log(`策略 ${strategyId} 标的 ${symbol}: 数据库检查发现已有未成交卖出订单，跳过`);
  return;
}
```

3. **改进 `checkPendingSellOrder` 函数**:
```typescript
private async checkPendingSellOrder(
  _strategyId: number, 
  symbol: string, 
  forceRefresh: boolean = false  // 新增参数
): Promise<boolean> {
  // 如果强制刷新，清除缓存并重新获取订单
  const todayOrders = await this.getTodayOrders(forceRefresh);
  ...
}
```

**修复效果**:
- 强制刷新订单缓存，避免缓存延迟问题
- 双重检查机制，防止竞态条件
- 数据库查询检查，确保不会重复提交订单

## 📋 修复后的逻辑流程

### 持仓监控流程

```
1. 获取持仓上下文（入场价、止损、止盈、数量）
2. 获取当前价格
3. 检查触发条件：
   ✅ 止损触发：currentPrice <= stopLoss → 卖出
   ✅ 止盈触发：currentPrice >= takeProfit → 卖出
   ❌ 移除：策略信号检查（避免高买低卖）
4. 如果需要卖出：
   a. 检查API订单（强制刷新缓存）
   b. 检查数据库订单（双重检查）
   c. 如果都没有，才提交卖出订单
```

## 🔍 验证方法

1. **验证高买低卖修复**:
   - 观察持仓监控日志，确认不再出现 `STRATEGY_SIGNAL` 卖出
   - 确认卖出原因只有 `STOP_LOSS` 或 `TAKE_PROFIT`

2. **验证重复卖出单修复**:
   - 观察日志，确认有 `数据库检查发现已有未成交卖出订单` 的提示
   - 确认同一标的不会同时出现多个卖出订单

## 📝 注意事项

1. **策略信号用途**:
   - `BUY` 信号：用于开仓（做多）
   - `SELL` 信号：用于开仓（做空），**不是用于平仓**
   - 平仓只能通过止盈/止损触发

2. **持仓保护**:
   - 持仓时不应该根据市场环境变化而卖出
   - 只应该基于止盈/止损卖出
   - 这样可以避免高买低卖问题

3. **订单检查**:
   - 使用双重检查机制（API + 数据库）
   - 强制刷新缓存，避免缓存延迟
   - 防止竞态条件导致的重复提交

## 🎯 预期效果

1. **不再出现高买低卖**:
   - 持仓时只检查止盈/止损
   - 不会因为市场环境变化而卖出

2. **不再出现重复卖出单**:
   - 双重检查机制确保不会重复提交
   - 强制刷新缓存，避免缓存延迟

3. **更稳定的交易执行**:
   - 持仓保护机制确保交易逻辑正确
   - 订单检查机制确保不会重复提交

### 问题3: 资金使用差异

**修复时间**: 2025-12-05

**问题描述**:
- 策略资金使用记录值与实际持仓价值不一致
- 例如：策略 ark投资 (ID: 5) 资金使用差异: 记录值 25145.17, 实际值 0.00, 差异 25145.17

**根本原因**:
1. **持仓数据解析BUG**: API返回的数据结构是 `{channels: [{positions: [...]}]}`，但代码检查的是 `positions.positions`
2. **Symbol格式不匹配**: Symbol格式不匹配导致持仓无法正确匹配（如 `SHOP` vs `SHOP.US`）
3. **日志不足**: 缺乏详细的诊断日志，无法快速定位问题

## ✅ 修复方案（资金使用差异）

### 修复1: 修复持仓数据解析BUG ⚠️ **关键修复**

**问题**: API返回的数据结构是 `{channels: [{positions: [...]}]}`，但代码检查的是 `positions.positions`

**修复**:
- 支持多种数据结构：`positions.positions` 和 `positions.channels[].positions`
- 遍历所有channels，提取所有positions
- 支持多种价格字段：`currentPrice`, `costPrice`, `avgPrice`, `lastPrice`

**代码位置**: 
- `api/src/services/account-balance-sync.service.ts:189-230`
- `api/src/services/capital-manager.service.ts:574-610`

### 修复2: Symbol格式标准化

**问题**: Symbol格式不匹配导致持仓无法正确匹配

**修复**:
- 添加 `normalizeSymbol()` 方法，自动标准化symbol格式
- 在构建 `positionMap` 时，同时存储原始格式和标准化格式
- 支持 `SHOP` ↔ `SHOP.US` 格式转换

**代码位置**: `api/src/services/account-balance-sync.service.ts:28-40`

### 修复3: 增强日志输出

**修复内容**:
1. **增强持仓数据日志**:
   - 添加持仓数据获取的详细日志
   - 记录positionMap构建过程和条目数量
   - 记录Symbol格式转换过程
   - 当持仓数据为空时输出警告

2. **增强策略资金使用计算日志**:
   - 记录HOLDING状态标的数量和列表
   - 记录每个标的的匹配过程（原始symbol和标准化symbol）
   - 记录匹配成功/失败的详细信息
   - 输出实际使用值的计算过程

3. **增强差异检测日志**:
   - 记录资金使用对比的详细信息（记录值、实际值、差异、阈值）
   - 当检测到差异时，输出诊断信息（HOLDING状态标的列表、positionMap keys）
   - 便于快速定位问题根因

4. **增强资金释放日志**:
   - 记录资金释放的详细信息（策略ID、标的、释放金额）
   - 记录释放前后的 `current_usage` 值
   - 记录分配账户信息
   - 当释放失败时输出错误日志

**代码位置**:
- `api/src/services/account-balance-sync.service.ts:174-295`
- `api/src/services/capital-manager.service.ts:471-510`

## 📊 预期效果（资金使用差异修复）

### 修复前
```
[WARN] 策略 ark投资 (ID: 5) 资金使用差异: 记录值 25145.17, 实际值 0.00, 差异 25145.17
```

### 修复后（预期日志输出）
```
[DEBUG] [账户余额同步] 获取到 9 个实际持仓
[DEBUG] [账户余额同步] Symbol格式转换: SHOP -> SHOP.US, 价值=486.93
[DEBUG] [账户余额同步] positionMap构建完成，共 18 个条目
[DEBUG] [账户余额同步] positionMap keys: SHOP, SHOP.US, ROKU, ROKU.US, ...
[DEBUG] [账户余额同步] 策略 ark投资 (ID: 5) 资金使用计算开始:
[DEBUG]   - HOLDING状态标的数量: 9
[DEBUG]   - positionMap大小: 18
[DEBUG]   - HOLDING状态标的列表: SHOP.US, ROKU.US, PLTR.US, ...
[DEBUG] [账户余额同步] 策略 ark投资 标的 SHOP.US: 匹配成功，持仓价值=486.93
[DEBUG] [账户余额同步] 策略 ark投资 (ID: 5) 实际使用值: 25145.17
[DEBUG] [账户余额同步] 策略 ark投资 (ID: 5) 资金使用对比:
[DEBUG]   - 记录值: 25145.17
[DEBUG]   - 实际值: 25145.17
[DEBUG]   - 差异: 0.00
[DEBUG]   - 阈值: 251.45
```

## 🔍 问题诊断流程（资金使用差异）

修复后，当再次出现资金使用差异时，可以通过以下步骤诊断：

1. **查看持仓数据日志**
   - 检查实际持仓数量是否正确
   - 检查positionMap是否构建成功
   - 检查Symbol格式转换是否正常

2. **查看匹配过程日志**
   - 检查每个HOLDING状态标的的匹配过程
   - 确认是否尝试了原始格式和标准化格式
   - 查看匹配失败的原因

3. **查看资金释放日志**
   - 检查卖出订单成交后是否调用了 `releaseAllocation`
   - 检查资金释放前后的 `current_usage` 值
   - 确认资金释放是否成功

4. **查看差异诊断信息**
   - 对比HOLDING状态标的列表和positionMap keys
   - 找出不匹配的标的
   - 分析不匹配的原因

## 📝 后续优化建议（资金使用差异）

### 优先级1: 状态同步机制

**问题**: 策略实例状态与实际持仓可能不一致

**建议**: 
- 在账户余额同步时，检查并修复状态不一致
- 如果实际持仓不存在但状态为HOLDING，更新状态为IDLE并释放资金

### 优先级2: 资金使用自动修复

**问题**: 资金使用记录可能累积错误

**建议**:
- 定期（如每小时）自动修复资金使用记录
- 基于实际持仓重新计算并更新 `current_usage`

### 优先级3: 监控告警

**问题**: 资金差异可能长时间未被发现

**建议**:
- 当资金差异超过阈值时，发送告警通知
- 记录差异历史，便于追踪问题

---

# 4. 测试指南

## 📋 目录

- [数据库变更说明](#数据库变更说明)
- [功能测试](#功能测试)
- [集成测试](#集成测试)
- [回测功能说明](#回测功能说明)

## 🗄️ 数据库变更说明

### ✅ 不需要数据库变更

**原因**:
- `strategy_instances` 表的 `context` 字段是 **JSONB** 类型
- JSONB 可以存储任意 JSON 数据结构，无需修改表结构
- 新增的字段（`entryMarketEnv`, `entryMarketStrength`, `originalATR`, `adjustmentHistory` 等）可以直接存储在 JSONB 中

### 当前数据库结构

```sql
CREATE TABLE strategy_instances (
    id SERIAL PRIMARY KEY,
    strategy_id INTEGER REFERENCES strategies(id) ON DELETE CASCADE,
    symbol VARCHAR(20) NOT NULL,
    current_state VARCHAR(50) NOT NULL,
    context JSONB,  -- ✅ JSONB类型，支持任意JSON结构
    last_updated TIMESTAMP DEFAULT NOW(),
    UNIQUE(strategy_id, symbol)
);
```

### 数据存储示例

**旧格式**（向后兼容）:
```json
{
  "entryPrice": 100.0,
  "quantity": 10,
  "stopLoss": 95.0,
  "takeProfit": 110.0,
  "orderId": "12345"
}
```

**新格式**（包含动态调整字段）:
```json
{
  "entryPrice": 100.0,
  "quantity": 10,
  "entryTime": "2025-12-03T10:00:00Z",
  "originalStopLoss": 95.0,
  "originalTakeProfit": 110.0,
  "currentStopLoss": 95.0,
  "currentTakeProfit": 110.0,
  "entryMarketEnv": "良好",
  "entryMarketStrength": 60,
  "previousMarketEnv": "良好",
  "previousMarketStrength": 60,
  "originalATR": 2.5,
  "currentATR": 2.5,
  "adjustmentHistory": [],
  "orderId": "12345"
}
```

### 向后兼容性

代码中已经处理了向后兼容：
- `getPositionContext()` 函数会自动补充缺失字段
- 如果缺少 `originalStopLoss`，会使用 `stopLoss`
- 如果缺少 `entryTime`，会使用当前时间
- 如果缺少 `adjustmentHistory`，会初始化为空数组

## 🧪 功能测试

### 1. 单元测试

#### 测试动态持仓管理服务

**文件**: `api/src/services/dynamic-position-manager.service.ts`

**测试用例**:

```typescript
// 测试文件: api/src/__tests__/dynamic-position-manager.test.ts

describe('DynamicPositionManager', () => {
  describe('getPositionContext', () => {
    it('应该从现有上下文构建完整的PositionContext', async () => {
      const oldContext = {
        entryPrice: 100,
        quantity: 10,
        stopLoss: 95,
        takeProfit: 110,
      };
      
      const context = await dynamicPositionManager.getPositionContext(
        1, 'AAPL.US', oldContext
      );
      
      expect(context.originalStopLoss).toBe(95);
      expect(context.currentStopLoss).toBe(95);
      expect(context.entryTime).toBeDefined();
    });
  });

  describe('calculateMarketDeterioration', () => {
    it('应该正确计算市场环境恶化程度', () => {
      const deterioration = dynamicPositionManager.calculateMarketDeterioration(
        '良好', '较差', 60, 20
      );
      
      expect(deterioration).toBeGreaterThan(0);
      expect(deterioration).toBeLessThanOrEqual(1);
    });
  });

  describe('adjustByMarketEnvironment', () => {
    it('市场环境恶化时应该收紧止盈', () => {
      const context = {
        entryPrice: 100,
        quantity: 10,
        entryTime: new Date().toISOString(),
        originalStopLoss: 95,
        originalTakeProfit: 110,
        currentStopLoss: 95,
        currentTakeProfit: 110,
        previousMarketEnv: '良好',
        previousMarketStrength: 60,
      };
      
      const result = dynamicPositionManager.adjustByMarketEnvironment(
        context, 105, '较差', 20, 5  // 盈利5%
      );
      
      expect(result.context.currentTakeProfit).toBeLessThan(110);
    });
  });
});
```

**运行测试**:
```bash
cd api
npm test -- dynamic-position-manager.test.ts
```

### 2. 手动测试步骤

#### 测试1: 买入时保存完整上下文

**步骤**:
1. 启动策略
2. 等待策略生成买入信号
3. 检查数据库 `strategy_instances` 表
4. 验证 `context` 字段包含所有新字段

**验证SQL**:
```sql
SELECT 
  symbol,
  current_state,
  context->>'entryPrice' as entry_price,
  context->>'entryTime' as entry_time,
  context->>'entryMarketEnv' as market_env,
  context->>'originalATR' as original_atr,
  context->'adjustmentHistory' as adjustment_history
FROM strategy_instances
WHERE current_state = 'HOLDING'
ORDER BY last_updated DESC
LIMIT 5;
```

**预期结果**:
- `entryTime` 不为空
- `entryMarketEnv` 不为空（应该是"良好"、"中性利好"等）
- `originalATR` 不为空（数字）
- `adjustmentHistory` 是空数组 `[]`

#### 测试2: 持仓监控动态调整

**步骤**:
1. 确保有持仓（状态为 HOLDING）
2. 观察日志输出
3. 检查是否有动态调整日志

**查看日志**:
```bash
# 查看策略日志
tail -f logs/strategy.log | grep "动态调整"
```

**预期日志**:
```
策略 {strategyId} 标的 {symbol}: 动态调整止盈/止损 - 止损: 95.00 -> 96.00, 止盈: 110.00 -> 108.00
```

**验证SQL**:
```sql
-- 查看调整历史
SELECT 
  symbol,
  context->'adjustmentHistory' as adjustments
FROM strategy_instances
WHERE current_state = 'HOLDING'
  AND jsonb_array_length(context->'adjustmentHistory') > 0;
```

#### 测试3: 市场环境变化响应

**步骤**:
1. 创建一个测试策略，持仓某个股票
2. 手动修改市场环境（模拟市场变化）
3. 观察动态调整是否触发

**注意**: 市场环境是从 `trading-recommendation.service` 获取的，需要实际市场数据。

**验证方法**:
- 查看日志中是否有市场环境变化相关的调整
- 检查数据库中的 `previousMarketEnv` 是否更新

#### 测试4: 持仓时间调整

**步骤**:
1. 创建一个持仓超过24小时的测试用例
2. 手动修改数据库中的 `entryTime` 为24小时前
3. 触发持仓监控
4. 观察是否有持仓时间相关的调整

**测试SQL**:
```sql
-- 修改entryTime为24小时前
UPDATE strategy_instances
SET context = jsonb_set(
  context,
  '{entryTime}',
  to_jsonb((NOW() - INTERVAL '25 hours')::text)
)
WHERE symbol = 'AAPL.US' AND current_state = 'HOLDING';
```

**预期结果**:
- 如果盈利，止盈应该收紧
- 日志中应该有持仓时间相关的调整信息

#### 测试5: 波动性调整

**步骤**:
1. 持仓一个波动性较大的股票
2. 观察ATR变化
3. 检查是否有波动性相关的调整

**验证方法**:
- 查看日志中的ATR信息
- 检查 `currentATR` 是否更新
- 如果波动性超过5%，应该有调整

### 3. 集成测试

#### 测试完整流程

**场景**: 买入 → 持仓监控 → 动态调整 → 卖出

**步骤**:
1. **启动策略**
   ```bash
   # 通过API启动策略
   curl -X POST http://localhost:3001/api/quant/strategies/1/start
   ```

2. **等待买入**
   - 策略每分钟运行一次
   - 等待生成买入信号并执行

3. **监控持仓**
   - 观察日志输出
   - 检查动态调整是否正常工作

4. **验证卖出**
   - 等待触发止盈/止损
   - 或等待动态调整建议卖出
   - 验证卖出订单是否正确提交

**验证SQL**:
```sql
-- 查看完整的交易流程
SELECT 
  si.symbol,
  si.current_state,
  si.context->>'entryPrice' as entry_price,
  si.context->>'currentStopLoss' as stop_loss,
  si.context->>'currentTakeProfit' as take_profit,
  si.context->'adjustmentHistory' as adjustments,
  eo.order_id,
  eo.side,
  eo.current_status
FROM strategy_instances si
LEFT JOIN execution_orders eo ON si.context->>'orderId' = eo.order_id
WHERE si.strategy_id = 1
ORDER BY si.last_updated DESC;
```

## 📊 回测功能说明

### 当前状态

**注意**: 回测功能已实现，详见 [回测功能文档](251215-回测功能文档.md)

回测功能包括：
1. **历史数据回测**
   - 使用历史K线数据
   - 使用历史市场环境数据
   - 模拟策略执行过程

2. **性能指标计算**
   - 总收益率
   - 最大回撤
   - 夏普比率
   - 胜率

3. **对比分析**
   - 修复前后的策略表现对比
   - 不同参数下的表现对比

## 🔍 问题排查

### 常见问题

#### 1. 动态调整没有触发

**可能原因**:
- 市场环境没有变化
- 持仓时间不足
- 波动性没有变化

**排查方法**:
```sql
-- 检查持仓上下文
SELECT 
  symbol,
  context->>'previousMarketEnv' as prev_env,
  context->>'entryMarketEnv' as entry_env,
  context->>'entryTime' as entry_time,
  NOW() - (context->>'entryTime')::timestamp as holding_duration
FROM strategy_instances
WHERE current_state = 'HOLDING';
```

#### 2. 调整历史没有记录

**可能原因**:
- 止盈/止损没有实际变化
- 调整逻辑没有执行

**排查方法**:
- 查看日志中是否有调整信息
- 检查 `adjustmentHistory` 字段

#### 3. 市场环境获取失败

**可能原因**:
- 交易推荐服务异常
- API调用失败

**排查方法**:
- 查看日志中的错误信息
- 测试交易推荐API是否正常

## 📝 测试检查清单

### 功能测试

- [ ] 买入时保存完整上下文
- [ ] 持仓监控动态调整
- [ ] 市场环境变化响应
- [ ] 持仓时间调整
- [ ] 波动性调整
- [ ] 风险保护机制

### 数据验证

- [ ] 数据库上下文格式正确
- [ ] 调整历史正确记录
- [ ] 市场环境正确保存
- [ ] ATR正确保存

### 日志验证

- [ ] 动态调整日志输出
- [ ] 市场环境变化日志
- [ ] 调整原因记录

### 集成测试

- [ ] 完整买入→持仓→卖出流程
- [ ] 动态调整触发卖出
- [ ] 固定止盈/止损触发卖出

---

## 📚 相关文档

- [回测功能文档](251215-回测功能文档.md) - 回测功能完整文档
- [交易推荐算法](../technical/251212-交易推荐逻辑总结.md) - 交易推荐逻辑
- [策略逻辑审查](../technical/251202-策略逻辑审查.md) - 策略逻辑审查

---

**文档版本**：v1.1  
**最后更新**：2025-12-05  
**状态**：已完成 ✅

---

## 📅 修订历史

### 2025-12-03：初始版本
- 完成动态交易策略设计文档
- 完成实施总结
- 完成Bug修复说明（高买低卖、重复卖出单）
- 完成测试指南

### 2025-12-05：资金使用差异修复
- 添加资金使用差异问题分析和修复方案
- 添加持仓数据解析BUG修复
- 添加Symbol格式标准化功能
- 添加增强日志输出功能


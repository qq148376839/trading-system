# 260218 — 期权信号系统动态化改造 开发文档

**创建时间**: 2026-02-18
**分析依据**: `docs/analysis/260218-SPY260217P676000-追高交易复盘.md`
**前置文档**: `docs/features/260216-0DTE单腿动态风控开发文档.md`
**状态**: ✅ 已完成（含 TSLPPCT 集成）

---

## 1. 背景与问题定义

### 1.1 事件回顾

2026-02-17 SPY 0DTE PUT 交易中，系统在 PUT 价格最高点（SPY 最低点）入场买入 PUT，随后 SPY V 形反转，PUT 价格暴跌，最终亏损 -31.4%。详细分析见复盘文档。

### 1.2 根因分析

通过对评分系统(`option-recommendation.service.ts`)的深度拆解，定位到以下结构性缺陷：

| 编号 | 缺陷 | 严重度 | 说明 |
|------|------|--------|------|
| D1 | **MA 排列加成为二值跳变** | **高** | `analyzeMarketTrend()` 第365-373行：完美空头排列一次性加 -25 分，导致 finalScore 在 2 分钟内跳变 21 分（从 -0.28 到 -21.0），触发入场 |
| D2 | **无动量耗竭/超卖检测** | **高** | 系统无 RSI、无价格加速度计算，累计动量评分在趋势末端达到峰值，恰好在最差位置给出最强信号 |
| D3 | **入场阈值为静态常量** | **中** | `ENTRY_THRESHOLDS.AGGRESSIVE.spreadScoreMin = 10`，不随市场波动率、时段、近期胜率调整 |
| D4 | **VWAP 获取缺少 TradeSessions 参数** | **高** | `getIntradayVWAP()` 调用 `candlesticks()` 缺少第 5 参数 `TradeSessions`，所有标的 VWAP 全部失败，结构确认全面降级放行 |
| D5 | **连续确认窗口过短** | **低** | 15 秒超时 + 评估间隔 ~5 秒，实际只需 2 次连续（约 10 秒），过滤效果有限 |

### 1.3 核心矛盾

**"动量追踪陷阱"** —— 基于累计动量的评分体系天然在趋势耗竭点给出最高分。系统追踪的是动量的历史积累量而非当前加速度，导致信号始终滞后于价格拐点。

---

## 2. 改造目标

### 2.1 核心目标

1. **引入均值回归/耗竭检测**（RSI 过滤器），避免在超买/超卖极端位置入场
2. **MA 加成线性化**，消除评分跳变
3. **价格破位快速确认**，替代过长的等待窗口
4. **修复 VWAP 数据获取**，确保结构确认可靠运行

### 2.2 设计原则

- **CALL 与 PUT 对称设计**：所有过滤器、阈值、确认逻辑必须同时覆盖看涨和看跌方向
- **参数可配置化**：核心阈值通过数据库策略配置热更新，无需重启
- **降级放行**：数据获取失败时记录警告并放行，不阻塞交易
- **最小侵入**：尽量在现有函数内插入逻辑，避免大规模重构

---

## 3. 涉及文件清单

| 文件 | 改动类型 | 改动范围 |
|------|----------|----------|
| `api/src/services/option-recommendation.service.ts` | **中改** | RSI 计算 + MA 加成线性化 + 评分输出增加 RSI 字段 |
| `api/src/services/strategies/option-intraday-strategy.ts` | **中改** | RSI 过滤器 + 价格破位确认改造 + 连续确认参数化 |
| `api/src/services/market-data.service.ts` | **小改** | VWAP `TradeSessions` 参数修复（一行） + `recentKlines` 扩展到 20 根 |
| `api/src/services/option-dynamic-exit.service.ts` | **无改动** | 退出逻辑已在 Phase 2 完成 |

---

## 4. 详细实现方案

### 4.1 Task 1：RSI 过滤器（解决 D2）

**目标**：在入场前检测超买/超卖状态，阻止在极端位置追高/追低。

**文件**: `option-recommendation.service.ts` + `option-intraday-strategy.ts`

#### 4.1.1 RSI 计算（recommendation service）

在 `option-recommendation.service.ts` 中新增 RSI 计算方法：

```typescript
/**
 * 计算 RSI（相对强弱指标）
 * 使用标的 1 分钟 K 线数据，计算 14 周期 RSI
 *
 * @param symbol 标的代码（如 SPY.US）
 * @param period RSI 周期数（默认 14）
 * @returns RSI 值（0-100），null 表示数据不足
 */
private async calculateRSI(
  symbol: string,
  period: number = 14
): Promise<number | null> {
  const vwapData = await marketDataService.getIntradayVWAP(symbol);
  if (!vwapData || vwapData.recentKlines.length < period + 1) {
    return null;
  }

  // 使用 recentKlines（需扩展 getIntradayVWAP 返回更多 K 线）
  // 或直接调用 1m K 线接口
  const klines = vwapData.recentKlines;
  const gains: number[] = [];
  const losses: number[] = [];

  for (let i = 1; i < klines.length; i++) {
    const change = klines[i].close - klines[i - 1].close;
    gains.push(change > 0 ? change : 0);
    losses.push(change < 0 ? -change : 0);
  }

  // EMA 平滑
  const avgGain = gains.slice(0, period).reduce((s, v) => s + v, 0) / period;
  const avgLoss = losses.slice(0, period).reduce((s, v) => s + v, 0) / period;

  let smoothGain = avgGain;
  let smoothLoss = avgLoss;
  for (let i = period; i < gains.length; i++) {
    smoothGain = (smoothGain * (period - 1) + gains[i]) / period;
    smoothLoss = (smoothLoss * (period - 1) + losses[i]) / period;
  }

  if (smoothLoss === 0) return 100;
  const rs = smoothGain / smoothLoss;
  return 100 - (100 / (1 + rs));
}
```

**数据源说明**：
- 当前 `getIntradayVWAP()` 返回最近 5 根 1m K 线（`recentKlines = klines.slice(-5)`）
- 需修改为返回最近 20 根（`klines.slice(-20)`），满足 RSI-14 计算需要
- 无需新增 5 分钟 K 线接口——直接复用已有的 1m K 线数据计算即可

**RSI 字段输出**：在 `calculateRecommendation()` 返回值中新增 `rsi?: number` 字段，传递给策略层。

#### 4.1.2 RSI 入场过滤（strategy service）

在 `option-intraday-strategy.ts` 的 `generateSignal()` 中，在连续确认（step 5.5）之前插入 RSI 检查：

```typescript
// 5.4) RSI 过滤：阻止在超买/超卖极端位置入场
const rsi = optionRec.rsi;
if (rsi !== null && rsi !== undefined) {
  const rsiOverbought = this.cfg.rsiOverboughtThreshold ?? 75;
  const rsiOversold = this.cfg.rsiOversoldThreshold ?? 25;

  if (direction === 'CALL' && rsi > rsiOverbought) {
    // CALL 方向但 RSI 超买 → 拒绝
    logData.finalResult = 'NO_SIGNAL';
    logData.rejectionReason = `RSI=${rsi.toFixed(1)} > ${rsiOverbought}，超买拒绝CALL`;
    logData.rejectionCheckpoint = 'rsi_filter';
    this.logDecision(logData);
    return null;
  }

  if (direction === 'PUT' && rsi < rsiOversold) {
    // PUT 方向但 RSI 超卖 → 拒绝
    logData.finalResult = 'NO_SIGNAL';
    logData.rejectionReason = `RSI=${rsi.toFixed(1)} < ${rsiOversold}，超卖拒绝PUT`;
    logData.rejectionCheckpoint = 'rsi_filter';
    this.logDecision(logData);
    return null;
  }
}
```

**对称性说明**：
- RSI < 25 阻止 PUT 入场（防止在超卖底部追空）
- RSI > 75 阻止 CALL 入场（防止在超买顶部追多）
- 阈值通过策略配置 `rsiOverboughtThreshold` / `rsiOversoldThreshold` 可调

**2/17 回测验证**：
- SPY 在 14:53 入场时 1m RSI 约 18-22（极度超卖），PUT 方向会被 RSI < 25 过滤器拦截
- 这是所有候选改进中**最有效**的单一措施

#### 4.1.3 配置扩展

在 `OptionIntradayStrategyConfig` 中新增：

```typescript
// ===== RSI 过滤配置 =====
rsiOverboughtThreshold?: number;  // RSI 超买阈值（默认 75），CALL 方向被拒绝
rsiOversoldThreshold?: number;    // RSI 超卖阈值（默认 25），PUT 方向被拒绝
```

---

### 4.2 Task 2：MA 加成线性化（解决 D1）

**目标**：消除 MA 排列加成的二值跳变，改为连续线性映射。

**文件**: `option-recommendation.service.ts`

**当前代码**（第 364-373 行）：

```typescript
// 当前：二值跳变
if (currentPrice > avg5 && avg5 > avg10 && avg10 > avg20) {
  trendStrength += 25;  // 完美多头：一次性 +25
} else if (currentPrice > avg10 && avg10 > avg20) {
  trendStrength += 15;  // 较强多头：一次性 +15
} else if (currentPrice < avg5 && avg5 < avg10 && avg10 < avg20) {
  trendStrength -= 25;  // 完美空头：一次性 -25
} else if (currentPrice < avg10 && avg10 < avg20) {
  trendStrength -= 15;  // 较强空头：一次性 -15
}
```

**改造方案**：基于 MA 偏离度的连续加成

```typescript
// 改造后：线性连续加成
// 计算各均线间的偏离度
const ma5Deviation = (avg5 - avg20) / avg20 * 100;   // MA5 相对 MA20 偏离%
const ma10Deviation = (avg10 - avg20) / avg20 * 100;  // MA10 相对 MA20 偏离%

// 均线排列得分 = 偏离度加权和，cap 到 ±25
// MA5 偏离 0.5% = 12.5分, 1% = 25分(满分)
const alignmentScore = Math.max(-25, Math.min(25,
  (ma5Deviation * 15 + ma10Deviation * 10) / 2
));

// 方向一致性加成：当均线完全同向排列时额外 +5（而非跳变 +10）
let directionBonus = 0;
if (currentPrice > avg5 && avg5 > avg10 && avg10 > avg20) {
  directionBonus = 5;
} else if (currentPrice < avg5 && avg5 < avg10 && avg10 < avg20) {
  directionBonus = -5;
}

trendStrength += alignmentScore + directionBonus;
```

**效果预估**（2/17 数据）：
- 旧逻辑：MA 排列从不满足到满足，trendStrength 一次跳变 25 分 → finalScore 跳变 ~21 分
- 新逻辑：MA 偏离从 0.3% 增长到 0.5%，trendStrength 从 +9 渐增到 +15 → finalScore 变化 ~5 分/分钟
- 跳变幅度降低约 **75%**

**对称性**：算法对多头/空头完全对称，`ma5Deviation` 为负时自动反映空头排列。

---

### 4.3 Task 3：价格破位确认改造（解决 D5 + 用户关注点 1）

**目标**：用更快速的价格破位确认替代当前连续确认机制。

**文件**: `option-intraday-strategy.ts`

#### 4.3.1 问题分析

当前连续确认（第 696-730 行）：
- 要求同方向信号在 **15 秒内**连续出现 2 次
- 实际评估间隔 ~5 秒，有效窗口为 2-3 次评估
- **问题**：纯粹基于信号重复，不检查价格行为，且 15 秒窗口既不能有效过滤假信号，又增加延迟

用户关注：原方案中的 3 分钟价格破位确认对期权来说太慢，可能错过最佳入场点。

#### 4.3.2 改造方案：60 秒快速确认

将纯信号重复确认改为**价格行为 + 信号双重确认**，窗口缩短至 60 秒：

```typescript
// 5.5) 快速价格破位确认（替代纯信号连续确认）
const confirmWindowSec = this.cfg.priceConfirmWindowSec ?? 60;  // 默认 60 秒

if (confirmWindowSec > 0) {
  const state = this.consecutiveStates.get(symbol);
  const nowMs = Date.now();

  if (state && state.direction === expectedDir && (nowMs - state.firstTime) < confirmWindowSec * 1000) {
    // 在确认窗口内，检查价格是否持续向信号方向移动
    const priceConfirmed = this.checkPriceConfirmation(symbol, direction, state);

    if (priceConfirmed) {
      // 价格确认通过
      this.consecutiveStates.delete(symbol);
      logger.info(`[破位确认] ${symbol} ${expectedDir} 通过 | 耗时${((nowMs - state.firstTime) / 1000).toFixed(0)}s`);
    } else if ((nowMs - state.firstTime) > confirmWindowSec * 1000 * 0.8) {
      // 窗口即将超时但价格未确认 → 拒绝
      this.consecutiveStates.delete(symbol);
      logData.finalResult = 'NO_SIGNAL';
      logData.rejectionReason = `破位确认超时：${confirmWindowSec}s内价格未持续向${expectedDir}方向运动`;
      logData.rejectionCheckpoint = 'price_confirm';
      this.logDecision(logData);
      return null;
    } else {
      // 继续等待
      logData.finalResult = 'NO_SIGNAL';
      logData.rejectionReason = `破位确认中 ${((nowMs - state.firstTime) / 1000).toFixed(0)}s/${confirmWindowSec}s`;
      logData.rejectionCheckpoint = 'price_confirm';
      this.logDecision(logData);
      return null;
    }
  } else {
    // 首次信号或方向变化 → 记录起点
    this.consecutiveStates.set(symbol, {
      direction: expectedDir,
      count: 1,
      lastTime: nowMs,
      firstTime: nowMs,
      entryPrice: optionRec.underlyingPrice,  // 记录首次信号时标的价格
    });
    logData.finalResult = 'NO_SIGNAL';
    logData.rejectionReason = `破位确认启动，等待${confirmWindowSec}s内价格确认`;
    logData.rejectionCheckpoint = 'price_confirm';
    this.logDecision(logData);
    return null;
  }
}
```

#### 4.3.3 价格确认逻辑

```typescript
/**
 * 检查价格是否向信号方向持续移动
 * PUT：标的价格应低于首次信号时的价格（至少 0.05%）
 * CALL：标的价格应高于首次信号时的价格（至少 0.05%）
 */
private checkPriceConfirmation(
  symbol: string,
  direction: 'CALL' | 'PUT',
  state: ConsecutiveState
): boolean {
  const currentPrice = state.currentUnderlyingPrice;  // 从最新评估获取
  const entryPrice = state.entryPrice;
  const minMovePct = 0.05;  // 最小确认幅度 0.05%

  if (direction === 'PUT') {
    return currentPrice < entryPrice * (1 - minMovePct / 100);
  } else {
    return currentPrice > entryPrice * (1 + minMovePct / 100);
  }
}
```

**为什么选择 60 秒而非 3 分钟**：
- 0DTE 期权 Gamma 极高，1 分钟内价格波动可达 10-20%
- 60 秒 = 1 根 1m K 线完成，足够确认价格趋势是否延续
- 3 分钟在快速行情中会错过 2-3 倍价格变动，入场价显著恶化
- 60 秒已能过滤掉大部分尖刺噪音（1-2 个评估周期内的假信号）

**对称性**：PUT 确认价格下行，CALL 确认价格上行，逻辑完全对称。

#### 4.3.4 配置扩展

```typescript
// ===== 价格确认配置 =====
priceConfirmWindowSec?: number;       // 破位确认窗口（秒），默认 60，设为 0 禁用
priceConfirmMinMovePct?: number;      // 破位确认最小价格变动%，默认 0.05
```

---

### 4.4 Task 4：VWAP 数据获取修复（解决 D4 + 用户关注点 2）

**目标**：修复 VWAP 数据无法生成的问题，确保结构确认可靠运行。

**文件**: `market-data.service.ts`

#### 4.4.1 问题定位

2/17 日志中 **所有标的** 的 VWAP 获取全部失败，错误信息完全一致：

```
[VWAP] SPY.US 获取失败: Failed to convert napi value into enum `TradeSessions`.
NumberExpected, Failed to convert napi value Undefined into rust type `i32`

[VWAP] IWM.US 获取失败: (同上)
[VWAP] QQQ.US 获取失败: (同上)
```

**根因**：`getIntradayVWAP()` 调用 `quoteCtx.candlesticks()` 时**缺少第 5 个参数 `TradeSessions`**。

LongPort SDK 3.0.18 的 Rust napi 绑定在运行时要求 `TradeSessions` 参数，但 TypeScript `.d.ts` 类型定义只声明了 4 个参数（未及时更新），导致 TypeScript 编译无报错，但运行时 Rust 层尝试将 `undefined` 转换为 `TradeSessions` 枚举时失败。

对比同文件中 VIX 的调用（正常工作，第 494 行）：
```typescript
// VIX（正常）：传了 5 个参数
candlesticks('.VIX.US', Period.Day, count, AdjustType.NoAdjust, TradeSessions?.All || 100)

// VWAP（失败，第 1125 行）：只传了 4 个参数
candlesticks(symbol, Period.Min_1, 240, AdjustType.NoAdjust)  // ← 缺少 TradeSessions
```

**这不是符号格式问题**：股票池配置的是 `SPY.US`、`IWM.US` 等 ETF/个股格式，LongPort 对这些标的的 1m K 线本身是支持的。

#### 4.4.2 修复方案

**一行修复**：补上 `TradeSessions` 参数（`market-data.service.ts` 第 1121-1130 行）

```typescript
// 修复前:
const { Period, AdjustType } = longport;
const candles = await quoteCtx.candlesticks(
  symbol, Period.Min_1, 240, AdjustType.NoAdjust
);

// 修复后:
const { Period, AdjustType, TradeSessions } = longport;
const candles = await quoteCtx.candlesticks(
  symbol, Period.Min_1, 240, AdjustType.NoAdjust,
  TradeSessions?.All || 100    // ← 补上 TradeSessions 参数
);
```

修复后 SPY/IWM/QQQ/TSLA/MU 全部标的的 VWAP 获取都会恢复正常。

#### 4.4.3 扩展 recentKlines 返回数量

当前 `recentKlines = klines.slice(-5)` 只返回最近 5 根。为支持 RSI-14 计算，需扩展到 20 根：

```typescript
// 修改 market-data.service.ts 第 1180 行
// 旧: const recentKlines = klines.slice(-5);
// 新:
const recentKlines = klines.slice(-20);  // 扩展到20根，支持RSI-14计算
```

同步修改接口返回类型注释，无需改签名。

#### 4.4.4 VWAP 结构确认是否需要改造？

**结论：当前逻辑无需改造，修复数据获取即可。**

当前 VWAP 结构确认逻辑（第 732-801 行）已覆盖 PUT 和 CALL 双向：
- PUT：最近 2 根 1m K 线收盘均在 VWAP 下方 + 无强反转阳线
- CALL：最近 2 根 1m K 线收盘均在 VWAP 上方 + 无强下砸阴线

逻辑本身是合理且对称的。2/17 的问题不是逻辑错误，而是**数据获取失败导致整个确认被跳过**。修复数据获取即可恢复结构确认的保护作用。

#### 4.4.5 降级策略（修复后仍保留）

`TradeSessions` 修复后预期不再出现 napi 错误，但保留现有降级逻辑作为防御：
- 60s 缓存 TTL + 5 分钟过期缓存降级（已实现）
- 获取失败时 `logger.warn` 而非 `logger.error`，避免告警噪音
- 结构确认降级放行（已实现，`logger.debug("VWAP数据不可用，跳过结构确认")`）

---

## 5. 实施顺序与依赖关系

```
Task 4 (VWAP修复)  ──────────────────────────────┐
                                                   │
Task 2 (MA线性化)  ─── 无依赖，可独立实施          │
                                                   ▼
Task 1 (RSI过滤器)  ─── 依赖 Task 4 (recentKlines扩展)
                                                   │
Task 3 (价格破位确认) ─── 无依赖，可独立实施        │
                                                   ▼
                                              集成测试
```

**推荐实施顺序**：

1. **Phase 1**：Task 4（VWAP 修复） + Task 2（MA 线性化）—— 可并行开发
2. **Phase 2**：Task 1（RSI 过滤器）—— 依赖 Task 4 的 recentKlines 扩展
3. **Phase 3**：Task 3（价格破位确认）—— 替代连续确认

---

## 6. 配置变更汇总

### 6.1 新增策略配置字段

| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `rsiOverboughtThreshold` | `number` | `75` | RSI 超买阈值，CALL 方向在此值以上被拒绝 |
| `rsiOversoldThreshold` | `number` | `25` | RSI 超卖阈值，PUT 方向在此值以下被拒绝 |
| `priceConfirmWindowSec` | `number` | `60` | 破位确认窗口秒数，设 0 禁用 |
| `priceConfirmMinMovePct` | `number` | `0.05` | 破位确认最小价格变动百分比 |

### 6.2 修改的现有行为

| 变更点 | 旧行为 | 新行为 |
|--------|--------|--------|
| MA 排列加成 | 二值跳变 ±25/±15 | 线性连续 ±25（基于偏离度）+ 方向一致性 ±5 |
| `recentKlines` 数量 | 最近 5 根 1m K 线 | 最近 20 根 1m K 线 |
| 连续确认 | 15s 内同向信号重复 2 次 | 60s 内信号 + 价格向信号方向确认 |
| VWAP 获取 | 缺少 `TradeSessions` 参数，全部标的 100% 失败 | 补上 `TradeSessions` 参数，恢复正常获取 |

### 6.3 recommendation 返回值新增字段

```typescript
// calculateRecommendation() 返回值新增
{
  rsi?: number;           // 标的 1m RSI-14 值（0-100）
  maAlignmentScore?: number;  // MA排列连续得分（-25 到 +25，调试用）
}
```

---

## 7. 风险评估

| 风险 | 等级 | 说明 | 缓解 |
|------|------|------|------|
| RSI 过滤过于严格 | **中** | 默认 25/75 可能拒绝过多有效信号 | 阈值可通过 DB 配置调整；先上线观察再收紧 |
| MA 线性化降低信号强度 | **低** | 线性化后 finalScore 峰值会降低 | 同步可降低入场阈值（如 10→8），保持信号频率 |
| 60s 确认窗口仍可能错过快速行情 | **低** | 极端行情中 60s 仍有延迟 | 可设为 30s 或通过配置禁用（`priceConfirmWindowSec=0`） |
| recentKlines 从 5 扩展到 20 | **极低** | 数据量增加但仍在内存缓存中 | 无性能影响 |
| VWAP 修复后仍可能偶发失败 | **低** | LongPort API 限流或网络抖动 | 已有 60s 缓存 + 5min 降级缓存兜底 |

---

## 8. 2/17 回测预期效果

基于 2/17 SPY PUT 交易数据的模拟：

| 改进项 | 对 2/17 PUT 入场的影响 | 对 CALL 入场的影响（假设场景） |
|--------|------------------------|-------------------------------|
| RSI 过滤 | 14:53 RSI≈18-22 < 25，**拦截 PUT 入场** | RSI > 75 时拦截 CALL，防止追高 |
| MA 线性化 | finalScore 从 -21 降至约 -14，**未达 -15 阈值** | 同理，CALL finalScore 峰值降低 |
| 价格破位确认 | 60s 内 SPY 继续下跌 → 确认通过（不拦截） | 60s 内标的继续上涨 → 确认通过 |
| VWAP 修复 | VWAP 数据恢复可用，14:53 SPY 价格在 VWAP 下方 → 结构确认通过（放行 PUT） | VWAP 上方 → 放行 CALL |

**综合效果**：RSI 过滤 + MA 线性化任一生效即可避免 2/17 亏损。双重保护提供冗余安全。

---

## 9. 测试计划

### 9.1 单元测试

| 测试项 | 覆盖函数 | 验证内容 |
|--------|----------|----------|
| RSI 计算正确性 | `calculateRSI()` | 上涨序列 RSI→100，下跌序列→0，震荡→50 附近 |
| RSI 过滤对称性 | `generateSignal()` | PUT+RSI<25 被拦截，CALL+RSI>75 被拦截 |
| MA 线性化 | `analyzeMarketTrend()` | 偏离 0.5% 得分约 12，偏离 1% 得分约 25 |
| MA 线性化无跳变 | `analyzeMarketTrend()` | 连续输入价格序列，输出无突变 |
| 价格破位确认 | `generateSignal()` | 60s 内价格反向 → 拒绝，同向 → 通过 |
| VWAP TradeSessions 参数修复 | `getIntradayVWAP()` | 补上 TradeSessions 后能正常获取 SPY/IWM/QQQ 1m K 线 |

### 9.2 集成测试

- 使用 2/17 历史数据回放，验证 RSI 过滤在 14:53 拦截 PUT 入场
- 使用 2/12 历史数据回放，验证正常信号（得分 -12.8，RSI ~40）仍可通过
- 验证 CALL 方向的对称行为（使用模拟数据）

---

## 10. 后续迭代方向（本次不实施）

以下改进经分析确认有价值，但优先级低于上述 4 项核心改造，留待后续：

| 编号 | 改进 | 预期效果 | 前置条件 |
|------|------|----------|----------|
| B1 | 波动率自适应阈值 | 高波动日放宽阈值、低波动日收紧 | 需积累更多交易日数据 |
| B2 | 时间自适应阈值 | 开盘黄金窗口降低阈值、尾盘提高 | 已有 timeWindowAdjustment 基础 |
| B3 | 连续亏损自适应 | 连亏后自动提高阈值、减小仓位 | 需对接交易记录查询 |
| C1 | 多时间周期趋势阶段识别 | 识别趋势初期/中期/末期 | 需 5m/15m/1h K 线数据 |
| C2 | 成交量确认 | 放量确认信号有效性 | 当前期权成交量数据已可用 |

---

## 11. 实施记录

**实施时间**: 2026-02-18
**实施范围**: Task 1-4 全部完成 + TSLPPCT 券商保护单集成

### 11.1 实际改动汇总

| 阶段 | 文件 | 改动 | 状态 |
|------|------|------|------|
| Phase 1 | `market-data.service.ts` | VWAP `TradeSessions` 参数修复 + `recentKlines` 扩展到 20 根 | ✅ |
| Phase 1 | `option-intraday-strategy.ts` | 0DTE 禁入默认值 `?? 30` → `?? 0` | ✅ |
| Phase 1 | `option-intraday-strategy.ts` | LATE 时段截止 180 分钟 → 120 分钟（13:00→14:00 ET） | ✅ |
| Phase 2 | `option-recommendation.service.ts` | 新增 `calculateRSI14()` 公共方法（Wilder's Smoothed RSI-14） | ✅ |
| Phase 2 | `option-recommendation.service.ts` | MA 排列加成线性化（偏离度加权：MA5×0.7 + MA10×0.3，clamp ±30） | ✅ |
| Phase 2 | `option-intraday-strategy.ts` | RSI 过滤门：PUT+RSI<25 拒绝 / CALL+RSI>75 拒绝（`rsiFilter` 配置） | ✅ |
| Phase 2 | `option-intraday-strategy.ts` | 价格确认替代连续确认：60s 窗口内标的价格移动 ≥0.03% 确认 | ✅ |
| Phase 3 | `strategy-scheduler.service.ts` | TSLPPCT 集成：买入成交后提交保护单 | ✅ |
| Phase 3 | `strategy-scheduler.service.ts` | TSLPPCT 集成：退出循环顶部检查保护单状态 | ✅ |
| Phase 3 | `strategy-scheduler.service.ts` | TSLPPCT 集成：软件卖出前取消保护单（含 alreadyFilled 竞态处理） | ✅ |
| Phase 3 | `strategy-scheduler.service.ts` | TSLPPCT 集成：卖出成交处理识别 TSLPPCT 自动成交 | ✅ |

### 11.2 与原方案的差异

| 方案点 | 原方案 | 实际实现 | 原因 |
|--------|--------|----------|------|
| RSI 配置位置 | 顶层 `rsiOverboughtThreshold` | 嵌套 `rsiFilter.enabled/oversoldThreshold/overboughtThreshold` | 支持整体开关 |
| MA 线性化公式 | `(ma5Dev * 15 + ma10Dev * 10) / 2 + directionBonus` | `(ma5Dev * 30 * 0.7 + ma10Dev * 30 * 0.3)` clamp ±30 | 简化为单一加权，去除二元 directionBonus |
| 价格确认阈值 | 0.05% | 0.03% | 更灵敏，适配 0DTE 快速行情 |
| TSLPPCT | 原不在计划内 | 完整集成 submit/monitor/cancel | 利用已有的 `trailing-stop-protection.service.ts` |
| `TradeSessions` 类型 | `const { TradeSessions } = longport` | `const TradeSessions = (longport as any).TradeSessions` | TS 类型定义未导出 `TradeSessions`，运行时可用 |

### 11.3 TSLPPCT 安全属性

- **提交失败** → 软件监控继续（已验证流程）
- **保护单先成交** → `processOptionDynamicExit` 顶部检测 `filled`，直接 IDLE，不重复卖
- **软件退出时保护单已成交** → `cancelProtection` 返回 `alreadyFilled: true`，跳过软件卖出
- **双方同时触发** → 券商拒绝第二笔（持仓为 0），已有错误处理兜底

### 11.4 构建验证

编译通过（4 个 pre-existing 缺失类型声明错误与本次改动无关）。

```
4 files changed, 300 insertions(+), 34 deletions(-)
```

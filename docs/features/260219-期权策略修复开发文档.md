# 期权策略修复开发文档

**制定日期**: 2026-02-19
**修复计划**: `docs/features/260218-SPY追高交易修复计划.md`
**复盘分析**: `docs/analysis/260218-SPY260217P676000-追高交易复盘.md`
**优先级**: P0 > P1 > P2

---

## 1. 概述

本文档为期权策略修复的详细开发实现方案。基于 2/17 SPY PUT (-31.4%) 和 2/18 TSLA CALL (-63.1%) 两笔连续亏损交易的复盘分析，已确认当前策略存在系统性缺陷：

1. 评分系统在趋势极端点产生最强信号，导致在反转前一刻入场
2. 多层过滤（RSI、价格确认、连续确认）延迟入场，使系统在最差时机入场
3. TSLPPCT 因到期日 bug 无法提交，券商侧追踪止损完全失效
4. VWAP 结构确认因 napi SDK bug 全天不可用

核心修复策略：移除所有延迟类过滤、实现反向信号策略、修复 TSLPPCT 到期日 bug、修复 VWAP napi 问题，通过动态风控 + kill switch 控制风险。

---

## 2. 修改清单

| 编号 | 文件路径 | 修改描述 | 优先级 |
|------|---------|---------|--------|
| Fix 2.5 | `api/src/services/trailing-stop-protection.service.ts` | TSLPPCT 到期日修复：0DTE/1DTE 到期日改为 max(optionExpiry, tomorrow) | P0 |
| Fix 1 | `api/src/services/strategies/option-intraday-strategy.ts` | VWAP 降级拒绝：0DTE 入场时 VWAP 不可用直接拒绝 | P0 |
| Fix 2 | `api/src/services/market-data.service.ts` | VWAP napi 修复：硬编码 TradeSessions 值 100，包裹 try/catch | P0 |
| Fix 5 | `api/src/services/trailing-stop-protection.service.ts` | TSLPPCT trailing 15% 下调至 10%（0DTE） | P0 |
| Fix 3 | `api/src/services/strategies/option-intraday-strategy.ts` | 动量衰减检测：得分从极值回归时拒绝 0DTE 入场 | P1 |
| Fix 4 | 数据库配置 | zdteCooldownMinutes: 30 -> 15 | P1 |
| Fix 7 | `api/src/services/strategies/option-intraday-strategy.ts` | K 线价格位置检测：防止追高入场 | P1 |
| Fix 8a | `api/src/services/strategies/option-intraday-strategy.ts` | 移除延迟过滤：RSI 阈值改为极端值、价格确认 bypass、连续确认改为 1 | P1 |
| Fix 8b | `api/src/services/strategies/option-intraday-strategy.ts` | 反向策略：极端得分时反向交易 + kill switch | P1 |
| Fix 6 | `api/src/services/strategy-scheduler.service.ts` + `api/src/services/basic-execution.service.ts` | 动态调整盈亏比例：成交偏差 > 2% 时收紧 trailing | P2 |
| Fix 9 | `api/src/services/strategy-scheduler.service.ts` | 日志 NaN 修复：exitPnLPercent 改用 grossPnLPercent | P2 |
| Fix 10 | `api/src/services/capital-manager.service.ts` | 资金差异修复：订单成交与资金释放同步 | P2 |
| Fix 8c | `api/src/services/strategies/option-intraday-strategy.ts` | 反向策略跳过 VWAP 结构确认：|score| >= 15 时 bypass VWAP 方向检查 | P1 |
| Fix 11 | `api/src/services/strategy-scheduler.service.ts` | 动态冷却期：0DTE 退出后冷却根据交易次数递增（0→1→3 分钟） | P1 |

---

## 3. 详细实现方案

### Fix 2.5 — TSLPPCT 到期日修复 [P0]

**问题**: 对于 0DTE/1DTE 期权，到期日就是当天或明天，券商拒绝 "expire date should be after today's date"，导致 TSLPPCT 完全无法提交。这是 Fix 5（trailing 10%）生效的前提条件。

**修改文件**: `api/src/services/trailing-stop-protection.service.ts`

**修改位置**: `submitProtection()` 方法，line 76-88

**当前代码** (line 80-88):
```typescript
// LongPort SDK 要求 NaiveDate 而非 JS Date
const longport = require('longport');
const { NaiveDate } = longport;
const dateParts = expireDate.split('-'); // YYYY-MM-DD
const expireNaiveDate = new NaiveDate(
  parseInt(dateParts[0], 10),
  parseInt(dateParts[1], 10),
  parseInt(dateParts[2], 10)
);
```

**修改后**:
```typescript
// LongPort SDK 要求 NaiveDate 而非 JS Date
const longport = require('longport');
const { NaiveDate } = longport;

// 修复：券商要求 expireDate 必须在今天之后
// 对于 0DTE/1DTE 期权，到期日可能是今天，导致提交被拒绝
// 解决方案：expireDate = max(optionExpiry, tomorrow)
const today = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
let effectiveExpireDate = expireDate;
if (expireDate <= today) {
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  effectiveExpireDate = tomorrow.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
  logger.log(
    `${TSLP_TAG} ${symbol}: 期权到期日${expireDate}不晚于今天${today}，` +
    `TSLPPCT到期日调整为${effectiveExpireDate}`
  );
}

const dateParts = effectiveExpireDate.split('-'); // YYYY-MM-DD
const expireNaiveDate = new NaiveDate(
  parseInt(dateParts[0], 10),
  parseInt(dateParts[1], 10),
  parseInt(dateParts[2], 10)
);
```

**注意事项**:
- `toLocaleDateString('en-CA')` 输出格式为 `YYYY-MM-DD`，与现有 expireDate 格式一致
- 需要使用 `America/New_York` 时区，因为美股交易日以美东时间为准
- TSLPPCT 的 expireDate 是订单有效期，不是期权到期日，所以延后一天不影响逻辑
- 周五到期的 0DTE，expireDate 设为周六，券商会在下一个交易日（周一）前处理

---

### Fix 1 — VWAP 降级策略改为保守拒绝 [P0]

**问题**: VWAP 获取失败时，系统跳过结构确认降级放行，导致唯一能识别反转的安全网失效。2/17 交易中 VWAP 因 napi bug 全天不可用，降级放行导致在 V 型反转底部买入 PUT。

**修改文件**: `api/src/services/strategies/option-intraday-strategy.ts`

**修改位置**: `generateSignal()` 方法中结构确认逻辑，line 910-911

**当前代码** (line 910-911):
```typescript
} else {
  logger.debug(`[结构确认] ${symbol} VWAP数据不可用，跳过结构确认（降级放行）`);
}
```

**修改后**:
```typescript
} else {
  // 0DTE 入场必须通过 VWAP 结构确认，不可降级放行
  if (is0DTEEntry) {
    logger.warn(
      `[结构确认] ${symbol} VWAP数据不可用，拒绝0DTE入场（安全网失效）`
    );
    logData.finalResult = 'NO_SIGNAL';
    logData.rejectionReason = 'VWAP_UNAVAILABLE_0DTE_BLOCKED';
    logData.rejectionCheckpoint = 'structure_confirm';
    this.logDecision(logData);
    return null;
  }
  // 1DTE/2DTE 允许降级放行（容错空间更大）
  logger.debug(`[结构确认] ${symbol} VWAP数据不可用，跳过结构确认（降级放行，非0DTE）`);
}
```

**同时修改** line 913-914 的 catch 分支：
```typescript
} catch (structErr: any) {
  if (is0DTEEntry) {
    logger.warn(`[结构确认] ${symbol} 异常: ${structErr.message}，拒绝0DTE入场`);
    logData.finalResult = 'NO_SIGNAL';
    logData.rejectionReason = `VWAP_ERROR_0DTE_BLOCKED: ${structErr.message}`;
    logData.rejectionCheckpoint = 'structure_confirm';
    this.logDecision(logData);
    return null;
  }
  logger.warn(`[结构确认] ${symbol} 异常: ${structErr.message}，跳过结构确认（降级放行，非0DTE）`);
}
```

**注意事项**:
- `is0DTEEntry` 变量在 line 567 已定义：`const is0DTEEntry = expirationMode === '0DTE' && !isInZdteCooldown`
- 此修改在结构确认 try/catch 的两个降级路径中均需应用
- 1DTE/2DTE 仍然保持降级放行，因为容错空间更大

---

### Fix 2 — VWAP napi 修复 [P0]

**问题**: `Failed to convert napi value into enum TradeSessions` 导致 VWAP 全天不可用。根因是 LongPort SDK 的 `TradeSessions` 枚举通过 `(longport as any).TradeSessions` 动态获取，类型转换失败。

**修改文件**: `api/src/services/market-data.service.ts`

**修改位置 1**: `getIntradayVWAP()` 方法，line 1126-1135

**当前代码** (line 1126-1134):
```typescript
const TradeSessions = (longport as any).TradeSessions;
const quoteCtx = await getQuoteContext();

const candles = await quoteCtx.candlesticks(
  symbol,
  Period.Min_1,
  240,
  AdjustType.NoAdjust,
  TradeSessions?.All || 100
);
```

**修改后**:
```typescript
const quoteCtx = await getQuoteContext();

// 修复：直接使用数值 100 代替 TradeSessions.All
// LongPort SDK 的 TradeSessions 枚举在 napi 层存在类型转换 bug
// TradeSessions.All 的实际值为 100，硬编码避免 napi 错误
let tradeSessionsAll = 100;
try {
  const TradeSessions = (longport as any).TradeSessions;
  if (TradeSessions && typeof TradeSessions.All === 'number') {
    tradeSessionsAll = TradeSessions.All;
  }
} catch (enumErr: unknown) {
  logger.debug(`[VWAP] ${symbol} TradeSessions枚举获取失败，使用默认值100`);
}

const candles = await quoteCtx.candlesticks(
  symbol,
  Period.Min_1,
  240,
  AdjustType.NoAdjust,
  tradeSessionsAll
);
```

**修改位置 2**: VIX 数据获取，line 496-503

**当前代码** (line 496-502):
```typescript
const { TradeSessions } = longport;
candlesticks = await quoteCtx.candlesticks(
  '.VIX.US',
  Period.Day,
  count,
  AdjustType.NoAdjust,
  TradeSessions?.All || 100
);
```

**修改后**:
```typescript
// 修复：与 getIntradayVWAP 一致，避免 TradeSessions napi 错误
let tradeSessionsAll = 100;
try {
  const TradeSessions = (longport as any).TradeSessions;
  if (TradeSessions && typeof TradeSessions.All === 'number') {
    tradeSessionsAll = TradeSessions.All;
  }
} catch {
  // 使用默认值 100
}
candlesticks = await quoteCtx.candlesticks(
  '.VIX.US',
  Period.Day,
  count,
  AdjustType.NoAdjust,
  tradeSessionsAll
);
```

**注意事项**:
- 两处修改使用相同模式：先尝试获取枚举值，失败则使用硬编码 100
- 值 100 已通过 LongPort SDK 文档和现有代码中的 fallback 确认
- 修复后需在开盘时段验证 VWAP 数据是否恢复可用

---

### Fix 5 — TSLPPCT trailing 15% 下调至 10% [P0]

**问题**: 当前 0DTE 默认 trailing=15%，复盘模拟显示 trailing=10% 可实现近乎保本 (-0.8%)，而 15% 仍亏损 -8.3%。

**修改文件**: `api/src/services/trailing-stop-protection.service.ts`

**修改位置**: `getTrailingPercentForPhase()` 方法，line 352-355

**当前代码** (line 352-355):
```typescript
// 0DTE 收紧
if (params.is0DTE) {
  tp = Math.min(tp, 15);
}
```

**修改后**:
```typescript
// 0DTE 收紧：从 15% 下调至 10%
// 基于复盘分析 Section 10.7.1 敏感性分析：
// trailing=10% 在 2/17 SPY 交易中可实现 -0.8%（近乎保本）
// trailing=15% 仍亏损 -8.3%
if (params.is0DTE) {
  tp = Math.min(tp, 10);
}
```

**注意事项**:
- 此修改依赖 Fix 2.5 先行完成（到期日修复），否则 TSLPPCT 根本无法提交
- 1DTE/2DTE 的 trailing 不受影响，仍由其他分支逻辑控制
- trailing=10% 可能过于敏感，导致正常波动提前触发，需要观察 1 周实盘数据

---

### Fix 3 — 入场动量衰减检测 [P1]

**问题**: 系统只检查绝对得分是否超过阈值，不考虑得分变化方向。2/17 交易中得分从 -17.6 回升至 -15.7，说明看空动量已在减弱，但系统仍然入场。

**修改文件**: `api/src/services/strategies/option-intraday-strategy.ts`

**修改位置 1**: 类属性声明，在 line 260-262 的 `tradeWindowSkipLogTimes` 之后添加

**新增代码**:
```typescript
// 动量衰减检测：历史得分记录
private scoreHistory: Map<string, { score: number; timestamp: number }> = new Map();
```

**修改位置 2**: `generateSignal()` 方法中，在策略评估通过后（line 696 `break` 之后），RSI 过滤之前（line 710 之前），插入动量衰减检测

**新增代码** (在 line 708 `logData.selectedStrategy = selectedStrategy;` 之后):
```typescript
// 5.2) 动量衰减检测：得分从极值回归时拒绝 0DTE 入场
if (is0DTEEntry) {
  const prevEntry = this.scoreHistory.get(symbol);
  const currentScore = optionRec.finalScore;
  const nowMs = Date.now();

  if (prevEntry && (nowMs - prevEntry.timestamp) <= 60_000) {
    const previousScore = prevEntry.score;
    // 检测衰减：当前绝对值小于前次绝对值，说明动量在减弱
    if (
      Math.abs(currentScore) < Math.abs(previousScore) &&
      Math.abs(currentScore) >= Math.abs(previousScore) * 0.8
    ) {
      logger.warn(
        `[动量衰减] ${symbol} 得分从极值回归中: ${previousScore.toFixed(1)} -> ${currentScore.toFixed(1)} ` +
        `(|${currentScore.toFixed(1)}| < |${previousScore.toFixed(1)}|)，暂缓0DTE入场`
      );
      this.scoreHistory.set(symbol, { score: currentScore, timestamp: nowMs });
      logData.finalResult = 'NO_SIGNAL';
      logData.rejectionReason = `动量衰减：得分从${previousScore.toFixed(1)}回归至${currentScore.toFixed(1)}`;
      logData.rejectionCheckpoint = 'momentum_decay';
      this.logDecision(logData);
      return null;
    }
  }
  // 更新历史得分
  this.scoreHistory.set(symbol, { score: currentScore, timestamp: nowMs });
}
```

**注意事项**:
- 使用 `Math.abs(currentScore) < Math.abs(previousScore)` 而非 `scoreTrend > 0`，正确处理看多和看空两个方向的衰减
- 80% 阈值确保只在 "仍接近极值但已开始回归" 时触发，避免得分大幅下降后误触发
- 60 秒超时窗口：超过 60 秒的历史得分视为无效（评估周期约 5 秒）
- 仅对 0DTE 入场生效，1DTE/2DTE 不受影响

---

### Fix 4 — 禁入窗口调整 [P1]

**问题**: 0DTE 禁入窗口 30 分钟损失 7.7% 交易窗口，且在 2/17 交易中延迟了入场导致追高。

**修改方式**: 数据库配置修改 + 代码修改

**DB 配置修改**: `zdteCooldownMinutes: 30 -> 15`

**代码修改**: 极端信号豁免冷却窗口

**修改文件**: `api/src/services/strategies/option-intraday-strategy.ts`

**修改位置**: line 560-567

**当前代码** (line 560-567):
```typescript
const zdteCooldownMinutes = this.cfg.tradeWindow?.zdteCooldownMinutes ?? 0;
const isInZdteCooldown = minutesSinceOpen >= 0 && minutesSinceOpen < zdteCooldownMinutes;
// ...
if (isInZdteCooldown) {
  skip0DTE = true;
}
```

**修改后**:
```typescript
const zdteCooldownMinutes = this.cfg.tradeWindow?.zdteCooldownMinutes ?? 0;
const isInZdteCooldown = minutesSinceOpen >= 0 && minutesSinceOpen < zdteCooldownMinutes;

let skip0DTE = false;
if (isInZdteCooldown) {
  // 极端信号豁免冷却窗口
  const absScore = Math.abs(optionRec.finalScore);
  if (absScore >= OptionIntradayStrategy.EXTREME_THRESHOLD) {
    logger.info(
      `[0DTE冷却] ${symbol} 冷却窗口内但得分${optionRec.finalScore.toFixed(1)}达极端值(阈值${OptionIntradayStrategy.EXTREME_THRESHOLD})，` +
      `豁免冷却，允许0DTE入场`
    );
    skip0DTE = false;
  } else {
    skip0DTE = true;
    logger.debug(`[0DTE冷却] ${symbol} 冷却窗口内，得分${optionRec.finalScore.toFixed(1)}未达极端值，降级1DTE/2DTE`);
  }
}
```

**注意事项**:
- `EXTREME_THRESHOLD` (15) 复用 Fix 8b 的常量，保持一致
- 极端信号绕过冷却后，仍需通过后续的反向策略(Fix 8b)、VWAP跳过(Fix 8c)等检查
- 这里有一个时序问题：冷却判断在 line 560-567，但 finalScore 在 line 588-605 才计算。需要调整代码顺序，将评分计算提前到冷却判断之前，或者延迟冷却判断到评分之后
- 推荐方案：将 `skip0DTE` 的最终决定延迟到评分计算之后

**时序调整方案**:
```typescript
// 原来的位置（line 560-567）：先标记为冷却中
const isInZdteCooldown = minutesSinceOpen >= 0 && minutesSinceOpen < zdteCooldownMinutes;

// ... 评分计算（line 588-605）...

// 评分计算完成后，再决定是否真的 skip0DTE
if (isInZdteCooldown) {
  const absScore = Math.abs(optionRec.finalScore);
  if (absScore >= OptionIntradayStrategy.EXTREME_THRESHOLD) {
    skip0DTE = false; // 极端信号豁免
  } else {
    skip0DTE = true;  // 非极端降级
  }
}
```

**测试用例**:

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 冷却窗口内 + 极端信号 | minutesSinceOpen=5, score=-20 | skip0DTE=false，允许 0DTE |
| 冷却窗口内 + 非极端信号 | minutesSinceOpen=5, score=-13 | skip0DTE=true，降级 1DTE |
| 冷却窗口外 | minutesSinceOpen=20, score=-13 | skip0DTE=false，允许 0DTE |
| 冷却窗口内 + kill switch 触发 | minutesSinceOpen=5, score=-20, killSwitch=true | skip0DTE=false（冷却豁免与 kill switch 独立） |

---

### Fix 7 — K 线价格位置检测 [P1]

**问题**: 不检查入场价格在近期 K 线中的位置，可能买在蜡烛上半部分（追高）。2/17 交易中买入价 $2.09 位于 5 分钟 K 线 68.8% 分位。

**修改文件**: `api/src/services/strategies/option-intraday-strategy.ts`

**修改位置**: 在 `OptionIntradayStrategy` 类中新增方法，放在 `generateSignal()` 之后

**新增方法**:
```typescript
/**
 * 检查期权价格在近期 K 线中的位置，防止追高入场
 * 对 PUT 和 CALL 都适用：pricePosition > 0.7 = 追高
 * （期权价格在近期高位意味着标的已大幅移动，追入风险高）
 */
private async checkOptionPricePosition(
  optionSymbol: string,
  entryPrice: number,
  is0DTEEntry: boolean
): Promise<{ allowed: boolean; reason?: string }> {
  try {
    // 获取期权最近 3 根 5 分钟 K 线
    const vwapData = await marketDataService.getIntradayVWAP(
      optionSymbol.replace(/\.(US|HK)$/i, '').replace(/\d{6}[CP]\d+/, (m) => m) // 尝试获取期权K线
    );

    // 如果无法获取期权 K 线，使用标的 K 线作为代理
    // 注：此处为简化实现，后续可扩展为直接获取期权 K 线
    if (!vwapData || vwapData.recentKlines.length < 3) {
      return { allowed: true }; // 数据不足，放行
    }

    const recentKlines = vwapData.recentKlines.slice(-3);
    const recentHigh = Math.max(...recentKlines.map(k => k.high));
    const recentLow = Math.min(...recentKlines.map(k => k.low));
    const priceRange = recentHigh - recentLow;

    if (priceRange <= 0) {
      return { allowed: true }; // 无波动，放行
    }

    const pricePosition = (entryPrice - recentLow) / priceRange;

    // 无论 PUT 还是 CALL，期权价格在近期高点 70% 以上均视为追高
    // 因为期权价格高位意味着标的已大幅移动（PUT: 标的大跌 / CALL: 标的大涨）
    if (pricePosition > 0.7 && is0DTEEntry) {
      return {
        allowed: false,
        reason: `OPTION_PRICE_POSITION_HIGH: ${(pricePosition * 100).toFixed(1)}%分位，近期高${recentHigh.toFixed(2)}低${recentLow.toFixed(2)}`
      };
    }

    return { allowed: true };
  } catch (error: unknown) {
    const errMsg = error instanceof Error ? error.message : String(error);
    logger.debug(`[价格位置] ${optionSymbol} 检测失败: ${errMsg}，放行`);
    return { allowed: true }; // 检测失败时保守放行
  }
}
```

**调用位置**: 在 `generateSignal()` 方法中合约选择成功后（line 936 之后），入场价格确定后（line 951 之后），生成交易意图前（line 1001 之前），插入检测调用：

```typescript
// 8.5) K 线价格位置检测：防止追高入场
if (is0DTEEntry) {
  const posCheck = await this.checkOptionPricePosition(
    selected.optionSymbol,
    premium,
    is0DTEEntry
  );
  if (!posCheck.allowed) {
    logger.warn(`[价格位置] ${selected.optionSymbol} ${direction} 拒绝：${posCheck.reason}`);
    logData.finalResult = 'NO_SIGNAL';
    logData.rejectionReason = posCheck.reason;
    logData.rejectionCheckpoint = 'price_position';
    this.logDecision(logData);
    return null;
  }
}
```

**注意事项**:
- 对 PUT 和 CALL 统一使用 `pricePosition > 0.7` 判定追高，因为期权价格在高位说明标的已大幅移动
- 检测失败时保守放行（不阻止入场），避免数据问题导致无法交易
- 仅对 0DTE 入场生效

---

### Fix 8a — 移除延迟过滤 [P1]

**问题**: RSI 过滤、价格确认等待、连续确认三层过滤共计延迟入场约 9 分钟（2/18 数据），导致系统在最差时机入场。

**修改文件**: `api/src/services/strategies/option-intraday-strategy.ts`

#### 8a-1. RSI 过滤阈值改为极端值

**修改位置**: line 719-720

**当前代码**:
```typescript
const oversoldThreshold = rsiFilterCfg?.oversoldThreshold ?? 25;
const overboughtThreshold = rsiFilterCfg?.overboughtThreshold ?? 75;
```

**修改后**:
```typescript
// 修改：RSI 阈值从 25/75 改为 5/95（仅过滤极端值）
// 理由：RSI 超卖时 CALL 正是最佳入场点，超买时 PUT 正是最佳入场点
// 复盘 Section 14.1：2/18 全天 1,231 次 RSI 过滤拦截，通过率仅 0.3%
const oversoldThreshold = rsiFilterCfg?.oversoldThreshold ?? 5;
const overboughtThreshold = rsiFilterCfg?.overboughtThreshold ?? 95;
```

#### 8a-2. 价格确认 bypass

**修改位置**: line 751

**当前代码**:
```typescript
const requiredCycles = this.cfg.consecutiveConfirmCycles ?? 2;
```

**修改后**:
```typescript
// 修改：连续确认默认值从 2 改为 1（跳过价格确认等待）
// 理由：价格确认在 2/18 延迟了 9 分钟（1,801 次 "移动 < 0.03%" 拦截）
// 设为 1 时整个 if (requiredCycles > 1) 分支不执行，直接跳过价格确认
const requiredCycles = this.cfg.consecutiveConfirmCycles ?? 1;
```

这样 line 752 的 `if (requiredCycles > 1)` 条件不满足，整个价格确认逻辑被 bypass，无需删除代码。如果通过 DB 配置设置了 `consecutiveConfirmCycles: 2`，仍会生效，保留了配置覆盖能力。

**注意事项**:
- RSI 阈值修改：5/95 只过滤极端异常值（如数据错误），正常交易不受影响
- 价格确认 bypass：不删除代码，仅修改默认值，通过 DB 可随时恢复
- 这些修改仅影响期权策略（`OptionIntradayStrategy`），股票策略（如果存在）不受影响

---

### Fix 8b — 反向策略 + Kill Switch [P1]

**问题**: 复盘 Section 14 证明评分系统在趋势极端点产生最强信号。2/17 极端看空 -> 买 PUT -> 标的反弹亏损；2/18 极端看多 -> 买 CALL -> 标的下跌亏损。如果反向操作，两天合计可盈利 +$351。

**修改文件**: `api/src/services/strategies/option-intraday-strategy.ts`

**修改位置 1**: 类属性声明，在 `scoreHistory` 之后新增 kill switch 状态

**新增代码**:
```typescript
// 反向策略 kill switch：连续亏损自动禁用
private reverseStrategyKillSwitch: {
  consecutiveLosses: number;
  disabled: boolean;
  lastResetDate: string;
} = { consecutiveLosses: 0, disabled: false, lastResetDate: '' };

// 反向策略极端阈值
private static readonly EXTREME_THRESHOLD = 15;
// kill switch 阈值：连续 3 次亏损超过 -20% 则禁用
private static readonly KILL_SWITCH_MAX_LOSSES = 3;
```

**修改位置 2**: 在 `generateSignal()` 方法中，策略评估通过并确定 direction 后（line 691-694 的 `selectedStrategy`、`direction`、`strategyReason` 赋值之后），动量衰减检测之前，插入反向策略逻辑

**新增代码**:
```typescript
// 5.1) 反向策略：极端得分时反向交易
// 理由：评分系统在趋势末端产生最极端信号，极端看空 -> 买 CALL（赌反弹），极端看多 -> 买 PUT（赌回调）
if (is0DTEEntry) {
  // 每日重置 kill switch
  const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
  if (this.reverseStrategyKillSwitch.lastResetDate !== todayStr) {
    this.reverseStrategyKillSwitch = {
      consecutiveLosses: 0,
      disabled: false,
      lastResetDate: todayStr,
    };
  }

  const absScore = Math.abs(optionRec.finalScore);
  if (absScore >= OptionIntradayStrategy.EXTREME_THRESHOLD && !this.reverseStrategyKillSwitch.disabled) {
    const originalDirection = direction;
    direction = optionRec.finalScore <= -OptionIntradayStrategy.EXTREME_THRESHOLD ? 'CALL' : 'PUT';
    logger.info(
      `[反向策略] ${symbol} 得分${optionRec.finalScore.toFixed(1)}达到极端值(阈值${OptionIntradayStrategy.EXTREME_THRESHOLD})，` +
      `采用反向交易：${originalDirection} -> ${direction}`
    );
    // 验证反向目标策略类型是否在前端配置中启用
    const reverseTargetType = direction === 'CALL' ? 'DIRECTIONAL_CALL' : 'DIRECTIONAL_PUT';
    const enabledBuyer = this.cfg.strategyTypes?.buyer ?? [];
    if (!enabledBuyer.includes(reverseTargetType)) {
      logger.warn(
        `[反向策略] ${symbol} 反向目标${reverseTargetType}未在前端配置中启用（当前启用: ${enabledBuyer.join(', ')}），` +
        `跳过反向策略，保持原方向${originalDirection}`
      );
      direction = originalDirection; // 恢复原方向
      logData.reverseStrategy = false;
    } else {
      strategyReason = `[反向策略] 极端得分${optionRec.finalScore.toFixed(1)}，反向${direction} | ` + strategyReason;
    }
  } else if (this.reverseStrategyKillSwitch.disabled) {
    logger.warn(
      `[反向策略] ${symbol} kill switch 已触发（连续${this.reverseStrategyKillSwitch.consecutiveLosses}次亏损），` +
      `保持原方向${direction}`
    );
  }
}
```

**修改位置 3**: 在 `strategy-scheduler.service.ts` 中，卖出成交处理后更新 kill switch（需传递亏损信息回策略实例）

这部分逻辑较复杂，建议通过在 `strategy-scheduler.service.ts` 的卖出成交回调中调用策略实例的新方法实现：

```typescript
// 在 OptionIntradayStrategy 类中新增方法
public updateReverseStrategyKillSwitch(pnlPercent: number): void {
  if (pnlPercent <= -20) {
    this.reverseStrategyKillSwitch.consecutiveLosses++;
    if (this.reverseStrategyKillSwitch.consecutiveLosses >= OptionIntradayStrategy.KILL_SWITCH_MAX_LOSSES) {
      this.reverseStrategyKillSwitch.disabled = true;
      logger.warn(
        `[反向策略] kill switch 触发！连续${this.reverseStrategyKillSwitch.consecutiveLosses}次亏损超过-20%，` +
        `今日剩余时间禁用反向策略`
      );
    }
  } else {
    // 非大幅亏损，重置计数器
    this.reverseStrategyKillSwitch.consecutiveLosses = 0;
  }
}
```

**注意事项**:
- 极端阈值 15 基于复盘分析：2/17 得分 -15.7，2/18 得分 +13.9，取 15 作为分界线
- Kill switch 每日重置，基于美东时间日期
- Kill switch 触发条件：连续 3 次亏损超过 -20%（非累计，必须连续）
- 反向策略仅在 0DTE 入场时生效
- 反向策略仅适用于 DIRECTIONAL_CALL / DIRECTIONAL_PUT，不影响 STRADDLE_BUY / BULL_SPREAD / BEAR_SPREAD
- 反向策略触发前验证目标策略类型（反转后的 DIRECTIONAL_CALL 或 DIRECTIONAL_PUT）在 config.strategyTypes.buyer 中已启用
- 当 `|finalScore| >= 15` 时反向，否则保持原有趋势追踪逻辑

---

### Fix 8c — 反向策略跳过 VWAP 结构确认 [P1]

**问题**: 反向策略入场方向与 VWAP 结构天然矛盾。极端看空时(score <= -15)价格在 VWAP 下方，反向买 CALL 需要收盘 > VWAP → 必定被拦截。极端看多时反之。如果不处理，反向策略几乎永远无法入场。

**修改文件**: `api/src/services/strategies/option-intraday-strategy.ts`

**修改位置**: VWAP 结构确认逻辑，line 847-915

**当前代码** (line 847-850):
```typescript
// 7) VWAP 结构确认
try {
  const vwapData = await marketDataService.getIntradayVWAP(symbol);
  if (vwapData && vwapData.dataPoints > 0) {
```

**修改方案**: 在 VWAP 结构确认入口处添加 `skipVwapForReverse` 判断

```typescript
// 7) VWAP 结构确认
// Fix 8c: 反向策略触发时跳过 VWAP 方向检查
// 理由: 反向策略本质是"逆结构"入场，VWAP 方向检查会拦截所有反向信号
const isReverseEntry = logData.reverseStrategy === true; // 由 Fix 8b 在前面设置
if (isReverseEntry) {
  logger.info(
    `[结构确认] ${symbol} 反向策略入场，跳过 VWAP 结构方向检查` +
    `（得分${optionRec.finalScore.toFixed(1)}，方向${direction}）`
  );
  // 跳过整个 VWAP 结构确认，直接进入合约选择
} else {
  // 非反向策略：保留完整的 VWAP 结构确认
  try {
    const vwapData = await marketDataService.getIntradayVWAP(symbol);
    if (vwapData && vwapData.dataPoints > 0) {
      // ... 现有 VWAP 确认逻辑不变 ...
    } else {
      if (is0DTEEntry) {
        // Fix 1: VWAP 不可用时拒绝 0DTE
        logger.warn(`[结构确认] ${symbol} VWAP数据不可用，拒绝0DTE入场（安全网失效）`);
        logData.finalResult = 'NO_SIGNAL';
        logData.rejectionReason = 'VWAP_UNAVAILABLE_0DTE_BLOCKED';
        logData.rejectionCheckpoint = 'structure_confirm';
        this.logDecision(logData);
        return null;
      }
      logger.debug(`[结构确认] ${symbol} VWAP数据不可用，跳过结构确认（降级放行，非0DTE）`);
    }
  } catch (structErr: any) {
    if (is0DTEEntry) {
      logger.warn(`[结构确认] ${symbol} 异常: ${structErr.message}，拒绝0DTE入场`);
      logData.finalResult = 'NO_SIGNAL';
      logData.rejectionReason = `VWAP_ERROR_0DTE_BLOCKED: ${structErr.message}`;
      logData.rejectionCheckpoint = 'structure_confirm';
      this.logDecision(logData);
      return null;
    }
    logger.warn(`[结构确认] ${symbol} 异常: ${structErr.message}，跳过结构确认（降级放行，非0DTE）`);
  }
}
```

**联动修改**: Fix 8b 代码中需要设置 `logData.reverseStrategy = true`，在反向策略生效时标记：

```typescript
// 在 Fix 8b 的反向策略代码中，direction 被反转后，添加：
logData.reverseStrategy = true;
```

**注意事项**:
- 仅在反向策略触发时（`|score| >= 15` 且 kill switch 未触发）跳过 VWAP
- 非极端信号（`|score| < 15`）仍然保留完整的 VWAP 结构确认
- VWAP 不可用时的 0DTE 拒绝（Fix 1）仍然在非反向路径生效
- 反向路径虽然跳过 VWAP 方向检查，但 TSLPPCT trailing 10% 和 kill switch 仍然提供风险保护

**测试用例**:

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 反向 CALL + 价格 < VWAP | score=-20, direction=CALL(反转), 收盘 < VWAP | 跳过 VWAP，允许入场 |
| 反向 PUT + 价格 > VWAP | score=+18, direction=PUT(反转), 收盘 > VWAP | 跳过 VWAP，允许入场 |
| 非极端 CALL + 价格 < VWAP | score=+13, direction=CALL, 收盘 < VWAP | VWAP 拦截，拒绝入场 |
| 非极端 PUT + 价格 > VWAP | score=-13, direction=PUT, 收盘 > VWAP | VWAP 拦截，拒绝入场 |
| Kill switch 触发 + 极端得分 | score=-20, killSwitch.disabled=true | 保持原方向 PUT，VWAP 正常检查 |

---

### Fix 6 — 动态调整盈亏比例 [P2]

**问题**: 市价单成交价可能与信号价有偏差，偏差越大说明市场波动越大，应收紧止损/止盈。

**修改文件**: `api/src/services/strategy-scheduler.service.ts`

**修改位置**: TSLPPCT 保护单提交逻辑，line 828-865

**当前代码** (line 840-843):
```typescript
const trailingPct = trailingStopProtectionService.getTrailingPercentForPhase({
  phase: 'EARLY',
  is0DTE,
});
```

**修改后**:
```typescript
let trailingPct = trailingStopProtectionService.getTrailingPercentForPhase({
  phase: 'EARLY',
  is0DTE,
});

// Fix 6: 动态调整 — 实际成交价与信号价偏差大时收紧 trailing
if (is0DTE && context.intent?.entryPrice) {
  const signalPrice = context.intent.entryPrice;
  const filledPrice = parseFloat(dbOrder.filled_price || dbOrder.price || '0');
  if (filledPrice > 0 && signalPrice > 0) {
    const actualDeviation = Math.abs((filledPrice - signalPrice) / signalPrice);
    if (actualDeviation > 0.02) {
      // 偏差 > 2%: 收紧 trailing，偏差每 1% 收紧 0.5%，最多收紧至 8%
      const adjustment = Math.min(actualDeviation * 50, trailingPct - 8);
      if (adjustment > 0) {
        const adjustedTrailing = Math.max(trailingPct - adjustment, 8);
        logger.info(
          `[动态调整] ${tradedSym} 0DTE 成交偏差${(actualDeviation * 100).toFixed(2)}%` +
          `(信号${signalPrice.toFixed(2)} vs 成交${filledPrice.toFixed(2)})，` +
          `trailing从${trailingPct}%调整为${adjustedTrailing.toFixed(1)}%`
        );
        trailingPct = adjustedTrailing;
      }
    }
  }
}
```

**注意事项**:
- 当前代码 (line 737-752) 已经对所有期权订单使用市价单，无需修改订单类型逻辑
- 动态调整仅在偏差 > 2% 时触发，避免小幅正常偏差也触发调整
- trailing 最低不低于 8%，防止过于敏感

---

### Fix 9 — 日志 NaN 修复 [P2]

**问题**: `strategy-scheduler.service.ts` 中卖出成交记录使用 `pnl.netPnLPercent`，当手续费数据不可靠时（美股 T+1 结算）产生 NaN。决策逻辑已全部使用 `grossPnLPercent`（在 `option-dynamic-exit.service.ts` 中已验证），仅日志输出仍使用 `netPnLPercent`。

**修改文件**: `api/src/services/strategy-scheduler.service.ts`

**修改位置**: line 2950, 2966, 2983

**当前代码** (line 2950):
```typescript
exitPnLPercent: pnl.netPnLPercent,
```

**修改后**:
```typescript
exitPnLPercent: pnl.grossPnLPercent,
```

**当前代码** (line 2966):
```typescript
netPnLPercent: pnl.netPnLPercent,
```

**修改后**:
```typescript
netPnLPercent: pnl.grossPnLPercent, // 使用 grossPnLPercent 避免 NaN（美股T+1手续费不可靠）
```

**当前代码** (line 2983):
```typescript
netPnLPercent: pnl.netPnLPercent,
```

**修改后**:
```typescript
netPnLPercent: pnl.grossPnLPercent,
```

**注意事项**:
- `grossPnLPercent` 不包含手续费计算，避免了手续费数据缺失导致的 NaN
- `option-dynamic-exit.service.ts` 中的决策逻辑已全部使用 `grossPnLPercent`（从 grep 结果确认），此处仅修复日志/记录层面的残留问题
- 字段名保留 `netPnLPercent` 以保持数据库兼容性，实际值为 gross（注释说明）

---

### Fix 10 — 资金差异修复 [P2]

**问题**: 策略记录的资金使用量与实际持仓价值不一致。

**修改文件**: `api/src/services/capital-manager.service.ts`

**分析方向**:
- 订单成交时的 `allocationAmount` 是基于信号价 * 合约数 * 乘数 + 手续费估算
- 实际成交价可能与信号价不同（市价单），导致记录的分配金额与实际成本不一致
- 卖出时释放的资金应基于实际买入成本，而非信号价估算

**修改方案**: 在 `strategy-scheduler.service.ts` 中买入成交确认后，使用实际成交价更新 `allocationAmount`：

```typescript
// 在买入订单成交处理中（约 line 815-824），成交后更新分配金额
const actualCost = filledPrice * filledQuantity * (optMeta?.multiplier || 100);
if (Math.abs(actualCost - allocationAmount) > 1) {
  logger.info(
    `[资金修正] ${instanceKeySymbol} 预估分配$${allocationAmount.toFixed(2)} -> ` +
    `实际成本$${actualCost.toFixed(2)}，差额$${(actualCost - allocationAmount).toFixed(2)}`
  );
  // 更新资金管理器中的记录
  await capitalManager.adjustAllocation(strategyId, instanceKeySymbol, actualCost - allocationAmount);
}
```

**注意事项**:
- 需要确认 `capitalManager` 是否有 `adjustAllocation` 方法，如果没有需要新增
- 此修复为低优先级，优先确保核心修复（Fix 2.5/1/2/5）部署

---

### Fix 11 — 退出后动态冷却期 [P1]

**问题**: 当前 LATE 时段退出后固定 3 分钟冷却期，对 0DTE 期权不合理（6.5 小时总窗口），是"每天只交易一只股票"的因素之一。

**修改文件**: `api/src/services/strategy-scheduler.service.ts`

**修改位置**: LATE 时段冷却期逻辑，line 1333-1341

**当前代码** (line 1333-1341):
```typescript
// LATE时段冷却期：同一标的平仓后N分钟内不重新开仓
const cooldownMinutes = strategyConfig?.latePeriod?.cooldownMinutes ?? 3;
if (cancelCtx?.lastExitTime && cooldownMinutes > 0) {
  const exitElapsed = Date.now() - new Date(cancelCtx.lastExitTime).getTime();
  if (exitElapsed < cooldownMinutes * 60000) {
    summary.idle.push(`${symbol}(COOLDOWN_${Math.ceil((cooldownMinutes * 60000 - exitElapsed) / 60000)}m)`);
    return;
  }
}
```

**修改后**:
```typescript
// LATE时段冷却期：根据当日交易次数动态调整
// 0DTE 初期无冷却（快速抓机会），后续递增（防止过度交易）
const dailyTradeCount = cancelCtx?.dailyTradeCount ?? 0;
const is0DTEContext = cancelCtx?.optionMeta?.expirationMode === '0DTE'
  || cancelCtx?.is0DTE === true;

let cooldownMinutes: number;
if (is0DTEContext) {
  if (dailyTradeCount <= 1) {
    cooldownMinutes = 0; // 前 1-2 笔：无冷却
  } else if (dailyTradeCount <= 3) {
    cooldownMinutes = 1; // 第 3-4 笔：1 分钟
  } else {
    cooldownMinutes = 3; // 第 5 笔起：3 分钟
  }
} else {
  cooldownMinutes = strategyConfig?.latePeriod?.cooldownMinutes ?? 3;
}

if (cancelCtx?.lastExitTime && cooldownMinutes > 0) {
  const exitElapsed = Date.now() - new Date(cancelCtx.lastExitTime).getTime();
  if (exitElapsed < cooldownMinutes * 60000) {
    summary.idle.push(
      `${symbol}(COOLDOWN_${Math.ceil((cooldownMinutes * 60000 - exitElapsed) / 60000)}m_trade#${dailyTradeCount})`
    );
    return;
  }
}
```

**联动修改**: 卖出成交处理中需要递增 `dailyTradeCount`：

在 `strategy-scheduler.service.ts` 的卖出成交回调中（约 line 867-900），状态更新为 IDLE 时，同时更新计数器：

```typescript
// 在 updateState(symbol, 'IDLE', ...) 时添加
await strategyInstance.updateState(instanceKeySymbol, 'IDLE', {
  ...existingContext,
  dailyTradeCount: (existingContext.dailyTradeCount || 0) + 1,
  lastExitTime: new Date().toISOString(),
});
```

**注意事项**:
- `dailyTradeCount` 在策略调度的每日重置逻辑中自动归零（如果存在），或在首次检测到新日期时重置
- `is0DTEContext` 需要从 context 中判断，因为此处不在策略实例内部
- 非 0DTE 不受影响，保持原有固定 3 分钟冷却
- 前 2 笔 0DTE 交易无冷却，最大化早期交易机会

**测试用例**:

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 0DTE 首笔退出 | dailyTradeCount=0, is0DTE=true | cooldownMinutes=0，无冷却 |
| 0DTE 第 2 笔退出 | dailyTradeCount=1, is0DTE=true | cooldownMinutes=0，无冷却 |
| 0DTE 第 3 笔退出 | dailyTradeCount=2, is0DTE=true | cooldownMinutes=1 |
| 0DTE 第 5 笔退出 | dailyTradeCount=4, is0DTE=true | cooldownMinutes=3 |
| 1DTE 首笔退出 | dailyTradeCount=0, is0DTE=false | cooldownMinutes=3（默认） |

---

## 4. 测试方案

### Fix 2.5 — TSLPPCT 到期日修复

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 0DTE 到期日 = 今天 | expireDate = '2026-02-19' (今天) | effectiveExpireDate = '2026-02-20' (明天) |
| 1DTE 到期日 = 明天 | expireDate = '2026-02-20' (明天) | effectiveExpireDate = '2026-02-20' (不变) |
| 2DTE 到期日 = 后天 | expireDate = '2026-02-21' | effectiveExpireDate = '2026-02-21' (不变) |
| 周五 0DTE | expireDate = '2026-02-21' (周五), today = '2026-02-21' | effectiveExpireDate = '2026-02-22' (周六) |
| TSLPPCT 成功提交 | 使用修复后的到期日 | orderId 非空，无 "expire date should be after today's date" 错误 |

### Fix 1 — VWAP 降级拒绝

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 0DTE + VWAP 不可用 | is0DTEEntry=true, vwapData=null | 返回 null, rejectionReason='VWAP_UNAVAILABLE_0DTE_BLOCKED' |
| 1DTE + VWAP 不可用 | is0DTEEntry=false, vwapData=null | 继续执行（降级放行） |
| 0DTE + VWAP 异常 | is0DTEEntry=true, throw Error | 返回 null, rejectionReason 包含 'VWAP_ERROR_0DTE_BLOCKED' |
| 0DTE + VWAP 正常 | is0DTEEntry=true, vwapData 有效 | 正常执行结构确认逻辑 |

### Fix 2 — VWAP napi 修复

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| TradeSessions 枚举正常 | SDK 正常导出 | 使用 SDK 枚举值 |
| TradeSessions 枚举失败 | napi 转换错误 | 使用默认值 100，无报错 |
| candlesticks 正常返回 | 传入 tradeSessionsAll=100 | 返回有效 K 线数据 |
| 集成测试：开盘时段获取 VWAP | 实际 SDK 调用 | VWAP 数据非空，dataPoints > 0 |

### Fix 5 — TSLPPCT trailing 10%

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 0DTE trailing | is0DTE=true, 基础 tp=20 | 返回 10 (min(20, 10)) |
| 0DTE trailing 已低于 10 | is0DTE=true, 基础 tp=8 | 返回 8 (min(8, 10) = 8) |
| 1DTE trailing | is0DTE=false, 基础 tp=20 | 返回 20 (不受 0DTE 收紧影响) |

### Fix 3 — 动量衰减检测

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 得分从 -17.6 回归至 -15.7 | prev=-17.6, curr=-15.7, is0DTE=true | 拒绝入场（|-15.7| < |-17.6| 且 |-15.7| >= |-17.6|*0.8） |
| 得分持续恶化 -15 -> -17 | prev=-15, curr=-17, is0DTE=true | 允许入场（|-17| > |-15|，动量增强） |
| 得分大幅回归 -17.6 -> -5 | prev=-17.6, curr=-5, is0DTE=true | 允许入场（|-5| < |-17.6|*0.8，已大幅回归） |
| 超过 60 秒 | prev 时间 > 60s ago | 视为新信号，允许入场 |
| 非 0DTE | prev=-17.6, curr=-15.7, is0DTE=false | 不检测，直接通过 |

### Fix 8a — 移除延迟过滤

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| RSI=77 PUT | RSI=77, direction=PUT | 通过（77 > 5，不触发极端过滤） |
| RSI=82 CALL | RSI=82, direction=CALL | 通过（82 < 95，不触发极端过滤） |
| RSI=3 PUT | RSI=3, direction=PUT | 拒绝（3 < 5，极端超卖） |
| RSI=97 CALL | RSI=97, direction=CALL | 拒绝（97 > 95，极端超买） |
| 连续确认 default | 无 DB 配置覆盖 | requiredCycles=1, 跳过价格确认 |

### Fix 8b — 反向策略 + Kill Switch

| 用例 | 输入 | 预期输出 |
|------|------|---------|
| 极端看空 -17 | finalScore=-17, is0DTE=true | 方向从 PUT 反转为 CALL |
| 极端看多 +16 | finalScore=+16, is0DTE=true | 方向从 CALL 反转为 PUT |
| 非极端 -13 | finalScore=-13, is0DTE=true | 保持原方向 PUT |
| Kill switch 触发 | 连续 3 次亏损 > -20% | disabled=true，保持原方向 |
| Kill switch 每日重置 | 新日期 | disabled=false, consecutiveLosses=0 |
| 反向目标未启用 | score=-17, config只启用DIRECTIONAL_PUT | 跳过反向，保持 PUT 方向 |
| 反向目标已启用 | score=-17, config启用DIRECTIONAL_CALL+PUT | 反向为 CALL |
| STRADDLE不受反向影响 | score=-17, selectedStrategy=STRADDLE_BUY | 不触发反向策略 |

---

## 5. 部署方案

### 第一批：P0 修复（立即部署）

部署顺序（存在依赖关系）：
1. **Fix 2** — VWAP napi 修复（无依赖，独立修复）
2. **Fix 1** — VWAP 降级拒绝（依赖 Fix 2 验证 VWAP 可用性）
3. **Fix 2.5** — TSLPPCT 到期日修复（Fix 5 的前提）
4. **Fix 5** — TSLPPCT trailing 10%（依赖 Fix 2.5）

验收标准：
- VWAP 在开盘时段获取成功率 > 95%
- TSLPPCT 对 0DTE 期权成功提交（无 "expire date" 错误）
- 0DTE 在 VWAP 不可用时被拒绝入场

### 第二批：P1 修复（本周内部署）

部署顺序（相互独立，可并行）：
1. **Fix 4** — 禁入窗口 30->15 分钟（DB 配置修改）
2. **Fix 3** — 动量衰减检测
3. **Fix 8a** — 移除延迟过滤
4. **Fix 8b** — 反向策略 + kill switch（默认启用 kill switch）
5. **Fix 7** — K 线价格位置检测
6. **Fix 8c** — 反向策略跳过 VWAP（Fix 8b 的联动修改）
7. **Fix 11** — 动态冷却期

验收标准：
- 信号生成通过率从 0.3% 提升至 > 5%
- 反向策略在回测中覆盖 2/17 和 2/18 场景

### 第三批：P2 修复（下周部署）

1. **Fix 6** — 动态调整盈亏比例
2. **Fix 9** — 日志 NaN 修复
3. **Fix 10** — 资金差异修复

---

## 6. 回滚方案

| 修复 | 回滚方式 | 说明 |
|------|---------|------|
| Fix 1 (VWAP 降级拒绝) | 将 `is0DTEEntry` 判断改回直接放行 | 一行代码回滚 |
| Fix 2 (VWAP napi) | 恢复 `TradeSessions?.All \|\| 100` 写法 | 低风险，回滚意义不大 |
| Fix 2.5 (TSLPPCT 到期日) | 移除 effectiveExpireDate 逻辑 | 回滚后 0DTE TSLPPCT 重新失效 |
| Fix 3 (动量衰减) | 注释或删除 scoreHistory 检测块 | 独立模块，不影响其他逻辑 |
| Fix 4 (禁入窗口) | DB 配置改回 `zdteCooldownMinutes: 30` | SQL 一行修改 |
| Fix 5 (trailing 10%) | 将 `Math.min(tp, 10)` 改回 `Math.min(tp, 15)` | 一行代码回滚 |
| Fix 6 (动态调整) | 移除偏差检测和 trailing 调整块 | 独立逻辑块 |
| Fix 7 (价格位置) | 移除 `checkOptionPricePosition` 调用 | 独立方法 |
| Fix 8a (移除过滤) | 恢复默认值 `oversoldThreshold=25, overboughtThreshold=75, consecutiveConfirmCycles=2` | 三处常量修改 |
| Fix 8b (反向策略) | kill switch 自动触发即为回滚；或手动设 `disabled=true` | kill switch 自带回滚能力 |
| Fix 9 (NaN 修复) | 恢复 `netPnLPercent` | 回滚意义不大 |
| Fix 8c (VWAP 跳过) | 移除 `isReverseEntry` 判断，恢复统一 VWAP 检查 | 独立条件分支 |
| Fix 11 (动态冷却) | 移除动态计算，恢复固定 `cooldownMinutes = 3` | 一行代码回滚 |

---

## 7. 风险评估

### 高风险

| 风险项 | 影响 | 概率 | 缓解措施 |
|--------|------|------|---------|
| 反向策略在趋势延续行情中亏损 | 极端得分后趋势继续而非反转，反向交易亏损 | 中 | kill switch 连续 3 次亏损 > -20% 自动禁用；TSLPPCT 10% trailing 限制单笔最大亏损 |
| 移除过滤层后假信号增加 | RSI/价格确认移除后，非极端场景也可能入场 | 中 | TSLPPCT + 动态止损作为安全网；非极端信号仍保留 VWAP 结构确认 |

### 中风险

| 风险项 | 影响 | 概率 | 缓解措施 |
|--------|------|------|---------|
| TSLPPCT trailing 10% 过于敏感 | 正常波动提前触发止损，频繁止损侵蚀收益 | 中 | 观察 1 周数据，如触发率过高可调回 12% |
| 禁入窗口缩短后开盘噪声入场 | 09:30-09:45 信号噪声大，可能产生假信号 | 低 | 非极端信号保留 VWAP 结构确认，可过滤假信号 |

### 低风险

| 风险项 | 影响 | 概率 | 缓解措施 |
|--------|------|------|---------|
| VWAP napi 修复后仍失败 | 硬编码 100 不正确 | 极低 | 值 100 已通过现有代码 fallback 验证 |
| TSLPPCT 到期日修复引入新问题 | 明天过期的 TSLPPCT 在券商侧行为异常 | 极低 | TSLPPCT 的 expireDate 是订单有效期，非期权到期日 |
| 日志 NaN 修复影响数据一致性 | grossPnLPercent 与 netPnLPercent 数值差异 | 低 | 添加注释说明，保持字段名兼容 |

### 综合风险评估

反向策略是最大的未知风险，但已通过以下措施缓解：
1. **Kill switch 自动禁用**: 连续 3 次大幅亏损后当日禁用
2. **TSLPPCT 10% trailing**: 无论方向对错，最大亏损被限制在约 10%
3. **每日重置**: 隔天重新启用，不会因单日表现永久禁用
4. **VWAP 结构确认**: 非极端信号保留 VWAP 检查；反向策略（|score| >= 15）跳过 VWAP 方向检查（Fix 8c）

---

## 8. 策略类型适配说明

### 系统支持的策略类型

前端配置页面（`EditStrategyModal.tsx` lines 466-577）提供以下策略类型选择：

| 前端名称 | 代码枚举 | 评估方法 | 默认状态 |
|---------|---------|---------|---------|
| 单边买Call | `DIRECTIONAL_CALL` | `evaluateDirectionalBuyer()` | 启用 |
| 单边买Put | `DIRECTIONAL_PUT` | `evaluateDirectionalBuyer()` | 启用 |
| 跨式买入 | `STRADDLE_BUY` | `evaluateStraddleBuy()` | 启用 |
| 牛市价差 | `BULL_SPREAD` | `evaluateSpreadStrategy()` | 禁用 |
| 熊市价差 | `BEAR_SPREAD` | `evaluateSpreadStrategy()` | 禁用 |

### 配置数据流

```
前端 EditStrategyModal.tsx
  → config.strategyTypes.buyer[] / directional[]
  → DB strategies.config (JSONB)
  → Backend getEnabledStrategies()
  → generateSignal() 策略评估循环（line 639-696）
```

### 各修复项对策略类型的影响

| 修复项 | DIRECTIONAL_CALL | DIRECTIONAL_PUT | STRADDLE_BUY | BULL_SPREAD | BEAR_SPREAD |
|--------|:---:|:---:|:---:|:---:|:---:|
| Fix 1 (VWAP降级拒绝) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 2 (VWAP napi) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 2.5 (TSLPPCT到期日) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 3 (动量衰减) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 4 (冷却窗口) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 5 (trailing 10%) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 6 (动态调整) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 7 (价格位置) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 8a (移除过滤) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 8b (反向策略) | ✅ 反转 | ✅ 反转 | ❌ 不适用 | ❌ 不适用 | ❌ 不适用 |
| Fix 8c (VWAP跳过) | ✅ | ✅ | ❌ 无方向 | ✅ | ✅ |
| Fix 9 (NaN修复) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 10 (资金修复) | ✅ | ✅ | ✅ | ✅ | ✅ |
| Fix 11 (动态冷却) | ✅ | ✅ | ✅ | ✅ | ✅ |

### 反向策略 (Fix 8b) 策略类型限制

反向策略仅适用于 `DIRECTIONAL_CALL` 和 `DIRECTIONAL_PUT`：
- **STRADDLE_BUY**: 基于 VIX 触发，方向中性，"反向"无意义
- **BULL_SPREAD / BEAR_SPREAD**: 价差策略本质是方向确认策略，不适合逆向操作
- 反向策略触发时，系统检查反转后的目标策略类型是否在前端 `config.strategyTypes.buyer` 中启用
- 若目标未启用（如只开了单边买Put，反向目标 DIRECTIONAL_CALL 不在列表中），则跳过反向，保持原方向

### 前端配置参数说明

前端配置中与本次修复相关的参数：

| 参数 | 位置 | 说明 | 与修复的关系 |
|------|------|------|------------|
| 策略类型（多选） | `config.strategyTypes` | 控制哪些策略参与评估 | Fix 8b 反向策略需检查目标类型是否启用 |
| 强平时间 | `config.exitRules.forceExitMinutes` | 收盘前 N 分钟强制平仓（固定30分钟） | 无直接影响，保持现有逻辑 |
| 风险偏好 | `config.riskPreference` | CONSERVATIVE / AGGRESSIVE | 影响评分阈值，间接影响反向策略触发频率 |

---

---

## 9. 实施记录

### 已完成修复项

| 编号 | 状态 | 修改文件 | 变更行数 |
|------|------|---------|---------|
| Fix 1 | ✅ 已实施 | `option-intraday-strategy.ts` | +15 |
| Fix 2 | ✅ 已实施 | `market-data.service.ts` | +27 |
| Fix 2.5 | ✅ 已实施 | `trailing-stop-protection.service.ts` | +12 |
| Fix 3 | ✅ 已实施 | `option-intraday-strategy.ts` | +25 |
| Fix 4 | ✅ 已实施 | `option-intraday-strategy.ts` | +22 |
| Fix 5 | ✅ 已实施 | `trailing-stop-protection.service.ts` | +4 |
| Fix 6 | ✅ 已实施 | `strategy-scheduler.service.ts` | +22 |
| Fix 7 | ⏳ 待实施 | `option-intraday-strategy.ts` | — |
| Fix 8a | ✅ 已实施 | `option-intraday-strategy.ts` | +6 |
| Fix 8b | ✅ 已实施 | `option-intraday-strategy.ts` + `strategy-scheduler.service.ts` | +50 |
| Fix 8c | ✅ 已实施 | `option-intraday-strategy.ts` | +8 |
| Fix 9 | ✅ 已实施 | `strategy-scheduler.service.ts` | +3 |
| Fix 10 | ✅ 已实施 | `strategy-scheduler.service.ts` | +18 |
| Fix 11 | ✅ 已实施 | `strategy-scheduler.service.ts` | +22 |

### 总变更统计

```
4 files changed, 288 insertions(+), 22 deletions(-)
api/src/services/market-data.service.ts            |  27 +++-
api/src/services/strategies/option-intraday-strategy.ts | 173 +++++++++-
api/src/services/strategy-scheduler.service.ts     |  88 +++++-
api/src/services/trailing-stop-protection.service.ts   |  22 ++-
```

### 待实施项

- **Fix 7 (K线价格位置检测)**: 需要实现 `checkOptionPricePosition()` 方法和调用逻辑。此修复依赖期权K线数据的可靠获取，当前 VWAP 接口返回的 K 线是标的K线而非期权K线，需要确认数据源后再实施。
- **Fix 4 DB配置**: `zdteCooldownMinutes: 30 -> 15` 需要手动执行 SQL 修改数据库配置。

### TypeScript编译验证

编译通过，仅有预存在的模块声明缺失错误（swagger-jsdoc、pg-query-stream等），无新增错误。

**版本**: v4.0
**最后更新**: 2026-02-19
**状态**: 已实施

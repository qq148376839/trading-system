version: '3.8'

services:
  # PostgreSQL 数据库
  postgres:
    image: postgres:16-alpine
    container_name: trading-postgres
    environment:
      # 支持从项目根目录的 .env 文件读取，如果没有则使用默认值
      POSTGRES_USER: ${POSTGRES_USER:-trading_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-trading_password}
      POSTGRES_DB: ${POSTGRES_DB:-trading_db}
    # 注意：不映射外部端口，因为容器之间通过 Docker 网络通信
    # 如果需要从宿主机访问数据库，可以取消下面的注释并修改端口号
    # ports:
    #   - "5433:5432"  # 使用 5433 避免与系统 PostgreSQL 冲突
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # 只挂载初始化脚本，避免执行历史迁移脚本
      - ./api/migrations/000_init_schema.sql:/docker-entrypoint-initdb.d/000_init_schema.sql:ro
    healthcheck:
      # 健康检查也使用环境变量
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-trading_user} -d ${POSTGRES_DB:-trading_db}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - trading-network

  # API 服务
  api:
    build:
      context: ./api
      dockerfile: Dockerfile
    container_name: trading-api
    environment:
      # 数据库连接URL，支持从环境变量读取账号密码
      DATABASE_URL: postgresql://${POSTGRES_USER:-trading_user}:${POSTGRES_PASSWORD:-trading_password}@postgres:5432/${POSTGRES_DB:-trading_db}
      PORT: 3001
      NODE_ENV: production
      # 长桥API配置（需要从环境变量或 .env 文件提供）
      LONGPORT_APP_KEY: ${LONGPORT_APP_KEY:-your_app_key}
      LONGPORT_APP_SECRET: ${LONGPORT_APP_SECRET:-your_app_secret}
      LONGPORT_ACCESS_TOKEN: ${LONGPORT_ACCESS_TOKEN:-your_access_token}
      LONGPORT_ENABLE_OVERNIGHT: ${LONGPORT_ENABLE_OVERNIGHT:-false}
    ports:
      - "3001:3001"
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      # 如果需要热重载，可以挂载源代码（仅开发环境）
      # - ./api/src:/app/src
      # - ./api/dist:/app/dist
      # 注意：如果 api/.env 文件存在，确保其中的 DATABASE_URL 使用服务名 'postgres' 而不是 'localhost'
      # 例如：DATABASE_URL=postgresql://trading_user:trading_password@postgres:5432/trading_db
      - ./api/.env:/app/.env:ro
    networks:
      - trading-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    # 注意：移除了 deploy.resources 配置，因为某些系统（如 Synology NAS）不支持 CPU CFS 调度器
    # 如果需要资源限制，可以通过 Docker 运行时参数或其他方式设置

  # Frontend 服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        # NEXT_PUBLIC_API_URL 必须在构建时传递（作为 build arg）
        # 因为 Next.js 的 NEXT_PUBLIC_* 变量在构建时注入到客户端代码中
        NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-http://localhost:3001}
    container_name: trading-frontend
    environment:
      NODE_ENV: production
    ports:
      - "3000:3000"
    depends_on:
      api:
        condition: service_healthy
    networks:
      - trading-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    # 注意：移除了 deploy.resources 配置，因为某些系统（如 Synology NAS）不支持 CPU CFS 调度器
    # 如果需要资源限制，可以通过 Docker 运行时参数或其他方式设置

volumes:
  postgres_data:

networks:
  trading-network:
    driver: bridge

